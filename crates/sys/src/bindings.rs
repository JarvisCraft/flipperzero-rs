/* automatically generated by rust-bindgen 0.63.0 */

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage> {
    storage: Storage,
}
impl<Storage> __BindgenBitfieldUnit<Storage> {
    #[inline]
    pub const fn new(storage: Storage) -> Self {
        Self { storage }
    }
}
impl<Storage> __BindgenBitfieldUnit<Storage>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        byte & mask == mask
    }
    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        if val {
            *byte |= mask;
        } else {
            *byte &= !mask;
        }
    }
    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
}
#[repr(C)]
#[derive(Default)]
pub struct __IncompleteArrayField<T>(::core::marker::PhantomData<T>, [T; 0]);
impl<T> __IncompleteArrayField<T> {
    #[inline]
    pub const fn new() -> Self {
        __IncompleteArrayField(::core::marker::PhantomData, [])
    }
    #[inline]
    pub fn as_ptr(&self) -> *const T {
        self as *const _ as *const T
    }
    #[inline]
    pub fn as_mut_ptr(&mut self) -> *mut T {
        self as *mut _ as *mut T
    }
    #[inline]
    pub unsafe fn as_slice(&self, len: usize) -> &[T] {
        ::core::slice::from_raw_parts(self.as_ptr(), len)
    }
    #[inline]
    pub unsafe fn as_mut_slice(&mut self, len: usize) -> &mut [T] {
        ::core::slice::from_raw_parts_mut(self.as_mut_ptr(), len)
    }
}
impl<T> ::core::fmt::Debug for __IncompleteArrayField<T> {
    fn fmt(&self, fmt: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        fmt.write_str("__IncompleteArrayField")
    }
}
pub const API_VERSION: u32 = 917504;
pub type wint_t = core::ffi::c_int;
pub type _off_t = core::ffi::c_long;
pub type _fpos_t = core::ffi::c_long;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _mbstate_t {
    pub __count: core::ffi::c_int,
    pub __value: _mbstate_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _mbstate_t__bindgen_ty_1 {
    pub __wch: wint_t,
    pub __wchb: [core::ffi::c_uchar; 4usize],
}
#[test]
fn bindgen_test_layout__mbstate_t__bindgen_ty_1() {
    const UNINIT: ::core::mem::MaybeUninit<_mbstate_t__bindgen_ty_1> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_mbstate_t__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(_mbstate_t__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<_mbstate_t__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(_mbstate_t__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__wch) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_mbstate_t__bindgen_ty_1),
            "::",
            stringify!(__wch)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__wchb) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_mbstate_t__bindgen_ty_1),
            "::",
            stringify!(__wchb)
        )
    );
}
#[test]
fn bindgen_test_layout__mbstate_t() {
    const UNINIT: ::core::mem::MaybeUninit<_mbstate_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_mbstate_t>(),
        8usize,
        concat!("Size of: ", stringify!(_mbstate_t))
    );
    assert_eq!(
        ::core::mem::align_of::<_mbstate_t>(),
        4usize,
        concat!("Alignment of ", stringify!(_mbstate_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__count) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_mbstate_t),
            "::",
            stringify!(__count)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__value) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_mbstate_t),
            "::",
            stringify!(__value)
        )
    );
}
pub type __ULong = core::ffi::c_ulong;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __lock {
    _unused: [u8; 0],
}
pub type _LOCK_T = *mut __lock;
extern "C" {
    pub fn __retarget_lock_init_recursive(lock: *mut _LOCK_T);
}
extern "C" {
    pub fn __retarget_lock_close_recursive(lock: _LOCK_T);
}
extern "C" {
    pub fn __retarget_lock_acquire(lock: _LOCK_T);
}
extern "C" {
    pub fn __retarget_lock_acquire_recursive(lock: _LOCK_T);
}
extern "C" {
    pub fn __retarget_lock_release(lock: _LOCK_T);
}
extern "C" {
    pub fn __retarget_lock_release_recursive(lock: _LOCK_T);
}
pub type _flock_t = _LOCK_T;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __locale_t {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _Bigint {
    pub _next: *mut _Bigint,
    pub _k: core::ffi::c_int,
    pub _maxwds: core::ffi::c_int,
    pub _sign: core::ffi::c_int,
    pub _wds: core::ffi::c_int,
    pub _x: [__ULong; 1usize],
}
#[test]
fn bindgen_test_layout__Bigint() {
    const UNINIT: ::core::mem::MaybeUninit<_Bigint> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_Bigint>(),
        24usize,
        concat!("Size of: ", stringify!(_Bigint))
    );
    assert_eq!(
        ::core::mem::align_of::<_Bigint>(),
        4usize,
        concat!("Alignment of ", stringify!(_Bigint))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._next) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_Bigint),
            "::",
            stringify!(_next)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._k) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_Bigint),
            "::",
            stringify!(_k)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._maxwds) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_Bigint),
            "::",
            stringify!(_maxwds)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._sign) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_Bigint),
            "::",
            stringify!(_sign)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._wds) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_Bigint),
            "::",
            stringify!(_wds)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._x) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_Bigint),
            "::",
            stringify!(_x)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __tm {
    pub __tm_sec: core::ffi::c_int,
    pub __tm_min: core::ffi::c_int,
    pub __tm_hour: core::ffi::c_int,
    pub __tm_mday: core::ffi::c_int,
    pub __tm_mon: core::ffi::c_int,
    pub __tm_year: core::ffi::c_int,
    pub __tm_wday: core::ffi::c_int,
    pub __tm_yday: core::ffi::c_int,
    pub __tm_isdst: core::ffi::c_int,
}
#[test]
fn bindgen_test_layout___tm() {
    const UNINIT: ::core::mem::MaybeUninit<__tm> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<__tm>(),
        36usize,
        concat!("Size of: ", stringify!(__tm))
    );
    assert_eq!(
        ::core::mem::align_of::<__tm>(),
        4usize,
        concat!("Alignment of ", stringify!(__tm))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__tm_sec) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__tm),
            "::",
            stringify!(__tm_sec)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__tm_min) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__tm),
            "::",
            stringify!(__tm_min)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__tm_hour) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__tm),
            "::",
            stringify!(__tm_hour)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__tm_mday) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__tm),
            "::",
            stringify!(__tm_mday)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__tm_mon) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__tm),
            "::",
            stringify!(__tm_mon)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__tm_year) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(__tm),
            "::",
            stringify!(__tm_year)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__tm_wday) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__tm),
            "::",
            stringify!(__tm_wday)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__tm_yday) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(__tm),
            "::",
            stringify!(__tm_yday)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__tm_isdst) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(__tm),
            "::",
            stringify!(__tm_isdst)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _on_exit_args {
    pub _fnargs: [*mut core::ffi::c_void; 32usize],
    pub _dso_handle: [*mut core::ffi::c_void; 32usize],
    pub _fntypes: __ULong,
    pub _is_cxa: __ULong,
}
#[test]
fn bindgen_test_layout__on_exit_args() {
    const UNINIT: ::core::mem::MaybeUninit<_on_exit_args> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_on_exit_args>(),
        264usize,
        concat!("Size of: ", stringify!(_on_exit_args))
    );
    assert_eq!(
        ::core::mem::align_of::<_on_exit_args>(),
        4usize,
        concat!("Alignment of ", stringify!(_on_exit_args))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._fnargs) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_on_exit_args),
            "::",
            stringify!(_fnargs)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._dso_handle) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(_on_exit_args),
            "::",
            stringify!(_dso_handle)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._fntypes) as usize - ptr as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(_on_exit_args),
            "::",
            stringify!(_fntypes)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._is_cxa) as usize - ptr as usize },
        260usize,
        concat!(
            "Offset of field: ",
            stringify!(_on_exit_args),
            "::",
            stringify!(_is_cxa)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _atexit {
    pub _next: *mut _atexit,
    pub _ind: core::ffi::c_int,
    pub _fns: [::core::option::Option<unsafe extern "C" fn()>; 32usize],
    pub _on_exit_args: _on_exit_args,
}
#[test]
fn bindgen_test_layout__atexit() {
    const UNINIT: ::core::mem::MaybeUninit<_atexit> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_atexit>(),
        400usize,
        concat!("Size of: ", stringify!(_atexit))
    );
    assert_eq!(
        ::core::mem::align_of::<_atexit>(),
        4usize,
        concat!("Alignment of ", stringify!(_atexit))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._next) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_atexit),
            "::",
            stringify!(_next)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._ind) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_atexit),
            "::",
            stringify!(_ind)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._fns) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_atexit),
            "::",
            stringify!(_fns)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._on_exit_args) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_atexit),
            "::",
            stringify!(_on_exit_args)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __sbuf {
    pub _base: *mut core::ffi::c_uchar,
    pub _size: core::ffi::c_int,
}
#[test]
fn bindgen_test_layout___sbuf() {
    const UNINIT: ::core::mem::MaybeUninit<__sbuf> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<__sbuf>(),
        8usize,
        concat!("Size of: ", stringify!(__sbuf))
    );
    assert_eq!(
        ::core::mem::align_of::<__sbuf>(),
        4usize,
        concat!("Alignment of ", stringify!(__sbuf))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._base) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__sbuf),
            "::",
            stringify!(_base)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._size) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__sbuf),
            "::",
            stringify!(_size)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __sFILE {
    pub _p: *mut core::ffi::c_uchar,
    pub _r: core::ffi::c_int,
    pub _w: core::ffi::c_int,
    pub _flags: core::ffi::c_short,
    pub _file: core::ffi::c_short,
    pub _bf: __sbuf,
    pub _lbfsize: core::ffi::c_int,
    pub _cookie: *mut core::ffi::c_void,
    pub _read: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut _reent,
            arg2: *mut core::ffi::c_void,
            arg3: *mut core::ffi::c_char,
            arg4: core::ffi::c_int,
        ) -> core::ffi::c_int,
    >,
    pub _write: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut _reent,
            arg2: *mut core::ffi::c_void,
            arg3: *const core::ffi::c_char,
            arg4: core::ffi::c_int,
        ) -> core::ffi::c_int,
    >,
    pub _seek: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut _reent,
            arg2: *mut core::ffi::c_void,
            arg3: _fpos_t,
            arg4: core::ffi::c_int,
        ) -> _fpos_t,
    >,
    pub _close: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut _reent, arg2: *mut core::ffi::c_void) -> core::ffi::c_int,
    >,
    pub _ub: __sbuf,
    pub _up: *mut core::ffi::c_uchar,
    pub _ur: core::ffi::c_int,
    pub _ubuf: [core::ffi::c_uchar; 3usize],
    pub _nbuf: [core::ffi::c_uchar; 1usize],
    pub _lb: __sbuf,
    pub _blksize: core::ffi::c_int,
    pub _offset: _off_t,
    pub _data: *mut _reent,
    pub _lock: _flock_t,
    pub _mbstate: _mbstate_t,
    pub _flags2: core::ffi::c_int,
}
#[test]
fn bindgen_test_layout___sFILE() {
    const UNINIT: ::core::mem::MaybeUninit<__sFILE> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<__sFILE>(),
        104usize,
        concat!("Size of: ", stringify!(__sFILE))
    );
    assert_eq!(
        ::core::mem::align_of::<__sFILE>(),
        4usize,
        concat!("Alignment of ", stringify!(__sFILE))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._p) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_p)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._r) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_r)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._w) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_w)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._flags) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_flags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._file) as usize - ptr as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_file)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._bf) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_bf)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._lbfsize) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_lbfsize)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._cookie) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_cookie)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._read) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_read)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._write) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_write)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._seek) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_seek)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._close) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_close)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._ub) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_ub)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._up) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_up)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._ur) as usize - ptr as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_ur)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._ubuf) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_ubuf)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._nbuf) as usize - ptr as usize },
        67usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_nbuf)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._lb) as usize - ptr as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_lb)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._blksize) as usize - ptr as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_blksize)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._offset) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_offset)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._data) as usize - ptr as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_data)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._lock) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_lock)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._mbstate) as usize - ptr as usize },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_mbstate)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._flags2) as usize - ptr as usize },
        100usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_flags2)
        )
    );
}
pub type __FILE = __sFILE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _glue {
    pub _next: *mut _glue,
    pub _niobs: core::ffi::c_int,
    pub _iobs: *mut __FILE,
}
#[test]
fn bindgen_test_layout__glue() {
    const UNINIT: ::core::mem::MaybeUninit<_glue> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_glue>(),
        12usize,
        concat!("Size of: ", stringify!(_glue))
    );
    assert_eq!(
        ::core::mem::align_of::<_glue>(),
        4usize,
        concat!("Alignment of ", stringify!(_glue))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._next) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_glue),
            "::",
            stringify!(_next)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._niobs) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_glue),
            "::",
            stringify!(_niobs)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._iobs) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_glue),
            "::",
            stringify!(_iobs)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _rand48 {
    pub _seed: [core::ffi::c_ushort; 3usize],
    pub _mult: [core::ffi::c_ushort; 3usize],
    pub _add: core::ffi::c_ushort,
}
#[test]
fn bindgen_test_layout__rand48() {
    const UNINIT: ::core::mem::MaybeUninit<_rand48> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_rand48>(),
        14usize,
        concat!("Size of: ", stringify!(_rand48))
    );
    assert_eq!(
        ::core::mem::align_of::<_rand48>(),
        2usize,
        concat!("Alignment of ", stringify!(_rand48))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._seed) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_rand48),
            "::",
            stringify!(_seed)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._mult) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(_rand48),
            "::",
            stringify!(_mult)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._add) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_rand48),
            "::",
            stringify!(_add)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _reent {
    pub _errno: core::ffi::c_int,
    pub _stdin: *mut __FILE,
    pub _stdout: *mut __FILE,
    pub _stderr: *mut __FILE,
    pub _inc: core::ffi::c_int,
    pub _emergency: [core::ffi::c_char; 25usize],
    pub _unspecified_locale_info: core::ffi::c_int,
    pub _locale: *mut __locale_t,
    pub __sdidinit: core::ffi::c_int,
    pub __cleanup: ::core::option::Option<unsafe extern "C" fn(arg1: *mut _reent)>,
    pub _result: *mut _Bigint,
    pub _result_k: core::ffi::c_int,
    pub _p5s: *mut _Bigint,
    pub _freelist: *mut *mut _Bigint,
    pub _cvtlen: core::ffi::c_int,
    pub _cvtbuf: *mut core::ffi::c_char,
    pub _new: _reent__bindgen_ty_1,
    pub _atexit: *mut _atexit,
    pub _atexit0: _atexit,
    pub _sig_func: *mut ::core::option::Option<unsafe extern "C" fn(arg1: core::ffi::c_int)>,
    pub __sglue: _glue,
    pub __sf: [__FILE; 3usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _reent__bindgen_ty_1 {
    pub _reent: _reent__bindgen_ty_1__bindgen_ty_1,
    pub _unused: _reent__bindgen_ty_1__bindgen_ty_2,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _reent__bindgen_ty_1__bindgen_ty_1 {
    pub _unused_rand: core::ffi::c_uint,
    pub _strtok_last: *mut core::ffi::c_char,
    pub _asctime_buf: [core::ffi::c_char; 26usize],
    pub _localtime_buf: __tm,
    pub _gamma_signgam: core::ffi::c_int,
    pub _rand_next: core::ffi::c_ulonglong,
    pub _r48: _rand48,
    pub _mblen_state: _mbstate_t,
    pub _mbtowc_state: _mbstate_t,
    pub _wctomb_state: _mbstate_t,
    pub _l64a_buf: [core::ffi::c_char; 8usize],
    pub _signal_buf: [core::ffi::c_char; 24usize],
    pub _getdate_err: core::ffi::c_int,
    pub _mbrlen_state: _mbstate_t,
    pub _mbrtowc_state: _mbstate_t,
    pub _mbsrtowcs_state: _mbstate_t,
    pub _wcrtomb_state: _mbstate_t,
    pub _wcsrtombs_state: _mbstate_t,
    pub _h_errno: core::ffi::c_int,
}
#[test]
fn bindgen_test_layout__reent__bindgen_ty_1__bindgen_ty_1() {
    const UNINIT: ::core::mem::MaybeUninit<_reent__bindgen_ty_1__bindgen_ty_1> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_reent__bindgen_ty_1__bindgen_ty_1>(),
        208usize,
        concat!("Size of: ", stringify!(_reent__bindgen_ty_1__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<_reent__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_reent__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._unused_rand) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(_unused_rand)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._strtok_last) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(_strtok_last)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._asctime_buf) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(_asctime_buf)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._localtime_buf) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(_localtime_buf)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._gamma_signgam) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(_gamma_signgam)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._rand_next) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(_rand_next)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._r48) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(_r48)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._mblen_state) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(_mblen_state)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._mbtowc_state) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(_mbtowc_state)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._wctomb_state) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(_wctomb_state)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._l64a_buf) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(_l64a_buf)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._signal_buf) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(_signal_buf)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._getdate_err) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(_getdate_err)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._mbrlen_state) as usize - ptr as usize },
        164usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(_mbrlen_state)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._mbrtowc_state) as usize - ptr as usize },
        172usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(_mbrtowc_state)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._mbsrtowcs_state) as usize - ptr as usize },
        180usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(_mbsrtowcs_state)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._wcrtomb_state) as usize - ptr as usize },
        188usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(_wcrtomb_state)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._wcsrtombs_state) as usize - ptr as usize },
        196usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(_wcsrtombs_state)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._h_errno) as usize - ptr as usize },
        204usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(_h_errno)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _reent__bindgen_ty_1__bindgen_ty_2 {
    pub _nextf: [*mut core::ffi::c_uchar; 30usize],
    pub _nmalloc: [core::ffi::c_uint; 30usize],
}
#[test]
fn bindgen_test_layout__reent__bindgen_ty_1__bindgen_ty_2() {
    const UNINIT: ::core::mem::MaybeUninit<_reent__bindgen_ty_1__bindgen_ty_2> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_reent__bindgen_ty_1__bindgen_ty_2>(),
        240usize,
        concat!("Size of: ", stringify!(_reent__bindgen_ty_1__bindgen_ty_2))
    );
    assert_eq!(
        ::core::mem::align_of::<_reent__bindgen_ty_1__bindgen_ty_2>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_reent__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._nextf) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(_nextf)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._nmalloc) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(_nmalloc)
        )
    );
}
#[test]
fn bindgen_test_layout__reent__bindgen_ty_1() {
    const UNINIT: ::core::mem::MaybeUninit<_reent__bindgen_ty_1> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_reent__bindgen_ty_1>(),
        240usize,
        concat!("Size of: ", stringify!(_reent__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<_reent__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(_reent__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._reent) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent__bindgen_ty_1),
            "::",
            stringify!(_reent)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._unused) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent__bindgen_ty_1),
            "::",
            stringify!(_unused)
        )
    );
}
#[test]
fn bindgen_test_layout__reent() {
    const UNINIT: ::core::mem::MaybeUninit<_reent> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_reent>(),
        1064usize,
        concat!("Size of: ", stringify!(_reent))
    );
    assert_eq!(
        ::core::mem::align_of::<_reent>(),
        8usize,
        concat!("Alignment of ", stringify!(_reent))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._errno) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent),
            "::",
            stringify!(_errno)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._stdin) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent),
            "::",
            stringify!(_stdin)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._stdout) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent),
            "::",
            stringify!(_stdout)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._stderr) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent),
            "::",
            stringify!(_stderr)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._inc) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent),
            "::",
            stringify!(_inc)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._emergency) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent),
            "::",
            stringify!(_emergency)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._unspecified_locale_info) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent),
            "::",
            stringify!(_unspecified_locale_info)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._locale) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent),
            "::",
            stringify!(_locale)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__sdidinit) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent),
            "::",
            stringify!(__sdidinit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__cleanup) as usize - ptr as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent),
            "::",
            stringify!(__cleanup)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._result) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent),
            "::",
            stringify!(_result)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._result_k) as usize - ptr as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent),
            "::",
            stringify!(_result_k)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._p5s) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent),
            "::",
            stringify!(_p5s)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._freelist) as usize - ptr as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent),
            "::",
            stringify!(_freelist)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._cvtlen) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent),
            "::",
            stringify!(_cvtlen)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._cvtbuf) as usize - ptr as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent),
            "::",
            stringify!(_cvtbuf)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._new) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent),
            "::",
            stringify!(_new)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._atexit) as usize - ptr as usize },
        328usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent),
            "::",
            stringify!(_atexit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._atexit0) as usize - ptr as usize },
        332usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent),
            "::",
            stringify!(_atexit0)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._sig_func) as usize - ptr as usize },
        732usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent),
            "::",
            stringify!(_sig_func)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__sglue) as usize - ptr as usize },
        736usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent),
            "::",
            stringify!(__sglue)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__sf) as usize - ptr as usize },
        748usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent),
            "::",
            stringify!(__sf)
        )
    );
}
extern "C" {
    pub static mut _impure_ptr: *mut _reent;
}
extern "C" {
    pub static _global_impure_ptr: *mut _reent;
}
extern "C" {
    pub fn abort() -> !;
}
extern "C" {
    pub fn atoi(__nptr: *const core::ffi::c_char) -> core::ffi::c_int;
}
extern "C" {
    pub fn free(arg1: *mut core::ffi::c_void);
}
extern "C" {
    pub fn malloc(arg1: core::ffi::c_uint) -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn rand() -> core::ffi::c_int;
}
extern "C" {
    pub fn realloc(arg1: *mut core::ffi::c_void, arg2: core::ffi::c_uint)
        -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn srand(__seed: core::ffi::c_uint);
}
extern "C" {
    pub fn strtof(__n: *const core::ffi::c_char, __end_PTR: *mut *mut core::ffi::c_char) -> f32;
}
extern "C" {
    pub fn strtol(
        __n: *const core::ffi::c_char,
        __end_PTR: *mut *mut core::ffi::c_char,
        __base: core::ffi::c_int,
    ) -> core::ffi::c_long;
}
extern "C" {
    pub fn strtoul(
        __n: *const core::ffi::c_char,
        __end_PTR: *mut *mut core::ffi::c_char,
        __base: core::ffi::c_int,
    ) -> core::ffi::c_ulong;
}
extern "C" {
    pub fn random() -> core::ffi::c_long;
}
extern "C" {
    pub fn strtoull(
        __n: *const core::ffi::c_char,
        __end_PTR: *mut *mut core::ffi::c_char,
        __base: core::ffi::c_int,
    ) -> core::ffi::c_ulonglong;
}
extern "C" {
    #[doc = " Crash system"]
    pub fn __furi_crash();
}
extern "C" {
    #[doc = " Halt system"]
    pub fn __furi_halt();
}
extern "C" {
    #[doc = "< System Clock Frequency"]
    pub static mut SystemCoreClock: u32;
}
extern "C" {
    pub fn furi_thread_catch() -> !;
}
pub type BaseType_t = core::ffi::c_long;
pub type UBaseType_t = core::ffi::c_ulong;
pub type TickType_t = u32;
extern "C" {
    pub fn vPortEnterCritical();
}
extern "C" {
    pub fn vPortExitCritical();
}
#[doc = " task. h\n\n Type by which tasks are referenced.  For example, a call to xTaskCreate\n returns (via a pointer parameter) an TaskHandle_t variable that can then\n be used as a parameter to vTaskDelete to delete the task.\n\n \\defgroup TaskHandle_t TaskHandle_t\n \\ingroup Tasks"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tskTaskControlBlock {
    _unused: [u8; 0],
}
pub type TaskHandle_t = *mut tskTaskControlBlock;
extern "C" {
    #[doc = " task. h\n @code{c}\n void vTaskPrioritySet( TaskHandle_t xTask, UBaseType_t uxNewPriority );\n @endcode\n\n INCLUDE_vTaskPrioritySet must be defined as 1 for this function to be available.\n See the configuration section for more information.\n\n Set the priority of any task.\n\n A context switch will occur before the function returns if the priority\n being set is higher than the currently executing task.\n\n @param xTask Handle to the task for which the priority is being set.\n Passing a NULL handle results in the priority of the calling task being set.\n\n @param uxNewPriority The priority to which the task will be set.\n\n Example usage:\n @code{c}\n void vAFunction( void )\n {\n TaskHandle_t xHandle;\n\n   // Create a task, storing the handle.\n   xTaskCreate( vTaskCode, \"NAME\", STACK_SIZE, NULL, tskIDLE_PRIORITY, &xHandle );\n\n   // ...\n\n   // Use the handle to raise the priority of the created task.\n   vTaskPrioritySet( xHandle, tskIDLE_PRIORITY + 1 );\n\n   // ...\n\n   // Use a NULL handle to raise our priority to the same value.\n   vTaskPrioritySet( NULL, tskIDLE_PRIORITY + 1 );\n }\n @endcode\n \\defgroup vTaskPrioritySet vTaskPrioritySet\n \\ingroup TaskCtrl"]
    pub fn vTaskPrioritySet(xTask: TaskHandle_t, uxNewPriority: UBaseType_t);
}
extern "C" {
    #[doc = " task. h\n @code{c}\n TickType_t xTaskGetTickCount( void );\n @endcode\n\n @return The count of ticks since vTaskStartScheduler was called.\n\n \\defgroup xTaskGetTickCount xTaskGetTickCount\n \\ingroup TaskUtils"]
    pub fn xTaskGetTickCount() -> TickType_t;
}
extern "C" {
    #[doc = " task. h\n @code{c}\n TaskHandle_t xTaskGetHandle( const char *pcNameToQuery );\n @endcode\n\n NOTE:  This function takes a relatively long time to complete and should be\n used sparingly.\n\n @return The handle of the task that has the human readable name pcNameToQuery.\n NULL is returned if no matching name is found.  INCLUDE_xTaskGetHandle\n must be set to 1 in FreeRTOSConfig.h for pcTaskGetHandle() to be available.\n\n \\defgroup pcTaskGetHandle pcTaskGetHandle\n \\ingroup TaskUtils"]
    pub fn xTaskGetHandle(pcNameToQuery: *const core::ffi::c_char) -> TaskHandle_t;
}
extern "C" {
    pub fn xTaskGetSchedulerState() -> BaseType_t;
}
#[doc = "< Operation completed successfully."]
pub const FuriStatus_FuriStatusOk: FuriStatus = 0;
pub const FuriStatus_FuriStatusError: FuriStatus = -1;
#[doc = "< Operation not completed within the timeout period."]
pub const FuriStatus_FuriStatusErrorTimeout: FuriStatus = -2;
#[doc = "< Resource not available."]
pub const FuriStatus_FuriStatusErrorResource: FuriStatus = -3;
#[doc = "< Parameter error."]
pub const FuriStatus_FuriStatusErrorParameter: FuriStatus = -4;
pub const FuriStatus_FuriStatusErrorNoMemory: FuriStatus = -5;
pub const FuriStatus_FuriStatusErrorISR: FuriStatus = -6;
#[doc = "< Prevents enum down-size compiler optimization."]
pub const FuriStatus_FuriStatusReserved: FuriStatus = 2147483647;
pub type FuriStatus = core::ffi::c_int;
pub type FuriEventFlag = core::ffi::c_void;
extern "C" {
    #[doc = " Allocate FuriEventFlag\n\n @return     pointer to FuriEventFlag"]
    pub fn furi_event_flag_alloc() -> *mut FuriEventFlag;
}
extern "C" {
    #[doc = " Deallocate FuriEventFlag\n\n @param      instance  pointer to FuriEventFlag"]
    pub fn furi_event_flag_free(instance: *mut FuriEventFlag);
}
extern "C" {
    #[doc = " Set flags\n\n @param      instance  pointer to FuriEventFlag\n @param[in]  flags     The flags\n\n @return     Resulting flags or error (FuriStatus)"]
    pub fn furi_event_flag_set(instance: *mut FuriEventFlag, flags: u32) -> u32;
}
extern "C" {
    #[doc = " Clear flags\n\n @param      instance  pointer to FuriEventFlag\n @param[in]  flags     The flags\n\n @return     Resulting flags or error (FuriStatus)"]
    pub fn furi_event_flag_clear(instance: *mut FuriEventFlag, flags: u32) -> u32;
}
extern "C" {
    #[doc = " Get flags\n\n @param      instance  pointer to FuriEventFlag\n\n @return     Resulting flags"]
    pub fn furi_event_flag_get(instance: *mut FuriEventFlag) -> u32;
}
extern "C" {
    #[doc = " Wait flags\n\n @param      instance  pointer to FuriEventFlag\n @param[in]  flags     The flags\n @param[in]  options   The option flags\n @param[in]  timeout   The timeout\n\n @return     Resulting flags or error (FuriStatus)"]
    pub fn furi_event_flag_wait(
        instance: *mut FuriEventFlag,
        flags: u32,
        options: u32,
        timeout: u32,
    ) -> u32;
}
extern "C" {
    #[doc = " Check if CPU is in IRQ or kernel running and IRQ is masked\n\n Originally this primitive was born as a workaround for FreeRTOS kernel primitives shenanigans with PRIMASK.\n\n Meaningful use cases are:\n\n - When kernel is started and you want to ensure that you are not in IRQ or IRQ is not masked(like in critical section)\n - When kernel is not started and you want to make sure that you are not in IRQ mode, ignoring PRIMASK.\n\n As you can see there will be edge case when kernel is not started and PRIMASK is not 0 that may cause some funky behavior.\n Most likely it will happen after kernel primitives being used, but control not yet passed to kernel.\n It's up to you to figure out if it is safe for your code or not.\n\n @return     true if CPU is in IRQ or kernel running and IRQ is masked"]
    pub fn furi_kernel_is_irq_or_masked() -> bool;
}
extern "C" {
    #[doc = " Lock kernel, pause process scheduling\n\n @warning This should never be called in interrupt request context.\n\n @return     previous lock state(0 - unlocked, 1 - locked)"]
    pub fn furi_kernel_lock() -> i32;
}
extern "C" {
    #[doc = " Unlock kernel, resume process scheduling\n\n @warning This should never be called in interrupt request context.\n\n @return     previous lock state(0 - unlocked, 1 - locked)"]
    pub fn furi_kernel_unlock() -> i32;
}
extern "C" {
    #[doc = " Restore kernel lock state\n\n @warning This should never be called in interrupt request context.\n\n @param[in]  lock  The lock state\n\n @return     new lock state or error"]
    pub fn furi_kernel_restore_lock(lock: i32) -> i32;
}
extern "C" {
    #[doc = " Get kernel systick frequency\n\n @return     systick counts per second"]
    pub fn furi_kernel_get_tick_frequency() -> u32;
}
extern "C" {
    #[doc = " Delay execution\n\n @warning This should never be called in interrupt request context.\n\n Also keep in mind delay is aliased to scheduler timer intervals.\n\n @param[in]  ticks  The ticks count to pause"]
    pub fn furi_delay_tick(ticks: u32);
}
extern "C" {
    #[doc = " Delay until tick\n\n @warning This should never be called in interrupt request context.\n\n @param[in]  ticks  The tick until which kerel should delay task execution\n\n @return     The furi status."]
    pub fn furi_delay_until_tick(tick: u32) -> FuriStatus;
}
extern "C" {
    #[doc = " Get current tick counter\n\n System uptime, may overflow.\n\n @return     Current ticks in milliseconds"]
    pub fn furi_get_tick() -> u32;
}
extern "C" {
    #[doc = " Convert milliseconds to ticks\n\n @param[in]   milliseconds    time in milliseconds\n @return      time in ticks"]
    pub fn furi_ms_to_ticks(milliseconds: u32) -> u32;
}
extern "C" {
    #[doc = " Delay in milliseconds\n\n This method uses kernel ticks on the inside, which causes delay to be aliased to scheduler timer intervals.\n Real wait time will be between X+ milliseconds.\n Special value: 0, will cause task yield.\n Also if used when kernel is not running will fall back to `furi_delay_us`.\n\n @warning    Cannot be used from ISR\n\n @param[in]  milliseconds  milliseconds to wait"]
    pub fn furi_delay_ms(milliseconds: u32);
}
extern "C" {
    #[doc = " Delay in microseconds\n\n Implemented using Cortex DWT counter. Blocking and non aliased.\n\n @param[in]  microseconds  microseconds to wait"]
    pub fn furi_delay_us(microseconds: u32);
}
pub type va_list = u32;
pub type FILE = __FILE;
extern "C" {
    pub fn sscanf(
        arg1: *const core::ffi::c_char,
        arg2: *const core::ffi::c_char,
        ...
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn snprintf(
        arg1: *mut core::ffi::c_char,
        arg2: core::ffi::c_uint,
        arg3: *const core::ffi::c_char,
        ...
    ) -> core::ffi::c_int;
}
pub const FuriLogLevel_FuriLogLevelDefault: FuriLogLevel = 0;
pub const FuriLogLevel_FuriLogLevelNone: FuriLogLevel = 1;
pub const FuriLogLevel_FuriLogLevelError: FuriLogLevel = 2;
pub const FuriLogLevel_FuriLogLevelWarn: FuriLogLevel = 3;
pub const FuriLogLevel_FuriLogLevelInfo: FuriLogLevel = 4;
pub const FuriLogLevel_FuriLogLevelDebug: FuriLogLevel = 5;
pub const FuriLogLevel_FuriLogLevelTrace: FuriLogLevel = 6;
pub type FuriLogLevel = core::ffi::c_uchar;
extern "C" {
    #[doc = " Print log record\n\n @param level\n @param tag\n @param format\n @param ..."]
    pub fn furi_log_print_format(
        level: FuriLogLevel,
        tag: *const core::ffi::c_char,
        format: *const core::ffi::c_char,
        ...
    );
}
extern "C" {
    #[doc = " Print log record\n\n @param level\n @param format\n @param ..."]
    pub fn furi_log_print_raw_format(level: FuriLogLevel, format: *const core::ffi::c_char, ...);
}
extern "C" {
    #[doc = " Set log level\n\n @param[in]  level  The level"]
    pub fn furi_log_set_level(level: FuriLogLevel);
}
extern "C" {
    #[doc = " Get log level\n\n @return     The furi log level."]
    pub fn furi_log_get_level() -> FuriLogLevel;
}
extern "C" {
    pub fn strncasecmp(
        arg1: *const core::ffi::c_char,
        arg2: *const core::ffi::c_char,
        arg3: core::ffi::c_uint,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn memchr(
        arg1: *const core::ffi::c_void,
        arg2: core::ffi::c_int,
        arg3: core::ffi::c_uint,
    ) -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn memcmp(
        arg1: *const core::ffi::c_void,
        arg2: *const core::ffi::c_void,
        arg3: core::ffi::c_uint,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn memcpy(
        arg1: *mut core::ffi::c_void,
        arg2: *const core::ffi::c_void,
        arg3: core::ffi::c_uint,
    ) -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn memmove(
        arg1: *mut core::ffi::c_void,
        arg2: *const core::ffi::c_void,
        arg3: core::ffi::c_uint,
    ) -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn memset(
        arg1: *mut core::ffi::c_void,
        arg2: core::ffi::c_int,
        arg3: core::ffi::c_uint,
    ) -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn strchr(arg1: *const core::ffi::c_char, arg2: core::ffi::c_int)
        -> *mut core::ffi::c_char;
}
extern "C" {
    pub fn strcmp(
        arg1: *const core::ffi::c_char,
        arg2: *const core::ffi::c_char,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn strcpy(
        arg1: *mut core::ffi::c_char,
        arg2: *const core::ffi::c_char,
    ) -> *mut core::ffi::c_char;
}
extern "C" {
    pub fn strcspn(
        arg1: *const core::ffi::c_char,
        arg2: *const core::ffi::c_char,
    ) -> core::ffi::c_uint;
}
extern "C" {
    pub fn strlen(arg1: *const core::ffi::c_char) -> core::ffi::c_uint;
}
extern "C" {
    pub fn strncmp(
        arg1: *const core::ffi::c_char,
        arg2: *const core::ffi::c_char,
        arg3: core::ffi::c_uint,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn strncpy(
        arg1: *mut core::ffi::c_char,
        arg2: *const core::ffi::c_char,
        arg3: core::ffi::c_uint,
    ) -> *mut core::ffi::c_char;
}
extern "C" {
    pub fn strrchr(
        arg1: *const core::ffi::c_char,
        arg2: core::ffi::c_int,
    ) -> *mut core::ffi::c_char;
}
extern "C" {
    pub fn strspn(
        arg1: *const core::ffi::c_char,
        arg2: *const core::ffi::c_char,
    ) -> core::ffi::c_uint;
}
extern "C" {
    pub fn strstr(
        arg1: *const core::ffi::c_char,
        arg2: *const core::ffi::c_char,
    ) -> *mut core::ffi::c_char;
}
extern "C" {
    pub fn strcasestr(
        arg1: *const core::ffi::c_char,
        arg2: *const core::ffi::c_char,
    ) -> *mut core::ffi::c_char;
}
extern "C" {
    pub fn strdup(arg1: *const core::ffi::c_char) -> *mut core::ffi::c_char;
}
extern "C" {
    pub fn strlcpy(
        arg1: *mut core::ffi::c_char,
        arg2: *const core::ffi::c_char,
        arg3: core::ffi::c_uint,
    ) -> core::ffi::c_uint;
}
extern "C" {
    #[doc = " Get free heap size\n\n @return     free heap size in bytes"]
    pub fn memmgr_get_free_heap() -> usize;
}
extern "C" {
    #[doc = " Get total heap size\n\n @return     total heap size in bytes"]
    pub fn memmgr_get_total_heap() -> usize;
}
extern "C" {
    #[doc = " Get heap watermark\n\n @return     minimum heap in bytes"]
    pub fn memmgr_get_minimum_free_heap() -> usize;
}
extern "C" {
    #[doc = " An aligned version of malloc, used when you need to get the aligned space on the heap\n Freeing the received address is performed ONLY through the aligned_free function\n @param size\n @param alignment\n @return void*"]
    pub fn aligned_malloc(size: usize, alignment: usize) -> *mut core::ffi::c_void;
}
extern "C" {
    #[doc = " Freed space obtained through the aligned_malloc function\n @param p pointer to result of aligned_malloc"]
    pub fn aligned_free(p: *mut core::ffi::c_void);
}
pub const FuriThreadState_FuriThreadStateStopped: FuriThreadState = 0;
pub const FuriThreadState_FuriThreadStateStarting: FuriThreadState = 1;
pub const FuriThreadState_FuriThreadStateRunning: FuriThreadState = 2;
#[doc = " FuriThreadState"]
pub type FuriThreadState = core::ffi::c_uchar;
#[doc = "< Uninitialized, choose system default"]
pub const FuriThreadPriority_FuriThreadPriorityNone: FuriThreadPriority = 0;
#[doc = "< Idle priority"]
pub const FuriThreadPriority_FuriThreadPriorityIdle: FuriThreadPriority = 1;
#[doc = "< Lowest"]
pub const FuriThreadPriority_FuriThreadPriorityLowest: FuriThreadPriority = 14;
#[doc = "< Low"]
pub const FuriThreadPriority_FuriThreadPriorityLow: FuriThreadPriority = 15;
#[doc = "< Normal"]
pub const FuriThreadPriority_FuriThreadPriorityNormal: FuriThreadPriority = 16;
#[doc = "< High"]
pub const FuriThreadPriority_FuriThreadPriorityHigh: FuriThreadPriority = 17;
#[doc = "< Highest"]
pub const FuriThreadPriority_FuriThreadPriorityHighest: FuriThreadPriority = 18;
#[doc = "< Deffered Isr (highest possible)"]
pub const FuriThreadPriority_FuriThreadPriorityIsr: FuriThreadPriority = 32;
#[doc = " FuriThreadPriority"]
pub type FuriThreadPriority = core::ffi::c_uchar;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FuriThread {
    _unused: [u8; 0],
}
#[doc = " FuriThreadId proxy type to OS low level functions"]
pub type FuriThreadId = *mut core::ffi::c_void;
#[doc = " FuriThreadCallback Your callback to run in new thread\n @warning    never use osThreadExit in FuriThread"]
pub type FuriThreadCallback =
    ::core::option::Option<unsafe extern "C" fn(context: *mut core::ffi::c_void) -> i32>;
#[doc = " Write to stdout callback\n @param      data     pointer to data\n @param      size     data size @warning your handler must consume everything"]
pub type FuriThreadStdoutWriteCallback =
    ::core::option::Option<unsafe extern "C" fn(data: *const core::ffi::c_char, size: usize)>;
#[doc = " FuriThread state change callback called upon thread state change\n @param      state    new thread state\n @param      context  callback context"]
pub type FuriThreadStateCallback = ::core::option::Option<
    unsafe extern "C" fn(state: FuriThreadState, context: *mut core::ffi::c_void),
>;
extern "C" {
    #[doc = " Allocate FuriThread\n\n @return     FuriThread instance"]
    pub fn furi_thread_alloc() -> *mut FuriThread;
}
extern "C" {
    #[doc = " Allocate FuriThread, shortcut version\n\n @param name\n @param stack_size\n @param callback\n @param context\n @return FuriThread*"]
    pub fn furi_thread_alloc_ex(
        name: *const core::ffi::c_char,
        stack_size: u32,
        callback: FuriThreadCallback,
        context: *mut core::ffi::c_void,
    ) -> *mut FuriThread;
}
extern "C" {
    #[doc = " Release FuriThread\n\n @param      thread  FuriThread instance"]
    pub fn furi_thread_free(thread: *mut FuriThread);
}
extern "C" {
    #[doc = " Set FuriThread name\n\n @param      thread  FuriThread instance\n @param      name    string"]
    pub fn furi_thread_set_name(thread: *mut FuriThread, name: *const core::ffi::c_char);
}
extern "C" {
    #[doc = " Mark thread as service\n The service cannot be stopped or removed, and cannot exit from the thread body\n\n @param thread"]
    pub fn furi_thread_mark_as_service(thread: *mut FuriThread);
}
extern "C" {
    #[doc = " Set FuriThread stack size\n\n @param      thread      FuriThread instance\n @param      stack_size  stack size in bytes"]
    pub fn furi_thread_set_stack_size(thread: *mut FuriThread, stack_size: usize);
}
extern "C" {
    #[doc = " Set FuriThread callback\n\n @param      thread    FuriThread instance\n @param      callback  FuriThreadCallback, called upon thread run"]
    pub fn furi_thread_set_callback(thread: *mut FuriThread, callback: FuriThreadCallback);
}
extern "C" {
    #[doc = " Set FuriThread context\n\n @param      thread   FuriThread instance\n @param      context  pointer to context for thread callback"]
    pub fn furi_thread_set_context(thread: *mut FuriThread, context: *mut core::ffi::c_void);
}
extern "C" {
    #[doc = " Set FuriThread priority\n\n @param      thread   FuriThread instance\n @param      priority FuriThreadPriority value"]
    pub fn furi_thread_set_priority(thread: *mut FuriThread, priority: FuriThreadPriority);
}
extern "C" {
    #[doc = " Set current thread priority\n\n @param      priority FuriThreadPriority value"]
    pub fn furi_thread_set_current_priority(priority: FuriThreadPriority);
}
extern "C" {
    #[doc = " Get current thread priority\n\n @return     FuriThreadPriority value"]
    pub fn furi_thread_get_current_priority() -> FuriThreadPriority;
}
extern "C" {
    #[doc = " Set FuriThread state change callback\n\n @param      thread    FuriThread instance\n @param      callback  state change callback"]
    pub fn furi_thread_set_state_callback(
        thread: *mut FuriThread,
        callback: FuriThreadStateCallback,
    );
}
extern "C" {
    #[doc = " Set FuriThread state change context\n\n @param      thread   FuriThread instance\n @param      context  pointer to context"]
    pub fn furi_thread_set_state_context(thread: *mut FuriThread, context: *mut core::ffi::c_void);
}
extern "C" {
    #[doc = " Get FuriThread state\n\n @param      thread  FuriThread instance\n\n @return     thread state from FuriThreadState"]
    pub fn furi_thread_get_state(thread: *mut FuriThread) -> FuriThreadState;
}
extern "C" {
    #[doc = " Start FuriThread\n\n @param      thread  FuriThread instance"]
    pub fn furi_thread_start(thread: *mut FuriThread);
}
extern "C" {
    #[doc = " Join FuriThread\n\n @param      thread  FuriThread instance\n\n @return     bool"]
    pub fn furi_thread_join(thread: *mut FuriThread) -> bool;
}
extern "C" {
    #[doc = " Get FreeRTOS FuriThreadId for FuriThread instance\n\n @param      thread  FuriThread instance\n\n @return     FuriThreadId or NULL"]
    pub fn furi_thread_get_id(thread: *mut FuriThread) -> FuriThreadId;
}
extern "C" {
    #[doc = " Enable heap tracing\n\n @param      thread  FuriThread instance"]
    pub fn furi_thread_enable_heap_trace(thread: *mut FuriThread);
}
extern "C" {
    #[doc = " Get thread heap size\n\n @param      thread  FuriThread instance\n\n @return     size in bytes"]
    pub fn furi_thread_get_heap_size(thread: *mut FuriThread) -> usize;
}
extern "C" {
    #[doc = " Get thread return code\n\n @param      thread  FuriThread instance\n\n @return     return code"]
    pub fn furi_thread_get_return_code(thread: *mut FuriThread) -> i32;
}
extern "C" {
    #[doc = " Get FreeRTOS FuriThreadId for current thread\n\n @param      thread  FuriThread instance\n\n @return     FuriThreadId or NULL"]
    pub fn furi_thread_get_current_id() -> FuriThreadId;
}
extern "C" {
    #[doc = " Get FuriThread instance for current thread\n\n @return FuriThread*"]
    pub fn furi_thread_get_current() -> *mut FuriThread;
}
extern "C" {
    #[doc = " Return control to scheduler"]
    pub fn furi_thread_yield();
}
extern "C" {
    pub fn furi_thread_flags_set(thread_id: FuriThreadId, flags: u32) -> u32;
}
extern "C" {
    pub fn furi_thread_flags_clear(flags: u32) -> u32;
}
extern "C" {
    pub fn furi_thread_flags_get() -> u32;
}
extern "C" {
    pub fn furi_thread_flags_wait(flags: u32, options: u32, timeout: u32) -> u32;
}
extern "C" {
    pub fn furi_thread_enumerate(thread_array: *mut FuriThreadId, array_items: u32) -> u32;
}
extern "C" {
    pub fn furi_thread_get_name(thread_id: FuriThreadId) -> *const core::ffi::c_char;
}
extern "C" {
    pub fn furi_thread_get_stack_space(thread_id: FuriThreadId) -> u32;
}
extern "C" {
    #[doc = " Get STDOUT callback for thead\n\n @return STDOUT callback"]
    pub fn furi_thread_get_stdout_callback() -> FuriThreadStdoutWriteCallback;
}
extern "C" {
    #[doc = " Set STDOUT callback for thread\n\n @param      callback  callback or NULL to clear\n\n @return     true on success, otherwise fail"]
    pub fn furi_thread_set_stdout_callback(callback: FuriThreadStdoutWriteCallback) -> bool;
}
extern "C" {
    #[doc = " Write data to buffered STDOUT\n\n @param data input data\n @param size input data size\n\n @return size_t written data size"]
    pub fn furi_thread_stdout_write(data: *const core::ffi::c_char, size: usize) -> usize;
}
extern "C" {
    #[doc = " Flush data to STDOUT\n\n @return int32_t error code"]
    pub fn furi_thread_stdout_flush() -> i32;
}
extern "C" {
    #[doc = " Suspend thread\n\n @param thread_id thread id"]
    pub fn furi_thread_suspend(thread_id: FuriThreadId);
}
extern "C" {
    #[doc = " Resume thread\n\n @param thread_id thread id"]
    pub fn furi_thread_resume(thread_id: FuriThreadId);
}
extern "C" {
    #[doc = " Get thread suspended state\n\n @param thread_id thread id\n @return true if thread is suspended"]
    pub fn furi_thread_is_suspended(thread_id: FuriThreadId) -> bool;
}
extern "C" {
    #[doc = " Memmgr heap enable thread allocation tracking\n\n @param      thread_id  - thread id to track"]
    pub fn memmgr_heap_enable_thread_trace(taks_handle: FuriThreadId);
}
extern "C" {
    #[doc = " Memmgr heap disable thread allocation tracking\n\n @param      thread_id  - thread id to track"]
    pub fn memmgr_heap_disable_thread_trace(taks_handle: FuriThreadId);
}
extern "C" {
    #[doc = " Memmgr heap get allocatred thread memory\n\n @param      thread_id  - thread id to track\n\n @return     bytes allocated right now"]
    pub fn memmgr_heap_get_thread_memory(taks_handle: FuriThreadId) -> usize;
}
extern "C" {
    #[doc = " Memmgr heap get the max contiguous block size on the heap\n\n @return     size_t max contiguous block size"]
    pub fn memmgr_heap_get_max_free_block() -> usize;
}
extern "C" {
    #[doc = " Print the address and size of all free blocks to stdout"]
    pub fn memmgr_heap_printf_free_blocks();
}
pub type FuriMessageQueue = core::ffi::c_void;
extern "C" {
    #[doc = " Allocate furi message queue\n\n @param[in]  msg_count  The message count\n @param[in]  msg_size   The message size\n\n @return     pointer to FuriMessageQueue instance"]
    pub fn furi_message_queue_alloc(msg_count: u32, msg_size: u32) -> *mut FuriMessageQueue;
}
extern "C" {
    #[doc = " Free queue\n\n @param      instance  pointer to FuriMessageQueue instance"]
    pub fn furi_message_queue_free(instance: *mut FuriMessageQueue);
}
extern "C" {
    #[doc = " Put message into queue\n\n @param      instance  pointer to FuriMessageQueue instance\n @param[in]  msg_ptr   The message pointer\n @param[in]  timeout   The timeout\n @param[in]  msg_prio  The message prio\n\n @return     The furi status."]
    pub fn furi_message_queue_put(
        instance: *mut FuriMessageQueue,
        msg_ptr: *const core::ffi::c_void,
        timeout: u32,
    ) -> FuriStatus;
}
extern "C" {
    #[doc = " Get message from queue\n\n @param      instance  pointer to FuriMessageQueue instance\n @param      msg_ptr   The message pointer\n @param      msg_prio  The message prioority\n @param[in]  timeout   The timeout\n\n @return     The furi status."]
    pub fn furi_message_queue_get(
        instance: *mut FuriMessageQueue,
        msg_ptr: *mut core::ffi::c_void,
        timeout: u32,
    ) -> FuriStatus;
}
extern "C" {
    #[doc = " Get queue capacity\n\n @param      instance  pointer to FuriMessageQueue instance\n\n @return     capacity in object count"]
    pub fn furi_message_queue_get_capacity(instance: *mut FuriMessageQueue) -> u32;
}
extern "C" {
    #[doc = " Get message size\n\n @param      instance  pointer to FuriMessageQueue instance\n\n @return     Message size in bytes"]
    pub fn furi_message_queue_get_message_size(instance: *mut FuriMessageQueue) -> u32;
}
extern "C" {
    #[doc = " Get message count in queue\n\n @param      instance  pointer to FuriMessageQueue instance\n\n @return     Message count"]
    pub fn furi_message_queue_get_count(instance: *mut FuriMessageQueue) -> u32;
}
extern "C" {
    #[doc = " Get queue available space\n\n @param      instance  pointer to FuriMessageQueue instance\n\n @return     Message count"]
    pub fn furi_message_queue_get_space(instance: *mut FuriMessageQueue) -> u32;
}
extern "C" {
    #[doc = " Reset queue\n\n @param      instance  pointer to FuriMessageQueue instance\n\n @return     The furi status."]
    pub fn furi_message_queue_reset(instance: *mut FuriMessageQueue) -> FuriStatus;
}
pub const FuriMutexType_FuriMutexTypeNormal: FuriMutexType = 0;
pub const FuriMutexType_FuriMutexTypeRecursive: FuriMutexType = 1;
pub type FuriMutexType = core::ffi::c_uchar;
pub type FuriMutex = core::ffi::c_void;
extern "C" {
    #[doc = " Allocate FuriMutex\n\n @param[in]  type  The mutex type\n\n @return     pointer to FuriMutex instance"]
    pub fn furi_mutex_alloc(type_: FuriMutexType) -> *mut FuriMutex;
}
extern "C" {
    #[doc = " Free FuriMutex\n\n @param      instance  The pointer to FuriMutex instance"]
    pub fn furi_mutex_free(instance: *mut FuriMutex);
}
extern "C" {
    #[doc = " Acquire mutex\n\n @param      instance  The pointer to FuriMutex instance\n @param[in]  timeout   The timeout\n\n @return     The furi status."]
    pub fn furi_mutex_acquire(instance: *mut FuriMutex, timeout: u32) -> FuriStatus;
}
extern "C" {
    #[doc = " Release mutex\n\n @param      instance  The pointer to FuriMutex instance\n\n @return     The furi status."]
    pub fn furi_mutex_release(instance: *mut FuriMutex) -> FuriStatus;
}
extern "C" {
    #[doc = " Get mutex owner thread id\n\n @param      instance  The pointer to FuriMutex instance\n\n @return     The furi thread identifier."]
    pub fn furi_mutex_get_owner(instance: *mut FuriMutex) -> FuriThreadId;
}
#[doc = " FuriPubSub Callback type"]
pub type FuriPubSubCallback = ::core::option::Option<
    unsafe extern "C" fn(message: *const core::ffi::c_void, context: *mut core::ffi::c_void),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FuriPubSub {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FuriPubSubSubscription {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " Allocate FuriPubSub\n\n Reentrable, Not threadsafe, one owner\n\n @return     pointer to FuriPubSub instance"]
    pub fn furi_pubsub_alloc() -> *mut FuriPubSub;
}
extern "C" {
    #[doc = " Subscribe to FuriPubSub\n\n Threadsafe, Reentrable\n\n @param      pubsub            pointer to FuriPubSub instance\n @param[in]  callback          The callback\n @param      callback_context  The callback context\n\n @return     pointer to FuriPubSubSubscription instance"]
    pub fn furi_pubsub_subscribe(
        pubsub: *mut FuriPubSub,
        callback: FuriPubSubCallback,
        callback_context: *mut core::ffi::c_void,
    ) -> *mut FuriPubSubSubscription;
}
extern "C" {
    #[doc = " Unsubscribe from FuriPubSub\n\n No use of `pubsub_subscription` allowed after call of this method\n Threadsafe, Reentrable.\n\n @param      pubsub               pointer to FuriPubSub instance\n @param      pubsub_subscription  pointer to FuriPubSubSubscription instance"]
    pub fn furi_pubsub_unsubscribe(
        pubsub: *mut FuriPubSub,
        pubsub_subscription: *mut FuriPubSubSubscription,
    );
}
extern "C" {
    #[doc = " Publish message to FuriPubSub\n\n Threadsafe, Reentrable.\n\n @param      pubsub   pointer to FuriPubSub instance\n @param      message  message pointer to publish"]
    pub fn furi_pubsub_publish(pubsub: *mut FuriPubSub, message: *mut core::ffi::c_void);
}
extern "C" {
    #[doc = " Check if record exists\n\n @param      name  record name\n @note       Thread safe. Create and destroy must be executed from the same\n             thread."]
    pub fn furi_record_exists(name: *const core::ffi::c_char) -> bool;
}
extern "C" {
    #[doc = " Create record\n\n @param      name  record name\n @param      data  data pointer\n @note       Thread safe. Create and destroy must be executed from the same\n             thread."]
    pub fn furi_record_create(name: *const core::ffi::c_char, data: *mut core::ffi::c_void);
}
extern "C" {
    #[doc = " Open record\n\n @param      name  record name\n\n @return     pointer to the record\n @note       Thread safe. Open and close must be executed from the same\n             thread. Suspends caller thread till record is available"]
    pub fn furi_record_open(name: *const core::ffi::c_char) -> *mut core::ffi::c_void;
}
extern "C" {
    #[doc = " Close record\n\n @param      name  record name\n @note       Thread safe. Open and close must be executed from the same\n             thread."]
    pub fn furi_record_close(name: *const core::ffi::c_char);
}
pub type FuriSemaphore = core::ffi::c_void;
extern "C" {
    #[doc = " Allocate semaphore\n\n @param[in]  max_count      The maximum count\n @param[in]  initial_count  The initial count\n\n @return     pointer to FuriSemaphore instance"]
    pub fn furi_semaphore_alloc(max_count: u32, initial_count: u32) -> *mut FuriSemaphore;
}
extern "C" {
    #[doc = " Free semaphore\n\n @param      instance  The pointer to FuriSemaphore instance"]
    pub fn furi_semaphore_free(instance: *mut FuriSemaphore);
}
extern "C" {
    #[doc = " Acquire semaphore\n\n @param      instance  The pointer to FuriSemaphore instance\n @param[in]  timeout   The timeout\n\n @return     The furi status."]
    pub fn furi_semaphore_acquire(instance: *mut FuriSemaphore, timeout: u32) -> FuriStatus;
}
extern "C" {
    #[doc = " Release semaphore\n\n @param      instance  The pointer to FuriSemaphore instance\n\n @return     The furi status."]
    pub fn furi_semaphore_release(instance: *mut FuriSemaphore) -> FuriStatus;
}
extern "C" {
    #[doc = " Get semaphore count\n\n @param      instance  The pointer to FuriSemaphore instance\n\n @return     Semaphore count"]
    pub fn furi_semaphore_get_count(instance: *mut FuriSemaphore) -> u32;
}
pub type FuriTimerCallback =
    ::core::option::Option<unsafe extern "C" fn(context: *mut core::ffi::c_void)>;
#[doc = "< One-shot timer."]
pub const FuriTimerType_FuriTimerTypeOnce: FuriTimerType = 0;
#[doc = "< Repeating timer."]
pub const FuriTimerType_FuriTimerTypePeriodic: FuriTimerType = 1;
pub type FuriTimerType = core::ffi::c_uchar;
pub type FuriTimer = core::ffi::c_void;
extern "C" {
    #[doc = " Allocate timer\n\n @param[in]  func     The callback function\n @param[in]  type     The timer type\n @param      context  The callback context\n\n @return     The pointer to FuriTimer instance"]
    pub fn furi_timer_alloc(
        func: FuriTimerCallback,
        type_: FuriTimerType,
        context: *mut core::ffi::c_void,
    ) -> *mut FuriTimer;
}
extern "C" {
    #[doc = " Free timer\n\n @param      instance  The pointer to FuriTimer instance"]
    pub fn furi_timer_free(instance: *mut FuriTimer);
}
extern "C" {
    #[doc = " Start timer\n\n @param      instance  The pointer to FuriTimer instance\n @param[in]  ticks     The ticks\n\n @return     The furi status."]
    pub fn furi_timer_start(instance: *mut FuriTimer, ticks: u32) -> FuriStatus;
}
extern "C" {
    #[doc = " Stop timer\n\n @param      instance  The pointer to FuriTimer instance\n\n @return     The furi status."]
    pub fn furi_timer_stop(instance: *mut FuriTimer) -> FuriStatus;
}
extern "C" {
    #[doc = " Is timer running\n\n @param      instance  The pointer to FuriTimer instance\n\n @return     0: not running, 1: running"]
    pub fn furi_timer_is_running(instance: *mut FuriTimer) -> u32;
}
#[doc = " == ValueMutex ==\n\n The most simple concept is ValueMutex.\n It is wrapper around mutex and value pointer.\n You can take and give mutex to work with value and read and write value."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ValueMutex {
    pub value: *mut core::ffi::c_void,
    pub size: usize,
    pub mutex: *mut FuriMutex,
}
#[test]
fn bindgen_test_layout_ValueMutex() {
    const UNINIT: ::core::mem::MaybeUninit<ValueMutex> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<ValueMutex>(),
        12usize,
        concat!("Size of: ", stringify!(ValueMutex))
    );
    assert_eq!(
        ::core::mem::align_of::<ValueMutex>(),
        4usize,
        concat!("Alignment of ", stringify!(ValueMutex))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ValueMutex),
            "::",
            stringify!(value)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ValueMutex),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).mutex) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ValueMutex),
            "::",
            stringify!(mutex)
        )
    );
}
extern "C" {
    #[doc = " Creates ValueMutex."]
    pub fn init_mutex(
        valuemutex: *mut ValueMutex,
        value: *mut core::ffi::c_void,
        size: usize,
    ) -> bool;
}
extern "C" {
    #[doc = " Free resources allocated by `init_mutex`.\n This function doesn't free the memory occupied by `ValueMutex` itself."]
    pub fn delete_mutex(valuemutex: *mut ValueMutex) -> bool;
}
extern "C" {
    #[doc = " Call for work with data stored in mutex.\n @return pointer to data if success, NULL otherwise."]
    pub fn acquire_mutex(valuemutex: *mut ValueMutex, timeout: u32) -> *mut core::ffi::c_void;
}
extern "C" {
    #[doc = " Release mutex after end of work with data.\n Call `release_mutex` and pass ValueData instance and pointer to data."]
    pub fn release_mutex(valuemutex: *mut ValueMutex, value: *const core::ffi::c_void) -> bool;
}
extern "C" {
    pub static _ctype_: [core::ffi::c_char; 0usize];
}
extern "C" {
    pub fn __assert_func(
        arg1: *const core::ffi::c_char,
        arg2: core::ffi::c_int,
        arg3: *const core::ffi::c_char,
        arg4: *const core::ffi::c_char,
    ) -> !;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FuriString {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " @brief Allocate new FuriString.\n @return FuriString*"]
    pub fn furi_string_alloc() -> *mut FuriString;
}
extern "C" {
    #[doc = " @brief Allocate new FuriString and set it to string.\n Allocate & Set the string a to the string.\n @param source\n @return FuriString*"]
    pub fn furi_string_alloc_set(source: *const FuriString) -> *mut FuriString;
}
extern "C" {
    #[doc = " @brief Allocate new FuriString and set it to C string.\n Allocate & Set the string a to the C string.\n @param cstr_source\n @return FuriString*"]
    pub fn furi_string_alloc_set_str(cstr_source: *const core::ffi::c_char) -> *mut FuriString;
}
extern "C" {
    #[doc = " @brief Allocate new FuriString and printf to it.\n Initialize and set a string to the given formatted value.\n @param format\n @param ...\n @return FuriString*"]
    pub fn furi_string_alloc_printf(format: *const core::ffi::c_char, ...) -> *mut FuriString;
}
extern "C" {
    #[doc = " @brief Allocate new FuriString and printf to it.\n Initialize and set a string to the given formatted value.\n @param format\n @param args\n @return FuriString*"]
    pub fn furi_string_alloc_vprintf(
        format: *const core::ffi::c_char,
        args: va_list,
    ) -> *mut FuriString;
}
extern "C" {
    #[doc = " @brief Allocate new FuriString and move source string content to it.\n Allocate the string, set it to the other one, and destroy the other one.\n @param source\n @return FuriString*"]
    pub fn furi_string_alloc_move(source: *mut FuriString) -> *mut FuriString;
}
extern "C" {
    #[doc = " @brief Free FuriString.\n @param string"]
    pub fn furi_string_free(string: *mut FuriString);
}
extern "C" {
    #[doc = " @brief Reserve memory for string.\n Modify the string capacity to be able to handle at least 'alloc' characters (including final null char).\n @param string\n @param size"]
    pub fn furi_string_reserve(string: *mut FuriString, size: usize);
}
extern "C" {
    #[doc = " @brief Reset string.\n Make the string empty.\n @param s"]
    pub fn furi_string_reset(string: *mut FuriString);
}
extern "C" {
    #[doc = " @brief Swap two strings.\n Swap the two strings string_1 and string_2.\n @param string_1\n @param string_2"]
    pub fn furi_string_swap(string_1: *mut FuriString, string_2: *mut FuriString);
}
extern "C" {
    #[doc = " @brief Move string_2 content to string_1.\n Set the string to the other one, and destroy the other one.\n @param string_1\n @param string_2"]
    pub fn furi_string_move(string_1: *mut FuriString, string_2: *mut FuriString);
}
extern "C" {
    #[doc = " @brief Compute a hash for the string.\n @param string\n @return size_t"]
    pub fn furi_string_hash(string: *const FuriString) -> usize;
}
extern "C" {
    #[doc = " @brief Get string size (usually length, but not for UTF-8)\n @param string\n @return size_t"]
    pub fn furi_string_size(string: *const FuriString) -> usize;
}
extern "C" {
    #[doc = " @brief Check that string is empty or not\n @param string\n @return bool"]
    pub fn furi_string_empty(string: *const FuriString) -> bool;
}
extern "C" {
    #[doc = " @brief Get the character at the given index.\n Return the selected character of the string.\n @param string\n @param index\n @return char"]
    pub fn furi_string_get_char(string: *const FuriString, index: usize) -> core::ffi::c_char;
}
extern "C" {
    #[doc = " @brief Return the string view a classic C string.\n @param string\n @return const char*"]
    pub fn furi_string_get_cstr(string: *const FuriString) -> *const core::ffi::c_char;
}
extern "C" {
    #[doc = " @brief Set the string to the other string.\n Set the string to the source string.\n @param string\n @param source"]
    pub fn furi_string_set(string: *mut FuriString, source: *mut FuriString);
}
extern "C" {
    #[doc = " @brief Set the string to the other C string.\n Set the string to the source C string.\n @param string\n @param source"]
    pub fn furi_string_set_str(string: *mut FuriString, source: *const core::ffi::c_char);
}
extern "C" {
    #[doc = " @brief Set the string to the n first characters of the C string.\n @param string\n @param source\n @param length"]
    pub fn furi_string_set_strn(
        string: *mut FuriString,
        source: *const core::ffi::c_char,
        length: usize,
    );
}
extern "C" {
    #[doc = " @brief Set the character at the given index.\n @param string\n @param index\n @param c"]
    pub fn furi_string_set_char(string: *mut FuriString, index: usize, c: core::ffi::c_char);
}
extern "C" {
    #[doc = " @brief Set the string to the n first characters of other one.\n @param string\n @param source\n @param offset\n @param length"]
    pub fn furi_string_set_n(
        string: *mut FuriString,
        source: *const FuriString,
        offset: usize,
        length: usize,
    );
}
extern "C" {
    #[doc = " @brief Format in the string the given printf format\n @param string\n @param format\n @param ...\n @return int"]
    pub fn furi_string_printf(
        string: *mut FuriString,
        format: *const core::ffi::c_char,
        ...
    ) -> core::ffi::c_int;
}
extern "C" {
    #[doc = " @brief Format in the string the given printf format\n @param string\n @param format\n @param args\n @return int"]
    pub fn furi_string_vprintf(
        string: *mut FuriString,
        format: *const core::ffi::c_char,
        args: va_list,
    ) -> core::ffi::c_int;
}
extern "C" {
    #[doc = " @brief Append a character to the string.\n @param string\n @param c"]
    pub fn furi_string_push_back(string: *mut FuriString, c: core::ffi::c_char);
}
extern "C" {
    #[doc = " @brief Append a string to the string.\n Concatenate the string with the other string.\n @param string_1\n @param string_2"]
    pub fn furi_string_cat(string_1: *mut FuriString, string_2: *const FuriString);
}
extern "C" {
    #[doc = " @brief Append a C string to the string.\n Concatenate the string with the C string.\n @param string_1\n @param cstring_2"]
    pub fn furi_string_cat_str(string_1: *mut FuriString, cstring_2: *const core::ffi::c_char);
}
extern "C" {
    #[doc = " @brief Append to the string the formatted string of the given printf format.\n @param string\n @param format\n @param ...\n @return int"]
    pub fn furi_string_cat_printf(
        string: *mut FuriString,
        format: *const core::ffi::c_char,
        ...
    ) -> core::ffi::c_int;
}
extern "C" {
    #[doc = " @brief Append to the string the formatted string of the given printf format.\n @param string\n @param format\n @param args\n @return int"]
    pub fn furi_string_cat_vprintf(
        string: *mut FuriString,
        format: *const core::ffi::c_char,
        args: va_list,
    ) -> core::ffi::c_int;
}
extern "C" {
    #[doc = " @brief Compare two strings and return the sort order.\n @param string_1\n @param string_2\n @return int"]
    pub fn furi_string_cmp(
        string_1: *const FuriString,
        string_2: *const FuriString,
    ) -> core::ffi::c_int;
}
extern "C" {
    #[doc = " @brief Compare string with C string and return the sort order.\n @param string_1\n @param cstring_2\n @return int"]
    pub fn furi_string_cmp_str(
        string_1: *const FuriString,
        cstring_2: *const core::ffi::c_char,
    ) -> core::ffi::c_int;
}
extern "C" {
    #[doc = " @brief Compare two strings (case insensitive according to the current locale) and return the sort order.\n Note: doesn't work with UTF-8 strings.\n @param string_1\n @param string_2\n @return int"]
    pub fn furi_string_cmpi(
        string_1: *const FuriString,
        string_2: *const FuriString,
    ) -> core::ffi::c_int;
}
extern "C" {
    #[doc = " @brief Compare string with C string (case insensitive according to the current locale) and return the sort order.\n Note: doesn't work with UTF-8 strings.\n @param string_1\n @param cstring_2\n @return int"]
    pub fn furi_string_cmpi_str(
        string_1: *const FuriString,
        cstring_2: *const core::ffi::c_char,
    ) -> core::ffi::c_int;
}
extern "C" {
    #[doc = " @brief Search the first occurrence of the needle in the string from the position start.\n Return STRING_FAILURE if not found.\n By default, start is zero.\n @param string\n @param needle\n @param start\n @return size_t"]
    pub fn furi_string_search(
        string: *const FuriString,
        needle: *const FuriString,
        start: usize,
    ) -> usize;
}
extern "C" {
    #[doc = " @brief Search the first occurrence of the needle in the string from the position start.\n Return STRING_FAILURE if not found.\n @param string\n @param needle\n @param start\n @return size_t"]
    pub fn furi_string_search_str(
        string: *const FuriString,
        needle: *const core::ffi::c_char,
        start: usize,
    ) -> usize;
}
extern "C" {
    #[doc = " @brief Search for the position of the character c from the position start (include) in the string.\n Return STRING_FAILURE if not found.\n By default, start is zero.\n @param string\n @param c\n @param start\n @return size_t"]
    pub fn furi_string_search_char(
        string: *const FuriString,
        c: core::ffi::c_char,
        start: usize,
    ) -> usize;
}
extern "C" {
    #[doc = " @brief Reverse search for the position of the character c from the position start (include) in the string.\n Return STRING_FAILURE if not found.\n By default, start is zero.\n @param string\n @param c\n @param start\n @return size_t"]
    pub fn furi_string_search_rchar(
        string: *const FuriString,
        c: core::ffi::c_char,
        start: usize,
    ) -> usize;
}
extern "C" {
    #[doc = " @brief Test if two strings are equal.\n @param string_1\n @param string_2\n @return bool"]
    pub fn furi_string_equal(string_1: *const FuriString, string_2: *const FuriString) -> bool;
}
extern "C" {
    #[doc = " @brief Test if the string is equal to the C string.\n @param string_1\n @param cstring_2\n @return bool"]
    pub fn furi_string_equal_str(
        string_1: *const FuriString,
        cstring_2: *const core::ffi::c_char,
    ) -> bool;
}
extern "C" {
    #[doc = " @brief Replace in the string the sub-string at position 'pos' for 'len' bytes into the C string 'replace'.\n @param string\n @param pos\n @param len\n @param replace"]
    pub fn furi_string_replace_at(
        string: *mut FuriString,
        pos: usize,
        len: usize,
        replace: *const core::ffi::c_char,
    );
}
extern "C" {
    #[doc = " @brief Replace a string 'needle' to string 'replace' in a string from 'start' position.\n By default, start is zero.\n Return STRING_FAILURE if 'needle' not found or replace position.\n @param string\n @param needle\n @param replace\n @param start\n @return size_t"]
    pub fn furi_string_replace(
        string: *mut FuriString,
        needle: *mut FuriString,
        replace: *mut FuriString,
        start: usize,
    ) -> usize;
}
extern "C" {
    #[doc = " @brief Replace a C string 'needle' to C string 'replace' in a string from 'start' position.\n By default, start is zero.\n Return STRING_FAILURE if 'needle' not found or replace position.\n @param string\n @param needle\n @param replace\n @param start\n @return size_t"]
    pub fn furi_string_replace_str(
        string: *mut FuriString,
        needle: *const core::ffi::c_char,
        replace: *const core::ffi::c_char,
        start: usize,
    ) -> usize;
}
extern "C" {
    #[doc = " @brief Replace all occurrences of 'needle' string into 'replace' string.\n @param string\n @param needle\n @param replace"]
    pub fn furi_string_replace_all(
        string: *mut FuriString,
        needle: *const FuriString,
        replace: *const FuriString,
    );
}
extern "C" {
    #[doc = " @brief Replace all occurrences of 'needle' C string into 'replace' C string.\n @param string\n @param needle\n @param replace"]
    pub fn furi_string_replace_all_str(
        string: *mut FuriString,
        needle: *const core::ffi::c_char,
        replace: *const core::ffi::c_char,
    );
}
extern "C" {
    #[doc = " @brief Test if the string starts with the given string.\n @param string\n @param start\n @return bool"]
    pub fn furi_string_start_with(string: *const FuriString, start: *const FuriString) -> bool;
}
extern "C" {
    #[doc = " @brief Test if the string starts with the given C string.\n @param string\n @param start\n @return bool"]
    pub fn furi_string_start_with_str(
        string: *const FuriString,
        start: *const core::ffi::c_char,
    ) -> bool;
}
extern "C" {
    #[doc = " @brief Test if the string ends with the given string.\n @param string\n @param end\n @return bool"]
    pub fn furi_string_end_with(string: *const FuriString, end: *const FuriString) -> bool;
}
extern "C" {
    #[doc = " @brief Test if the string ends with the given C string.\n @param string\n @param end\n @return bool"]
    pub fn furi_string_end_with_str(
        string: *const FuriString,
        end: *const core::ffi::c_char,
    ) -> bool;
}
extern "C" {
    #[doc = " @brief Trim the string left to the first 'index' bytes.\n @param string\n @param index"]
    pub fn furi_string_left(string: *mut FuriString, index: usize);
}
extern "C" {
    #[doc = " @brief Trim the string right from the 'index' position to the last position.\n @param string\n @param index"]
    pub fn furi_string_right(string: *mut FuriString, index: usize);
}
extern "C" {
    #[doc = " @brief Trim the string from position index to size bytes.\n See also furi_string_set_n.\n @param string\n @param index\n @param size"]
    pub fn furi_string_mid(string: *mut FuriString, index: usize, size: usize);
}
extern "C" {
    #[doc = " @brief Trim a string from the given set of characters (default is \" \\n\\r\\t\").\n @param string\n @param chars"]
    pub fn furi_string_trim(string: *mut FuriString, chars: *const core::ffi::c_char);
}
#[doc = " @brief An unicode value."]
pub type FuriStringUnicodeValue = core::ffi::c_uint;
extern "C" {
    #[doc = " @brief Compute the length in UTF8 characters in the string.\n @param string\n @return size_t"]
    pub fn furi_string_utf8_length(string: *mut FuriString) -> usize;
}
extern "C" {
    #[doc = " @brief Push unicode into string, encoding it in UTF8.\n @param string\n @param unicode"]
    pub fn furi_string_utf8_push(string: *mut FuriString, unicode: FuriStringUnicodeValue);
}
pub const FuriStringUTF8State_FuriStringUTF8StateStarting: FuriStringUTF8State = 0;
pub const FuriStringUTF8State_FuriStringUTF8StateDecoding1: FuriStringUTF8State = 1;
pub const FuriStringUTF8State_FuriStringUTF8StateDecoding2: FuriStringUTF8State = 2;
pub const FuriStringUTF8State_FuriStringUTF8StateDecoding3: FuriStringUTF8State = 3;
pub const FuriStringUTF8State_FuriStringUTF8StateError: FuriStringUTF8State = 4;
#[doc = " @brief State of the UTF8 decoding machine state."]
pub type FuriStringUTF8State = core::ffi::c_uchar;
extern "C" {
    #[doc = " @brief Main generic UTF8 decoder.\n It takes a character, and the previous state and the previous value of the unicode value.\n It updates the state and the decoded unicode value.\n A decoded unicode encoded value is valid only when the state is FuriStringUTF8StateStarting.\n @param c\n @param state\n @param unicode"]
    pub fn furi_string_utf8_decode(
        c: core::ffi::c_char,
        state: *mut FuriStringUTF8State,
        unicode: *mut FuriStringUnicodeValue,
    );
}
pub type FuriStreamBuffer = core::ffi::c_void;
extern "C" {
    #[doc = " @brief Allocate stream buffer instance.\n Stream buffer implementation assumes there is only one task or\n interrupt that will write to the buffer (the writer), and only one task or\n interrupt that will read from the buffer (the reader).\n\n @param size The total number of bytes the stream buffer will be able to hold at any one time.\n @param trigger_level The number of bytes that must be in the stream buffer\n before a task that is blocked on the stream buffer to wait for data is moved out of the blocked state.\n @return The stream buffer instance."]
    pub fn furi_stream_buffer_alloc(size: usize, trigger_level: usize) -> *mut FuriStreamBuffer;
}
extern "C" {
    #[doc = " @brief Free stream buffer instance\n\n @param stream_buffer The stream buffer instance."]
    pub fn furi_stream_buffer_free(stream_buffer: *mut FuriStreamBuffer);
}
extern "C" {
    #[doc = " @brief Set trigger level for stream buffer.\n A stream buffer's trigger level is the number of bytes that must be in the\n stream buffer before a task that is blocked on the stream buffer to\n wait for data is moved out of the blocked state.\n\n @param stream_buffer The stream buffer instance\n @param trigger_level The new trigger level for the stream buffer.\n @return true if trigger level can be be updated (new trigger level was less than or equal to the stream buffer's length).\n @return false if trigger level can't be be updated (new trigger level was greater than the stream buffer's length)."]
    pub fn furi_stream_set_trigger_level(
        stream_buffer: *mut FuriStreamBuffer,
        trigger_level: usize,
    ) -> bool;
}
extern "C" {
    #[doc = " @brief Sends bytes to a stream buffer. The bytes are copied into the stream buffer.\n Wakes up task waiting for data to become available if called from ISR.\n\n @param stream_buffer The stream buffer instance.\n @param data A pointer to the data that is to be copied into the stream buffer.\n @param length The maximum number of bytes to copy from data into the stream buffer.\n @param timeout The maximum amount of time the task should remain in the\n Blocked state to wait for space to become available if the stream buffer is full.\n Will return immediately if timeout is zero.\n Setting timeout to FuriWaitForever will cause the task to wait indefinitely.\n Ignored if called from ISR.\n @return The number of bytes actually written to the stream buffer."]
    pub fn furi_stream_buffer_send(
        stream_buffer: *mut FuriStreamBuffer,
        data: *const core::ffi::c_void,
        length: usize,
        timeout: u32,
    ) -> usize;
}
extern "C" {
    #[doc = " @brief Receives bytes from a stream buffer.\n Wakes up task waiting for space to become available if called from ISR.\n\n @param stream_buffer The stream buffer instance.\n @param data A pointer to the buffer into which the received bytes will be\n copied.\n @param length The length of the buffer pointed to by the data parameter.\n @param timeout The maximum amount of time the task should remain in the\n Blocked state to wait for data to become available if the stream buffer is empty.\n Will return immediately if timeout is zero.\n Setting timeout to FuriWaitForever will cause the task to wait indefinitely.\n Ignored if called from ISR.\n @return The number of bytes read from the stream buffer, if any."]
    pub fn furi_stream_buffer_receive(
        stream_buffer: *mut FuriStreamBuffer,
        data: *mut core::ffi::c_void,
        length: usize,
        timeout: u32,
    ) -> usize;
}
extern "C" {
    #[doc = " @brief Queries a stream buffer to see how much data it contains, which is equal to\n the number of bytes that can be read from the stream buffer before the stream\n buffer would be empty.\n\n @param stream_buffer The stream buffer instance.\n @return The number of bytes that can be read from the stream buffer before\n the stream buffer would be empty."]
    pub fn furi_stream_buffer_bytes_available(stream_buffer: *mut FuriStreamBuffer) -> usize;
}
extern "C" {
    #[doc = " @brief Queries a stream buffer to see how much free space it contains, which is\n equal to the amount of data that can be sent to the stream buffer before it\n is full.\n\n @param stream_buffer The stream buffer instance.\n @return The number of bytes that can be written to the stream buffer before\n the stream buffer would be full."]
    pub fn furi_stream_buffer_spaces_available(stream_buffer: *mut FuriStreamBuffer) -> usize;
}
extern "C" {
    #[doc = " @brief Queries a stream buffer to see if it is full.\n\n @param stream_buffer stream buffer instance.\n @return true if the stream buffer is full.\n @return false if the stream buffer is not full."]
    pub fn furi_stream_buffer_is_full(stream_buffer: *mut FuriStreamBuffer) -> bool;
}
extern "C" {
    #[doc = " @brief Queries a stream buffer to see if it is empty.\n\n @param stream_buffer The stream buffer instance.\n @return true if the stream buffer is empty.\n @return false if the stream buffer is not empty."]
    pub fn furi_stream_buffer_is_empty(stream_buffer: *mut FuriStreamBuffer) -> bool;
}
extern "C" {
    #[doc = " @brief Resets a stream buffer to its initial, empty, state. Any data that was\n in the stream buffer is discarded. A stream buffer can only be reset if there\n are no tasks blocked waiting to either send to or receive from the stream buffer.\n\n @param stream_buffer The stream buffer instance.\n @return FuriStatusOk if the stream buffer is reset.\n @return FuriStatusError if there was a task blocked waiting to send to or read\n from the stream buffer then the stream buffer is not reset."]
    pub fn furi_stream_buffer_reset(stream_buffer: *mut FuriStreamBuffer) -> FuriStatus;
}
#[doc = " @brief Comparator"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct COMP_TypeDef {
    #[doc = "< COMP control and status register,               Address offset: 0x00"]
    pub CSR: u32,
}
#[test]
fn bindgen_test_layout_COMP_TypeDef() {
    const UNINIT: ::core::mem::MaybeUninit<COMP_TypeDef> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<COMP_TypeDef>(),
        4usize,
        concat!("Size of: ", stringify!(COMP_TypeDef))
    );
    assert_eq!(
        ::core::mem::align_of::<COMP_TypeDef>(),
        4usize,
        concat!("Alignment of ", stringify!(COMP_TypeDef))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CSR) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(COMP_TypeDef),
            "::",
            stringify!(CSR)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DMA_TypeDef {
    #[doc = "< DMA interrupt status register,                 Address offset: 0x00"]
    pub ISR: u32,
    #[doc = "< DMA interrupt flag clear register,             Address offset: 0x04"]
    pub IFCR: u32,
}
#[test]
fn bindgen_test_layout_DMA_TypeDef() {
    const UNINIT: ::core::mem::MaybeUninit<DMA_TypeDef> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<DMA_TypeDef>(),
        8usize,
        concat!("Size of: ", stringify!(DMA_TypeDef))
    );
    assert_eq!(
        ::core::mem::align_of::<DMA_TypeDef>(),
        4usize,
        concat!("Alignment of ", stringify!(DMA_TypeDef))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ISR) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DMA_TypeDef),
            "::",
            stringify!(ISR)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).IFCR) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(DMA_TypeDef),
            "::",
            stringify!(IFCR)
        )
    );
}
#[doc = " @brief General Purpose I/O"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GPIO_TypeDef {
    #[doc = "< GPIO port mode register,               Address offset: 0x00"]
    pub MODER: u32,
    #[doc = "< GPIO port output type register,        Address offset: 0x04"]
    pub OTYPER: u32,
    #[doc = "< GPIO port output speed register,       Address offset: 0x08"]
    pub OSPEEDR: u32,
    #[doc = "< GPIO port pull-up/pull-down register,  Address offset: 0x0C"]
    pub PUPDR: u32,
    #[doc = "< GPIO port input data register,         Address offset: 0x10"]
    pub IDR: u32,
    #[doc = "< GPIO port output data register,        Address offset: 0x14"]
    pub ODR: u32,
    #[doc = "< GPIO port bit set/reset  register,     Address offset: 0x18"]
    pub BSRR: u32,
    #[doc = "< GPIO port configuration lock register, Address offset: 0x1C"]
    pub LCKR: u32,
    #[doc = "< GPIO alternate function registers,     Address offset: 0x20-0x24"]
    pub AFR: [u32; 2usize],
    #[doc = "< GPIO Bit Reset register,               Address offset: 0x28"]
    pub BRR: u32,
}
#[test]
fn bindgen_test_layout_GPIO_TypeDef() {
    const UNINIT: ::core::mem::MaybeUninit<GPIO_TypeDef> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<GPIO_TypeDef>(),
        44usize,
        concat!("Size of: ", stringify!(GPIO_TypeDef))
    );
    assert_eq!(
        ::core::mem::align_of::<GPIO_TypeDef>(),
        4usize,
        concat!("Alignment of ", stringify!(GPIO_TypeDef))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).MODER) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GPIO_TypeDef),
            "::",
            stringify!(MODER)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).OTYPER) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(GPIO_TypeDef),
            "::",
            stringify!(OTYPER)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).OSPEEDR) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(GPIO_TypeDef),
            "::",
            stringify!(OSPEEDR)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).PUPDR) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(GPIO_TypeDef),
            "::",
            stringify!(PUPDR)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).IDR) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(GPIO_TypeDef),
            "::",
            stringify!(IDR)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ODR) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(GPIO_TypeDef),
            "::",
            stringify!(ODR)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).BSRR) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(GPIO_TypeDef),
            "::",
            stringify!(BSRR)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).LCKR) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(GPIO_TypeDef),
            "::",
            stringify!(LCKR)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).AFR) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(GPIO_TypeDef),
            "::",
            stringify!(AFR)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).BRR) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(GPIO_TypeDef),
            "::",
            stringify!(BRR)
        )
    );
}
#[doc = " @brief Inter-integrated Circuit Interface"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct I2C_TypeDef {
    #[doc = "< I2C Control register 1,            Address offset: 0x00"]
    pub CR1: u32,
    #[doc = "< I2C Control register 2,            Address offset: 0x04"]
    pub CR2: u32,
    #[doc = "< I2C Own address 1 register,        Address offset: 0x08"]
    pub OAR1: u32,
    #[doc = "< I2C Own address 2 register,        Address offset: 0x0C"]
    pub OAR2: u32,
    #[doc = "< I2C Timing register,               Address offset: 0x10"]
    pub TIMINGR: u32,
    #[doc = "< I2C Timeout register,              Address offset: 0x14"]
    pub TIMEOUTR: u32,
    #[doc = "< I2C Interrupt and status register, Address offset: 0x18"]
    pub ISR: u32,
    #[doc = "< I2C Interrupt clear register,      Address offset: 0x1C"]
    pub ICR: u32,
    #[doc = "< I2C PEC register,                  Address offset: 0x20"]
    pub PECR: u32,
    #[doc = "< I2C Receive data register,         Address offset: 0x24"]
    pub RXDR: u32,
    #[doc = "< I2C Transmit data register,        Address offset: 0x28"]
    pub TXDR: u32,
}
#[test]
fn bindgen_test_layout_I2C_TypeDef() {
    const UNINIT: ::core::mem::MaybeUninit<I2C_TypeDef> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<I2C_TypeDef>(),
        44usize,
        concat!("Size of: ", stringify!(I2C_TypeDef))
    );
    assert_eq!(
        ::core::mem::align_of::<I2C_TypeDef>(),
        4usize,
        concat!("Alignment of ", stringify!(I2C_TypeDef))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CR1) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(I2C_TypeDef),
            "::",
            stringify!(CR1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CR2) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(I2C_TypeDef),
            "::",
            stringify!(CR2)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).OAR1) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(I2C_TypeDef),
            "::",
            stringify!(OAR1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).OAR2) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(I2C_TypeDef),
            "::",
            stringify!(OAR2)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).TIMINGR) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(I2C_TypeDef),
            "::",
            stringify!(TIMINGR)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).TIMEOUTR) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(I2C_TypeDef),
            "::",
            stringify!(TIMEOUTR)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ISR) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(I2C_TypeDef),
            "::",
            stringify!(ISR)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ICR) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(I2C_TypeDef),
            "::",
            stringify!(ICR)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).PECR) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(I2C_TypeDef),
            "::",
            stringify!(PECR)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).RXDR) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(I2C_TypeDef),
            "::",
            stringify!(RXDR)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).TXDR) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(I2C_TypeDef),
            "::",
            stringify!(TXDR)
        )
    );
}
#[doc = " @brief LPTIMER"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LPTIM_TypeDef {
    #[doc = "< LPTIM Interrupt and Status register,                Address offset: 0x00"]
    pub ISR: u32,
    #[doc = "< LPTIM Interrupt Clear register,                     Address offset: 0x04"]
    pub ICR: u32,
    #[doc = "< LPTIM Interrupt Enable register,                    Address offset: 0x08"]
    pub IER: u32,
    #[doc = "< LPTIM Configuration register,                       Address offset: 0x0C"]
    pub CFGR: u32,
    #[doc = "< LPTIM Control register,                             Address offset: 0x10"]
    pub CR: u32,
    #[doc = "< LPTIM Compare register,                             Address offset: 0x14"]
    pub CMP: u32,
    #[doc = "< LPTIM Autoreload register,                          Address offset: 0x18"]
    pub ARR: u32,
    #[doc = "< LPTIM Counter register,                             Address offset: 0x1C"]
    pub CNT: u32,
    #[doc = "< LPTIM Option register,                              Address offset: 0x20"]
    pub OR: u32,
}
#[test]
fn bindgen_test_layout_LPTIM_TypeDef() {
    const UNINIT: ::core::mem::MaybeUninit<LPTIM_TypeDef> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<LPTIM_TypeDef>(),
        36usize,
        concat!("Size of: ", stringify!(LPTIM_TypeDef))
    );
    assert_eq!(
        ::core::mem::align_of::<LPTIM_TypeDef>(),
        4usize,
        concat!("Alignment of ", stringify!(LPTIM_TypeDef))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ISR) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(LPTIM_TypeDef),
            "::",
            stringify!(ISR)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ICR) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(LPTIM_TypeDef),
            "::",
            stringify!(ICR)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).IER) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(LPTIM_TypeDef),
            "::",
            stringify!(IER)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CFGR) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(LPTIM_TypeDef),
            "::",
            stringify!(CFGR)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CR) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(LPTIM_TypeDef),
            "::",
            stringify!(CR)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CMP) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(LPTIM_TypeDef),
            "::",
            stringify!(CMP)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ARR) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(LPTIM_TypeDef),
            "::",
            stringify!(ARR)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CNT) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(LPTIM_TypeDef),
            "::",
            stringify!(CNT)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).OR) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(LPTIM_TypeDef),
            "::",
            stringify!(OR)
        )
    );
}
#[doc = " @brief Real-Time Clock"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RTC_TypeDef {
    #[doc = "< RTC time register,                                         Address offset: 0x00"]
    pub TR: u32,
    #[doc = "< RTC date register,                                         Address offset: 0x04"]
    pub DR: u32,
    #[doc = "< RTC control register,                                      Address offset: 0x08"]
    pub CR: u32,
    #[doc = "< RTC initialization and status register,                    Address offset: 0x0C"]
    pub ISR: u32,
    #[doc = "< RTC prescaler register,                                    Address offset: 0x10"]
    pub PRER: u32,
    #[doc = "< RTC wakeup timer register,                                 Address offset: 0x14"]
    pub WUTR: u32,
    #[doc = "< Reserved,                                                  Address offset: 0x18"]
    pub RESERVED: u32,
    #[doc = "< RTC alarm A register,                                      Address offset: 0x1C"]
    pub ALRMAR: u32,
    #[doc = "< RTC alarm B register,                                      Address offset: 0x20"]
    pub ALRMBR: u32,
    #[doc = "< RTC write protection register,                             Address offset: 0x24"]
    pub WPR: u32,
    #[doc = "< RTC sub second register,                                   Address offset: 0x28"]
    pub SSR: u32,
    #[doc = "< RTC shift control register,                                Address offset: 0x2C"]
    pub SHIFTR: u32,
    #[doc = "< RTC time stamp time register,                              Address offset: 0x30"]
    pub TSTR: u32,
    #[doc = "< RTC time stamp date register,                              Address offset: 0x34"]
    pub TSDR: u32,
    #[doc = "< RTC time-stamp sub second register,                        Address offset: 0x38"]
    pub TSSSR: u32,
    #[doc = "< RTC calibration register,                                  Address offset: 0x3C"]
    pub CALR: u32,
    #[doc = "< RTC tamper configuration register,                         Address offset: 0x40"]
    pub TAMPCR: u32,
    #[doc = "< RTC alarm A sub second register,                           Address offset: 0x44"]
    pub ALRMASSR: u32,
    #[doc = "< RTC alarm B sub second register,                           Address offset: 0x48"]
    pub ALRMBSSR: u32,
    #[doc = "< RTC option register,                                       Address offset  0x4C"]
    pub OR: u32,
    #[doc = "< RTC backup register 0,                                     Address offset: 0x50"]
    pub BKP0R: u32,
    #[doc = "< RTC backup register 1,                                     Address offset: 0x54"]
    pub BKP1R: u32,
    #[doc = "< RTC backup register 2,                                     Address offset: 0x58"]
    pub BKP2R: u32,
    #[doc = "< RTC backup register 3,                                     Address offset: 0x5C"]
    pub BKP3R: u32,
    #[doc = "< RTC backup register 4,                                     Address offset: 0x60"]
    pub BKP4R: u32,
    #[doc = "< RTC backup register 5,                                     Address offset: 0x64"]
    pub BKP5R: u32,
    #[doc = "< RTC backup register 6,                                     Address offset: 0x68"]
    pub BKP6R: u32,
    #[doc = "< RTC backup register 7,                                     Address offset: 0x6C"]
    pub BKP7R: u32,
    #[doc = "< RTC backup register 8,                                     Address offset: 0x70"]
    pub BKP8R: u32,
    #[doc = "< RTC backup register 9,                                     Address offset: 0x74"]
    pub BKP9R: u32,
    #[doc = "< RTC backup register 10,                                    Address offset: 0x78"]
    pub BKP10R: u32,
    #[doc = "< RTC backup register 11,                                    Address offset: 0x7C"]
    pub BKP11R: u32,
    #[doc = "< RTC backup register 12,                                    Address offset: 0x80"]
    pub BKP12R: u32,
    #[doc = "< RTC backup register 13,                                    Address offset: 0x84"]
    pub BKP13R: u32,
    #[doc = "< RTC backup register 14,                                    Address offset: 0x88"]
    pub BKP14R: u32,
    #[doc = "< RTC backup register 15,                                    Address offset: 0x8C"]
    pub BKP15R: u32,
    #[doc = "< RTC backup register 16,                                    Address offset: 0x90"]
    pub BKP16R: u32,
    #[doc = "< RTC backup register 17,                                    Address offset: 0x94"]
    pub BKP17R: u32,
    #[doc = "< RTC backup register 18,                                    Address offset: 0x98"]
    pub BKP18R: u32,
    #[doc = "< RTC backup register 19,                                    Address offset: 0x9C"]
    pub BKP19R: u32,
}
#[test]
fn bindgen_test_layout_RTC_TypeDef() {
    const UNINIT: ::core::mem::MaybeUninit<RTC_TypeDef> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<RTC_TypeDef>(),
        160usize,
        concat!("Size of: ", stringify!(RTC_TypeDef))
    );
    assert_eq!(
        ::core::mem::align_of::<RTC_TypeDef>(),
        4usize,
        concat!("Alignment of ", stringify!(RTC_TypeDef))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).TR) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_TypeDef),
            "::",
            stringify!(TR)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).DR) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_TypeDef),
            "::",
            stringify!(DR)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CR) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_TypeDef),
            "::",
            stringify!(CR)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ISR) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_TypeDef),
            "::",
            stringify!(ISR)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).PRER) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_TypeDef),
            "::",
            stringify!(PRER)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).WUTR) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_TypeDef),
            "::",
            stringify!(WUTR)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).RESERVED) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_TypeDef),
            "::",
            stringify!(RESERVED)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ALRMAR) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_TypeDef),
            "::",
            stringify!(ALRMAR)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ALRMBR) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_TypeDef),
            "::",
            stringify!(ALRMBR)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).WPR) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_TypeDef),
            "::",
            stringify!(WPR)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).SSR) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_TypeDef),
            "::",
            stringify!(SSR)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).SHIFTR) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_TypeDef),
            "::",
            stringify!(SHIFTR)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).TSTR) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_TypeDef),
            "::",
            stringify!(TSTR)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).TSDR) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_TypeDef),
            "::",
            stringify!(TSDR)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).TSSSR) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_TypeDef),
            "::",
            stringify!(TSSSR)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CALR) as usize - ptr as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_TypeDef),
            "::",
            stringify!(CALR)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).TAMPCR) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_TypeDef),
            "::",
            stringify!(TAMPCR)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ALRMASSR) as usize - ptr as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_TypeDef),
            "::",
            stringify!(ALRMASSR)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ALRMBSSR) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_TypeDef),
            "::",
            stringify!(ALRMBSSR)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).OR) as usize - ptr as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_TypeDef),
            "::",
            stringify!(OR)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).BKP0R) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_TypeDef),
            "::",
            stringify!(BKP0R)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).BKP1R) as usize - ptr as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_TypeDef),
            "::",
            stringify!(BKP1R)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).BKP2R) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_TypeDef),
            "::",
            stringify!(BKP2R)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).BKP3R) as usize - ptr as usize },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_TypeDef),
            "::",
            stringify!(BKP3R)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).BKP4R) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_TypeDef),
            "::",
            stringify!(BKP4R)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).BKP5R) as usize - ptr as usize },
        100usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_TypeDef),
            "::",
            stringify!(BKP5R)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).BKP6R) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_TypeDef),
            "::",
            stringify!(BKP6R)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).BKP7R) as usize - ptr as usize },
        108usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_TypeDef),
            "::",
            stringify!(BKP7R)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).BKP8R) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_TypeDef),
            "::",
            stringify!(BKP8R)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).BKP9R) as usize - ptr as usize },
        116usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_TypeDef),
            "::",
            stringify!(BKP9R)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).BKP10R) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_TypeDef),
            "::",
            stringify!(BKP10R)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).BKP11R) as usize - ptr as usize },
        124usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_TypeDef),
            "::",
            stringify!(BKP11R)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).BKP12R) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_TypeDef),
            "::",
            stringify!(BKP12R)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).BKP13R) as usize - ptr as usize },
        132usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_TypeDef),
            "::",
            stringify!(BKP13R)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).BKP14R) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_TypeDef),
            "::",
            stringify!(BKP14R)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).BKP15R) as usize - ptr as usize },
        140usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_TypeDef),
            "::",
            stringify!(BKP15R)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).BKP16R) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_TypeDef),
            "::",
            stringify!(BKP16R)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).BKP17R) as usize - ptr as usize },
        148usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_TypeDef),
            "::",
            stringify!(BKP17R)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).BKP18R) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_TypeDef),
            "::",
            stringify!(BKP18R)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).BKP19R) as usize - ptr as usize },
        156usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_TypeDef),
            "::",
            stringify!(BKP19R)
        )
    );
}
#[doc = " @brief Serial Peripheral Interface"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SPI_TypeDef {
    #[doc = "< SPI Control register 1,       Address offset: 0x00"]
    pub CR1: u32,
    #[doc = "< SPI Control register 2,       Address offset: 0x04"]
    pub CR2: u32,
    #[doc = "< SPI Status register,          Address offset: 0x08"]
    pub SR: u32,
    #[doc = "< SPI data register,            Address offset: 0x0C"]
    pub DR: u32,
    #[doc = "< SPI CRC polynomial register,  Address offset: 0x10"]
    pub CRCPR: u32,
    #[doc = "< SPI Rx CRC register,          Address offset: 0x14"]
    pub RXCRCR: u32,
    #[doc = "< SPI Tx CRC register,          Address offset: 0x18"]
    pub TXCRCR: u32,
}
#[test]
fn bindgen_test_layout_SPI_TypeDef() {
    const UNINIT: ::core::mem::MaybeUninit<SPI_TypeDef> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SPI_TypeDef>(),
        28usize,
        concat!("Size of: ", stringify!(SPI_TypeDef))
    );
    assert_eq!(
        ::core::mem::align_of::<SPI_TypeDef>(),
        4usize,
        concat!("Alignment of ", stringify!(SPI_TypeDef))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CR1) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SPI_TypeDef),
            "::",
            stringify!(CR1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CR2) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SPI_TypeDef),
            "::",
            stringify!(CR2)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).SR) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SPI_TypeDef),
            "::",
            stringify!(SR)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).DR) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(SPI_TypeDef),
            "::",
            stringify!(DR)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CRCPR) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SPI_TypeDef),
            "::",
            stringify!(CRCPR)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).RXCRCR) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(SPI_TypeDef),
            "::",
            stringify!(RXCRCR)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).TXCRCR) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(SPI_TypeDef),
            "::",
            stringify!(TXCRCR)
        )
    );
}
#[doc = " @brief TIM"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TIM_TypeDef {
    #[doc = "< TIM control register 1,                   Address offset: 0x00"]
    pub CR1: u32,
    #[doc = "< TIM control register 2,                   Address offset: 0x04"]
    pub CR2: u32,
    #[doc = "< TIM slave mode control register,          Address offset: 0x08"]
    pub SMCR: u32,
    #[doc = "< TIM DMA/interrupt enable register,        Address offset: 0x0C"]
    pub DIER: u32,
    #[doc = "< TIM status register,                      Address offset: 0x10"]
    pub SR: u32,
    #[doc = "< TIM event generation register,            Address offset: 0x14"]
    pub EGR: u32,
    #[doc = "< TIM capture/compare mode register 1,      Address offset: 0x18"]
    pub CCMR1: u32,
    #[doc = "< TIM capture/compare mode register 2,      Address offset: 0x1C"]
    pub CCMR2: u32,
    #[doc = "< TIM capture/compare enable register,      Address offset: 0x20"]
    pub CCER: u32,
    #[doc = "< TIM counter register,                     Address offset: 0x24"]
    pub CNT: u32,
    #[doc = "< TIM prescaler register,                   Address offset: 0x28"]
    pub PSC: u32,
    #[doc = "< TIM auto-reload register,                 Address offset: 0x2C"]
    pub ARR: u32,
    #[doc = "< TIM repetition counter register,          Address offset: 0x30"]
    pub RCR: u32,
    #[doc = "< TIM capture/compare register 1,           Address offset: 0x34"]
    pub CCR1: u32,
    #[doc = "< TIM capture/compare register 2,           Address offset: 0x38"]
    pub CCR2: u32,
    #[doc = "< TIM capture/compare register 3,           Address offset: 0x3C"]
    pub CCR3: u32,
    #[doc = "< TIM capture/compare register 4,           Address offset: 0x40"]
    pub CCR4: u32,
    #[doc = "< TIM break and dead-time register,         Address offset: 0x44"]
    pub BDTR: u32,
    #[doc = "< TIM DMA control register,                 Address offset: 0x48"]
    pub DCR: u32,
    #[doc = "< TIM DMA address for full transfer,        Address offset: 0x4C"]
    pub DMAR: u32,
    #[doc = "< TIM option register                       Address offset: 0x50"]
    pub OR: u32,
    #[doc = "< TIM capture/compare mode register 3,      Address offset: 0x54"]
    pub CCMR3: u32,
    #[doc = "< TIM capture/compare register5,            Address offset: 0x58"]
    pub CCR5: u32,
    #[doc = "< TIM capture/compare register6,            Address offset: 0x5C"]
    pub CCR6: u32,
    #[doc = "< TIM Alternate function option register 1, Address offset: 0x60"]
    pub AF1: u32,
    #[doc = "< TIM Alternate function option register 2, Address offset: 0x64"]
    pub AF2: u32,
}
#[test]
fn bindgen_test_layout_TIM_TypeDef() {
    const UNINIT: ::core::mem::MaybeUninit<TIM_TypeDef> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<TIM_TypeDef>(),
        104usize,
        concat!("Size of: ", stringify!(TIM_TypeDef))
    );
    assert_eq!(
        ::core::mem::align_of::<TIM_TypeDef>(),
        4usize,
        concat!("Alignment of ", stringify!(TIM_TypeDef))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CR1) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TIM_TypeDef),
            "::",
            stringify!(CR1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CR2) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(TIM_TypeDef),
            "::",
            stringify!(CR2)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).SMCR) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(TIM_TypeDef),
            "::",
            stringify!(SMCR)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).DIER) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(TIM_TypeDef),
            "::",
            stringify!(DIER)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).SR) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(TIM_TypeDef),
            "::",
            stringify!(SR)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).EGR) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(TIM_TypeDef),
            "::",
            stringify!(EGR)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CCMR1) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(TIM_TypeDef),
            "::",
            stringify!(CCMR1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CCMR2) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(TIM_TypeDef),
            "::",
            stringify!(CCMR2)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CCER) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(TIM_TypeDef),
            "::",
            stringify!(CCER)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CNT) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(TIM_TypeDef),
            "::",
            stringify!(CNT)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).PSC) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(TIM_TypeDef),
            "::",
            stringify!(PSC)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ARR) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(TIM_TypeDef),
            "::",
            stringify!(ARR)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).RCR) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(TIM_TypeDef),
            "::",
            stringify!(RCR)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CCR1) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(TIM_TypeDef),
            "::",
            stringify!(CCR1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CCR2) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(TIM_TypeDef),
            "::",
            stringify!(CCR2)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CCR3) as usize - ptr as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(TIM_TypeDef),
            "::",
            stringify!(CCR3)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CCR4) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(TIM_TypeDef),
            "::",
            stringify!(CCR4)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).BDTR) as usize - ptr as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(TIM_TypeDef),
            "::",
            stringify!(BDTR)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).DCR) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(TIM_TypeDef),
            "::",
            stringify!(DCR)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).DMAR) as usize - ptr as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(TIM_TypeDef),
            "::",
            stringify!(DMAR)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).OR) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(TIM_TypeDef),
            "::",
            stringify!(OR)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CCMR3) as usize - ptr as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(TIM_TypeDef),
            "::",
            stringify!(CCMR3)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CCR5) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(TIM_TypeDef),
            "::",
            stringify!(CCR5)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CCR6) as usize - ptr as usize },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(TIM_TypeDef),
            "::",
            stringify!(CCR6)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).AF1) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(TIM_TypeDef),
            "::",
            stringify!(AF1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).AF2) as usize - ptr as usize },
        100usize,
        concat!(
            "Offset of field: ",
            stringify!(TIM_TypeDef),
            "::",
            stringify!(AF2)
        )
    );
}
#[doc = " @brief Universal Synchronous Asynchronous Receiver Transmitter"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct USART_TypeDef {
    #[doc = "< USART Control register 1,                 Address offset: 0x00"]
    pub CR1: u32,
    #[doc = "< USART Control register 2,                 Address offset: 0x04"]
    pub CR2: u32,
    #[doc = "< USART Control register 3,                 Address offset: 0x08"]
    pub CR3: u32,
    #[doc = "< USART Baud rate register,                 Address offset: 0x0C"]
    pub BRR: u32,
    #[doc = "< USART Guard time and prescaler register,  Address offset: 0x10"]
    pub GTPR: u32,
    #[doc = "< USART Receiver Time Out register,         Address offset: 0x14"]
    pub RTOR: u32,
    #[doc = "< USART Request register,                   Address offset: 0x18"]
    pub RQR: u32,
    #[doc = "< USART Interrupt and status register,      Address offset: 0x1C"]
    pub ISR: u32,
    #[doc = "< USART Interrupt flag Clear register,      Address offset: 0x20"]
    pub ICR: u32,
    #[doc = "< USART Receive Data register,              Address offset: 0x24"]
    pub RDR: u32,
    #[doc = "< USART Transmit Data register,             Address offset: 0x28"]
    pub TDR: u32,
    #[doc = "< USART Prescaler register,                 Address offset: 0x2C"]
    pub PRESC: u32,
}
#[test]
fn bindgen_test_layout_USART_TypeDef() {
    const UNINIT: ::core::mem::MaybeUninit<USART_TypeDef> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<USART_TypeDef>(),
        48usize,
        concat!("Size of: ", stringify!(USART_TypeDef))
    );
    assert_eq!(
        ::core::mem::align_of::<USART_TypeDef>(),
        4usize,
        concat!("Alignment of ", stringify!(USART_TypeDef))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CR1) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(USART_TypeDef),
            "::",
            stringify!(CR1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CR2) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(USART_TypeDef),
            "::",
            stringify!(CR2)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CR3) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(USART_TypeDef),
            "::",
            stringify!(CR3)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).BRR) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(USART_TypeDef),
            "::",
            stringify!(BRR)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).GTPR) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(USART_TypeDef),
            "::",
            stringify!(GTPR)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).RTOR) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(USART_TypeDef),
            "::",
            stringify!(RTOR)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).RQR) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(USART_TypeDef),
            "::",
            stringify!(RQR)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ISR) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(USART_TypeDef),
            "::",
            stringify!(ISR)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ICR) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(USART_TypeDef),
            "::",
            stringify!(ICR)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).RDR) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(USART_TypeDef),
            "::",
            stringify!(RDR)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).TDR) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(USART_TypeDef),
            "::",
            stringify!(TDR)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).PRESC) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(USART_TypeDef),
            "::",
            stringify!(PRESC)
        )
    );
}
pub const ErrorStatus_SUCCESS: ErrorStatus = 0;
pub const ErrorStatus_ERROR: ErrorStatus = 1;
pub type ErrorStatus = core::ffi::c_uchar;
#[doc = " @brief LL GPIO Init Structure definition"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LL_GPIO_InitTypeDef {
    #[doc = "< Specifies the GPIO pins to be configured.\nThis parameter can be any value of @ref GPIO_LL_EC_PIN"]
    pub Pin: u32,
    #[doc = "< Specifies the operating mode for the selected pins.\nThis parameter can be a value of @ref GPIO_LL_EC_MODE.\n\nGPIO HW configuration can be modified afterwards using unitary function @ref LL_GPIO_SetPinMode()."]
    pub Mode: u32,
    #[doc = "< Specifies the speed for the selected pins.\nThis parameter can be a value of @ref GPIO_LL_EC_SPEED.\n\nGPIO HW configuration can be modified afterwards using unitary function @ref LL_GPIO_SetPinSpeed()."]
    pub Speed: u32,
    #[doc = "< Specifies the operating output type for the selected pins.\nThis parameter can be a value of @ref GPIO_LL_EC_OUTPUT.\n\nGPIO HW configuration can be modified afterwards using unitary function @ref LL_GPIO_SetPinOutputType()."]
    pub OutputType: u32,
    #[doc = "< Specifies the operating Pull-up/Pull down for the selected pins.\nThis parameter can be a value of @ref GPIO_LL_EC_PULL.\n\nGPIO HW configuration can be modified afterwards using unitary function @ref LL_GPIO_SetPinPull()."]
    pub Pull: u32,
    #[doc = "< Specifies the Peripheral to be connected to the selected pins.\nThis parameter can be a value of @ref GPIO_LL_EC_AF.\n\nGPIO HW configuration can be modified afterwards using unitary function @ref LL_GPIO_SetAFPin_0_7() and LL_GPIO_SetAFPin_8_15()."]
    pub Alternate: u32,
}
#[test]
fn bindgen_test_layout_LL_GPIO_InitTypeDef() {
    const UNINIT: ::core::mem::MaybeUninit<LL_GPIO_InitTypeDef> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<LL_GPIO_InitTypeDef>(),
        24usize,
        concat!("Size of: ", stringify!(LL_GPIO_InitTypeDef))
    );
    assert_eq!(
        ::core::mem::align_of::<LL_GPIO_InitTypeDef>(),
        4usize,
        concat!("Alignment of ", stringify!(LL_GPIO_InitTypeDef))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Pin) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(LL_GPIO_InitTypeDef),
            "::",
            stringify!(Pin)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Mode) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(LL_GPIO_InitTypeDef),
            "::",
            stringify!(Mode)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Speed) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(LL_GPIO_InitTypeDef),
            "::",
            stringify!(Speed)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).OutputType) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(LL_GPIO_InitTypeDef),
            "::",
            stringify!(OutputType)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Pull) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(LL_GPIO_InitTypeDef),
            "::",
            stringify!(Pull)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Alternate) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(LL_GPIO_InitTypeDef),
            "::",
            stringify!(Alternate)
        )
    );
}
extern "C" {
    pub fn LL_GPIO_Init(
        GPIOx: *mut GPIO_TypeDef,
        GPIO_InitStruct: *mut LL_GPIO_InitTypeDef,
    ) -> ErrorStatus;
}
#[doc = " Interrupt callback prototype"]
pub type GpioExtiCallback =
    ::core::option::Option<unsafe extern "C" fn(ctx: *mut core::ffi::c_void)>;
pub const GpioMode_GpioModeInput: GpioMode = 0;
pub const GpioMode_GpioModeOutputPushPull: GpioMode = 1;
pub const GpioMode_GpioModeOutputOpenDrain: GpioMode = 2;
pub const GpioMode_GpioModeAltFunctionPushPull: GpioMode = 3;
pub const GpioMode_GpioModeAltFunctionOpenDrain: GpioMode = 4;
pub const GpioMode_GpioModeAnalog: GpioMode = 5;
pub const GpioMode_GpioModeInterruptRise: GpioMode = 6;
pub const GpioMode_GpioModeInterruptFall: GpioMode = 7;
pub const GpioMode_GpioModeInterruptRiseFall: GpioMode = 8;
pub const GpioMode_GpioModeEventRise: GpioMode = 9;
pub const GpioMode_GpioModeEventFall: GpioMode = 10;
pub const GpioMode_GpioModeEventRiseFall: GpioMode = 11;
#[doc = " Gpio modes"]
pub type GpioMode = core::ffi::c_uchar;
pub const GpioPull_GpioPullNo: GpioPull = 0;
pub const GpioPull_GpioPullUp: GpioPull = 1;
pub const GpioPull_GpioPullDown: GpioPull = 2;
#[doc = " Gpio pull modes"]
pub type GpioPull = core::ffi::c_uchar;
pub const GpioSpeed_GpioSpeedLow: GpioSpeed = 0;
pub const GpioSpeed_GpioSpeedMedium: GpioSpeed = 1;
pub const GpioSpeed_GpioSpeedHigh: GpioSpeed = 2;
pub const GpioSpeed_GpioSpeedVeryHigh: GpioSpeed = 3;
#[doc = " Gpio speed modes"]
pub type GpioSpeed = core::ffi::c_uchar;
#[doc = "< MCO Alternate Function mapping"]
pub const GpioAltFn_GpioAltFn0MCO: GpioAltFn = 0;
#[doc = "< LSCO Alternate Function mapping"]
pub const GpioAltFn_GpioAltFn0LSCO: GpioAltFn = 0;
#[doc = "< JTMS-SWDIO Alternate Function mapping"]
pub const GpioAltFn_GpioAltFn0JTMS_SWDIO: GpioAltFn = 0;
#[doc = "< JTCK-SWCLK Alternate Function mapping"]
pub const GpioAltFn_GpioAltFn0JTCK_SWCLK: GpioAltFn = 0;
#[doc = "< JTDI Alternate Function mapping"]
pub const GpioAltFn_GpioAltFn0JTDI: GpioAltFn = 0;
#[doc = "< RCT_OUT Alternate Function mapping"]
pub const GpioAltFn_GpioAltFn0RTC_OUT: GpioAltFn = 0;
#[doc = "< JTDO-TRACESWO Alternate Function mapping"]
pub const GpioAltFn_GpioAltFn0JTD_TRACE: GpioAltFn = 0;
#[doc = "< NJTRST Alternate Function mapping"]
pub const GpioAltFn_GpioAltFn0NJTRST: GpioAltFn = 0;
#[doc = "< RTC_REFIN Alternate Function mapping"]
pub const GpioAltFn_GpioAltFn0RTC_REFIN: GpioAltFn = 0;
#[doc = "< TRACED0 Alternate Function mapping"]
pub const GpioAltFn_GpioAltFn0TRACED0: GpioAltFn = 0;
#[doc = "< TRACED1 Alternate Function mapping"]
pub const GpioAltFn_GpioAltFn0TRACED1: GpioAltFn = 0;
#[doc = "< TRACED2 Alternate Function mapping"]
pub const GpioAltFn_GpioAltFn0TRACED2: GpioAltFn = 0;
#[doc = "< TRACED3 Alternate Function mapping"]
pub const GpioAltFn_GpioAltFn0TRACED3: GpioAltFn = 0;
#[doc = "< TRIG_INOUT Alternate Function mapping"]
pub const GpioAltFn_GpioAltFn0TRIG_INOUT: GpioAltFn = 0;
#[doc = "< TRACECK Alternate Function mapping"]
pub const GpioAltFn_GpioAltFn0TRACECK: GpioAltFn = 0;
#[doc = "< System Function mapping"]
pub const GpioAltFn_GpioAltFn0SYS: GpioAltFn = 0;
#[doc = "< TIM1 Alternate Function mapping"]
pub const GpioAltFn_GpioAltFn1TIM1: GpioAltFn = 1;
#[doc = "< TIM2 Alternate Function mapping"]
pub const GpioAltFn_GpioAltFn1TIM2: GpioAltFn = 1;
#[doc = "< LPTIM1 Alternate Function mapping"]
pub const GpioAltFn_GpioAltFn1LPTIM1: GpioAltFn = 1;
#[doc = "< TIM2 Alternate Function mapping"]
pub const GpioAltFn_GpioAltFn2TIM2: GpioAltFn = 2;
#[doc = "< TIM1 Alternate Function mapping"]
pub const GpioAltFn_GpioAltFn2TIM1: GpioAltFn = 2;
#[doc = "< SAI1_CK1 Alternate Function mapping"]
pub const GpioAltFn_GpioAltFn3SAI1: GpioAltFn = 3;
#[doc = "< SPI2 Alternate Function mapping"]
pub const GpioAltFn_GpioAltFn3SPI2: GpioAltFn = 3;
#[doc = "< TIM1 Alternate Function mapping"]
pub const GpioAltFn_GpioAltFn3TIM1: GpioAltFn = 3;
#[doc = "< I2C1 Alternate Function mapping"]
pub const GpioAltFn_GpioAltFn4I2C1: GpioAltFn = 4;
#[doc = "< I2C3 Alternate Function mapping"]
pub const GpioAltFn_GpioAltFn4I2C3: GpioAltFn = 4;
#[doc = "< SPI1 Alternate Function mapping"]
pub const GpioAltFn_GpioAltFn5SPI1: GpioAltFn = 5;
#[doc = "< SPI2 Alternate Function mapping"]
pub const GpioAltFn_GpioAltFn5SPI2: GpioAltFn = 5;
#[doc = "< MCO Alternate Function mapping"]
pub const GpioAltFn_GpioAltFn6MCO: GpioAltFn = 6;
#[doc = "< LSCO Alternate Function mapping"]
pub const GpioAltFn_GpioAltFn6LSCO: GpioAltFn = 6;
#[doc = "< RF_DTB0 Alternate Function mapping"]
pub const GpioAltFn_GpioAltFn6RF_DTB0: GpioAltFn = 6;
#[doc = "< RF_DTB1 Alternate Function mapping"]
pub const GpioAltFn_GpioAltFn6RF_DTB1: GpioAltFn = 6;
#[doc = "< RF_DTB2 Alternate Function mapping"]
pub const GpioAltFn_GpioAltFn6RF_DTB2: GpioAltFn = 6;
#[doc = "< RF_DTB3 Alternate Function mapping"]
pub const GpioAltFn_GpioAltFn6RF_DTB3: GpioAltFn = 6;
#[doc = "< RF_DTB4 Alternate Function mapping"]
pub const GpioAltFn_GpioAltFn6RF_DTB4: GpioAltFn = 6;
#[doc = "< RF_DTB5 Alternate Function mapping"]
pub const GpioAltFn_GpioAltFn6RF_DTB5: GpioAltFn = 6;
#[doc = "< RF_DTB6 Alternate Function mapping"]
pub const GpioAltFn_GpioAltFn6RF_DTB6: GpioAltFn = 6;
#[doc = "< RF_DTB7 Alternate Function mapping"]
pub const GpioAltFn_GpioAltFn6RF_DTB7: GpioAltFn = 6;
#[doc = "< RF_DTB8 Alternate Function mapping"]
pub const GpioAltFn_GpioAltFn6RF_DTB8: GpioAltFn = 6;
#[doc = "< RF_DTB9 Alternate Function mapping"]
pub const GpioAltFn_GpioAltFn6RF_DTB9: GpioAltFn = 6;
#[doc = "< RF_DTB10 Alternate Function mapping"]
pub const GpioAltFn_GpioAltFn6RF_DTB10: GpioAltFn = 6;
#[doc = "< RF_DTB11 Alternate Function mapping"]
pub const GpioAltFn_GpioAltFn6RF_DTB11: GpioAltFn = 6;
#[doc = "< RF_DTB12 Alternate Function mapping"]
pub const GpioAltFn_GpioAltFn6RF_DTB12: GpioAltFn = 6;
#[doc = "< RF_DTB13 Alternate Function mapping"]
pub const GpioAltFn_GpioAltFn6RF_DTB13: GpioAltFn = 6;
#[doc = "< RF_DTB14 Alternate Function mapping"]
pub const GpioAltFn_GpioAltFn6RF_DTB14: GpioAltFn = 6;
#[doc = "< RF_DTB15 Alternate Function mapping"]
pub const GpioAltFn_GpioAltFn6RF_DTB15: GpioAltFn = 6;
#[doc = "< RF_DTB16 Alternate Function mapping"]
pub const GpioAltFn_GpioAltFn6RF_DTB16: GpioAltFn = 6;
#[doc = "< RF_DTB17 Alternate Function mapping"]
pub const GpioAltFn_GpioAltFn6RF_DTB17: GpioAltFn = 6;
#[doc = "< RF_DTB18 Alternate Function mapping"]
pub const GpioAltFn_GpioAltFn6RF_DTB18: GpioAltFn = 6;
#[doc = "< RF_MISO Alternate Function mapping"]
pub const GpioAltFn_GpioAltFn6RF_MISO: GpioAltFn = 6;
#[doc = "< RF_MOSI Alternate Function mapping"]
pub const GpioAltFn_GpioAltFn6RF_MOSI: GpioAltFn = 6;
#[doc = "< RF_SCK Alternate Function mapping"]
pub const GpioAltFn_GpioAltFn6RF_SCK: GpioAltFn = 6;
#[doc = "< RF_NSS Alternate Function mapping"]
pub const GpioAltFn_GpioAltFn6RF_NSS: GpioAltFn = 6;
#[doc = "< USART1 Alternate Function mapping"]
pub const GpioAltFn_GpioAltFn7USART1: GpioAltFn = 7;
#[doc = "< LPUART1 Alternate Function mapping"]
pub const GpioAltFn_GpioAltFn8LPUART1: GpioAltFn = 8;
#[doc = "< IR Alternate Function mapping"]
pub const GpioAltFn_GpioAltFn8IR: GpioAltFn = 8;
#[doc = "< TSC Alternate Function mapping"]
pub const GpioAltFn_GpioAltFn9TSC: GpioAltFn = 9;
#[doc = "< QUADSPI Alternate Function mapping"]
pub const GpioAltFn_GpioAltFn10QUADSPI: GpioAltFn = 10;
#[doc = "< USB Alternate Function mapping"]
pub const GpioAltFn_GpioAltFn10USB: GpioAltFn = 10;
#[doc = "< LCD Alternate Function mapping"]
pub const GpioAltFn_GpioAltFn11LCD: GpioAltFn = 11;
#[doc = "< COMP1 Alternate Function mapping"]
pub const GpioAltFn_GpioAltFn12COMP1: GpioAltFn = 12;
#[doc = "< COMP2 Alternate Function mapping"]
pub const GpioAltFn_GpioAltFn12COMP2: GpioAltFn = 12;
#[doc = "< TIM1 Alternate Function mapping"]
pub const GpioAltFn_GpioAltFn12TIM1: GpioAltFn = 12;
#[doc = "< SAI1 Alternate Function mapping"]
pub const GpioAltFn_GpioAltFn13SAI1: GpioAltFn = 13;
#[doc = "< TIM2 Alternate Function mapping"]
pub const GpioAltFn_GpioAltFn14TIM2: GpioAltFn = 14;
#[doc = "< TIM16 Alternate Function mapping"]
pub const GpioAltFn_GpioAltFn14TIM16: GpioAltFn = 14;
#[doc = "< TIM17 Alternate Function mapping"]
pub const GpioAltFn_GpioAltFn14TIM17: GpioAltFn = 14;
#[doc = "< LPTIM2 Alternate Function mapping"]
pub const GpioAltFn_GpioAltFn14LPTIM2: GpioAltFn = 14;
#[doc = "< EVENTOUT Alternate Function mapping"]
pub const GpioAltFn_GpioAltFn15EVENTOUT: GpioAltFn = 15;
#[doc = "< just dummy value"]
pub const GpioAltFn_GpioAltFnUnused: GpioAltFn = 16;
#[doc = " Gpio alternate functions"]
pub type GpioAltFn = core::ffi::c_uchar;
#[doc = " Gpio structure"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GpioPin {
    pub port: *mut GPIO_TypeDef,
    pub pin: u16,
}
#[test]
fn bindgen_test_layout_GpioPin() {
    const UNINIT: ::core::mem::MaybeUninit<GpioPin> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<GpioPin>(),
        8usize,
        concat!("Size of: ", stringify!(GpioPin))
    );
    assert_eq!(
        ::core::mem::align_of::<GpioPin>(),
        4usize,
        concat!("Alignment of ", stringify!(GpioPin))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).port) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GpioPin),
            "::",
            stringify!(port)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pin) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(GpioPin),
            "::",
            stringify!(pin)
        )
    );
}
extern "C" {
    #[doc = " GPIO initialization function, simple version\n @param gpio  GpioPin\n @param mode  GpioMode"]
    pub fn furi_hal_gpio_init_simple(gpio: *const GpioPin, mode: GpioMode);
}
extern "C" {
    #[doc = " GPIO initialization function, normal version\n @param gpio  GpioPin\n @param mode  GpioMode\n @param pull  GpioPull\n @param speed GpioSpeed"]
    pub fn furi_hal_gpio_init(
        gpio: *const GpioPin,
        mode: GpioMode,
        pull: GpioPull,
        speed: GpioSpeed,
    );
}
extern "C" {
    #[doc = " GPIO initialization function, extended version\n @param gpio  GpioPin\n @param mode  GpioMode\n @param pull  GpioPull\n @param speed GpioSpeed\n @param alt_fn GpioAltFn"]
    pub fn furi_hal_gpio_init_ex(
        gpio: *const GpioPin,
        mode: GpioMode,
        pull: GpioPull,
        speed: GpioSpeed,
        alt_fn: GpioAltFn,
    );
}
extern "C" {
    #[doc = " Add and enable interrupt\n @param gpio GpioPin\n @param cb   GpioExtiCallback\n @param ctx  context for callback"]
    pub fn furi_hal_gpio_add_int_callback(
        gpio: *const GpioPin,
        cb: GpioExtiCallback,
        ctx: *mut core::ffi::c_void,
    );
}
extern "C" {
    #[doc = " Enable interrupt\n @param gpio GpioPin"]
    pub fn furi_hal_gpio_enable_int_callback(gpio: *const GpioPin);
}
extern "C" {
    #[doc = " Disable interrupt\n @param gpio GpioPin"]
    pub fn furi_hal_gpio_disable_int_callback(gpio: *const GpioPin);
}
extern "C" {
    #[doc = " Remove interrupt\n @param gpio GpioPin"]
    pub fn furi_hal_gpio_remove_int_callback(gpio: *const GpioPin);
}
extern "C" {
    pub fn furi_run();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Bt {
    _unused: [u8; 0],
}
pub const BtStatus_BtStatusUnavailable: BtStatus = 0;
pub const BtStatus_BtStatusOff: BtStatus = 1;
pub const BtStatus_BtStatusAdvertising: BtStatus = 2;
pub const BtStatus_BtStatusConnected: BtStatus = 3;
pub type BtStatus = core::ffi::c_uchar;
pub const BtProfile_BtProfileSerial: BtProfile = 0;
pub const BtProfile_BtProfileHidKeyboard: BtProfile = 1;
pub type BtProfile = core::ffi::c_uchar;
pub type BtStatusChangedCallback =
    ::core::option::Option<unsafe extern "C" fn(status: BtStatus, context: *mut core::ffi::c_void)>;
extern "C" {
    #[doc = " Change BLE Profile\n @note Call of this function leads to 2nd core restart\n\n @param bt        Bt instance\n @param profile   BtProfile\n\n @return          true on success"]
    pub fn bt_set_profile(bt: *mut Bt, profile: BtProfile) -> bool;
}
extern "C" {
    #[doc = " Disconnect from Central\n\n @param bt        Bt instance"]
    pub fn bt_disconnect(bt: *mut Bt);
}
extern "C" {
    #[doc = " Set callback for Bluetooth status change notification\n\n @param bt        Bt instance\n @param callback  BtStatusChangedCallback instance\n @param context   pointer to context"]
    pub fn bt_set_status_changed_callback(
        bt: *mut Bt,
        callback: BtStatusChangedCallback,
        context: *mut core::ffi::c_void,
    );
}
extern "C" {
    #[doc = " Forget bonded devices\n @note Leads to wipe ble key storage and deleting bt.keys\n\n @param bt        Bt instance"]
    pub fn bt_forget_bonded_devices(bt: *mut Bt);
}
extern "C" {
    #[doc = " Set keys storage file path\n\n @param bt                    Bt instance\n @param keys_storage_path     Path to file with saved keys"]
    pub fn bt_keys_storage_set_storage_path(
        bt: *mut Bt,
        keys_storage_path: *const core::ffi::c_char,
    );
}
extern "C" {
    #[doc = " Set default keys storage file path\n\n @param bt                    Bt instance"]
    pub fn bt_keys_storage_set_default_path(bt: *mut Bt);
}
#[doc = "< Default, loader lock is used"]
pub const CliCommandFlag_CliCommandFlagDefault: CliCommandFlag = 0;
pub const CliCommandFlag_CliCommandFlagParallelSafe: CliCommandFlag = 1;
#[doc = "< Safe to run with insomnia mode on"]
pub const CliCommandFlag_CliCommandFlagInsomniaSafe: CliCommandFlag = 2;
pub type CliCommandFlag = core::ffi::c_uchar;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Cli {
    _unused: [u8; 0],
}
#[doc = " Cli callback function pointer. Implement this interface and use\n add_cli_command\n @param      args     string with what was passed after command\n @param      context  pointer to whatever you gave us on cli_add_command"]
pub type CliCallback = ::core::option::Option<
    unsafe extern "C" fn(cli: *mut Cli, args: *mut FuriString, context: *mut core::ffi::c_void),
>;
extern "C" {
    #[doc = " Add cli command Registers you command callback\n\n @param      cli       pointer to cli instance\n @param      name      command name\n @param      flags     CliCommandFlag\n @param      callback  callback function\n @param      context   pointer to whatever we need to pass to callback"]
    pub fn cli_add_command(
        cli: *mut Cli,
        name: *const core::ffi::c_char,
        flags: CliCommandFlag,
        callback: CliCallback,
        context: *mut core::ffi::c_void,
    );
}
extern "C" {
    #[doc = " Print unified cmd usage tip\n\n @param      cmd    cmd name\n @param      usage  usage tip\n @param      arg    arg passed by user"]
    pub fn cli_print_usage(
        cmd: *const core::ffi::c_char,
        usage: *const core::ffi::c_char,
        arg: *const core::ffi::c_char,
    );
}
extern "C" {
    #[doc = " Delete cli command\n\n @param      cli   pointer to cli instance\n @param      name  command name"]
    pub fn cli_delete_command(cli: *mut Cli, name: *const core::ffi::c_char);
}
extern "C" {
    #[doc = " Read from terminal\n\n @param      cli     Cli instance\n @param      buffer  pointer to buffer\n @param      size    size of buffer in bytes\n\n @return     bytes read"]
    pub fn cli_read(cli: *mut Cli, buffer: *mut u8, size: usize) -> usize;
}
extern "C" {
    #[doc = " Non-blocking read from terminal\n\n @param      cli     Cli instance\n @param      buffer  pointer to buffer\n @param      size    size of buffer in bytes\n @param      timeout timeout value in ms\n\n @return     bytes read"]
    pub fn cli_read_timeout(cli: *mut Cli, buffer: *mut u8, size: usize, timeout: u32) -> usize;
}
extern "C" {
    #[doc = " Non-blocking check for interrupt command received\n\n @param      cli   Cli instance\n\n @return     true if received"]
    pub fn cli_cmd_interrupt_received(cli: *mut Cli) -> bool;
}
extern "C" {
    #[doc = " Write to terminal Do it only from inside of cli call.\n\n @param      cli     Cli instance\n @param      buffer  pointer to buffer\n @param      size    size of buffer in bytes"]
    pub fn cli_write(cli: *mut Cli, buffer: *const u8, size: usize);
}
extern "C" {
    #[doc = " Read character\n\n @param      cli   Cli instance\n\n @return     char"]
    pub fn cli_getc(cli: *mut Cli) -> core::ffi::c_char;
}
extern "C" {
    #[doc = " New line Send new ine sequence"]
    pub fn cli_nl();
}
extern "C" {
    pub fn cli_session_open(cli: *mut Cli, session: *mut core::ffi::c_void);
}
extern "C" {
    pub fn cli_session_close(cli: *mut Cli);
}
extern "C" {
    pub fn cli_is_connected(cli: *mut Cli) -> bool;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CliSession {
    _unused: [u8; 0],
}
extern "C" {
    pub static mut cli_vcp: CliSession;
}
extern "C" {
    #[doc = " Get icon width\n\n @param[in]  instance  pointer to Icon data\n\n @return     width in pixels"]
    pub fn icon_get_width(instance: *const Icon) -> u8;
}
extern "C" {
    #[doc = " Get icon height\n\n @param[in]  instance  pointer to Icon data\n\n @return     height in pixels"]
    pub fn icon_get_height(instance: *const Icon) -> u8;
}
extern "C" {
    #[doc = " Get Icon XBM bitmap data\n\n @param[in]  instance  pointer to Icon data\n\n @return     pointer to XBM bitmap data"]
    pub fn icon_get_data(instance: *const Icon) -> *const u8;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IconAnimation {
    _unused: [u8; 0],
}
#[doc = " Icon Animation Callback. Used for update notification"]
pub type IconAnimationCallback = ::core::option::Option<
    unsafe extern "C" fn(instance: *mut IconAnimation, context: *mut core::ffi::c_void),
>;
extern "C" {
    #[doc = " Allocate icon animation instance with const icon data.\n\n always returns Icon or stops system if not enough memory\n\n @param[in]  icon  pointer to Icon data\n\n @return     IconAnimation instance"]
    pub fn icon_animation_alloc(icon: *const Icon) -> *mut IconAnimation;
}
extern "C" {
    #[doc = " Release icon animation instance\n\n @param      instance  IconAnimation instance"]
    pub fn icon_animation_free(instance: *mut IconAnimation);
}
extern "C" {
    #[doc = " Set IconAnimation update callback\n\n Normally you do not need to use this function, use view_tie_icon_animation\n instead.\n\n @param      instance  IconAnimation instance\n @param[in]  callback  IconAnimationCallback\n @param      context   callback context"]
    pub fn icon_animation_set_update_callback(
        instance: *mut IconAnimation,
        callback: IconAnimationCallback,
        context: *mut core::ffi::c_void,
    );
}
extern "C" {
    #[doc = " Get icon animation width\n\n @param      instance  IconAnimation instance\n\n @return     width in pixels"]
    pub fn icon_animation_get_width(instance: *const IconAnimation) -> u8;
}
extern "C" {
    #[doc = " Get icon animation height\n\n @param      instance  IconAnimation instance\n\n @return     height in pixels"]
    pub fn icon_animation_get_height(instance: *const IconAnimation) -> u8;
}
extern "C" {
    #[doc = " Start icon animation\n\n @param      instance  IconAnimation instance"]
    pub fn icon_animation_start(instance: *mut IconAnimation);
}
extern "C" {
    #[doc = " Stop icon animation\n\n @param      instance  IconAnimation instance"]
    pub fn icon_animation_stop(instance: *mut IconAnimation);
}
extern "C" {
    #[doc = " Returns true if current frame is a last one\n\n @param      instance  IconAnimation instance\n\n @return     true if last frame"]
    pub fn icon_animation_is_last_frame(instance: *const IconAnimation) -> bool;
}
pub const Color_ColorWhite: Color = 0;
pub const Color_ColorBlack: Color = 1;
pub const Color_ColorXOR: Color = 2;
#[doc = " Color enumeration"]
pub type Color = core::ffi::c_uchar;
pub const Font_FontPrimary: Font = 0;
pub const Font_FontSecondary: Font = 1;
pub const Font_FontKeyboard: Font = 2;
pub const Font_FontBigNumbers: Font = 3;
pub const Font_FontTotalNumber: Font = 4;
#[doc = " Fonts enumeration"]
pub type Font = core::ffi::c_uchar;
pub const Align_AlignLeft: Align = 0;
pub const Align_AlignRight: Align = 1;
pub const Align_AlignTop: Align = 2;
pub const Align_AlignBottom: Align = 3;
pub const Align_AlignCenter: Align = 4;
#[doc = " Alignment enumeration"]
pub type Align = core::ffi::c_uchar;
pub const CanvasDirection_CanvasDirectionLeftToRight: CanvasDirection = 0;
pub const CanvasDirection_CanvasDirectionTopToBottom: CanvasDirection = 1;
pub const CanvasDirection_CanvasDirectionRightToLeft: CanvasDirection = 2;
pub const CanvasDirection_CanvasDirectionBottomToTop: CanvasDirection = 3;
#[doc = " Font Direction"]
pub type CanvasDirection = core::ffi::c_uchar;
#[doc = " Font parameters"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CanvasFontParameters {
    pub leading_default: u8,
    pub leading_min: u8,
    pub height: u8,
    pub descender: u8,
}
#[test]
fn bindgen_test_layout_CanvasFontParameters() {
    const UNINIT: ::core::mem::MaybeUninit<CanvasFontParameters> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<CanvasFontParameters>(),
        4usize,
        concat!("Size of: ", stringify!(CanvasFontParameters))
    );
    assert_eq!(
        ::core::mem::align_of::<CanvasFontParameters>(),
        1usize,
        concat!("Alignment of ", stringify!(CanvasFontParameters))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).leading_default) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CanvasFontParameters),
            "::",
            stringify!(leading_default)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).leading_min) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(CanvasFontParameters),
            "::",
            stringify!(leading_min)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).height) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(CanvasFontParameters),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).descender) as usize - ptr as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(CanvasFontParameters),
            "::",
            stringify!(descender)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Canvas {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " Reset canvas drawing tools configuration\n\n @param      canvas  Canvas instance"]
    pub fn canvas_reset(canvas: *mut Canvas);
}
extern "C" {
    #[doc = " Commit canvas. Send buffer to display\n\n @param      canvas  Canvas instance"]
    pub fn canvas_commit(canvas: *mut Canvas);
}
extern "C" {
    #[doc = " Get Canvas width\n\n @param      canvas  Canvas instance\n\n @return     width in pixels."]
    pub fn canvas_width(canvas: *const Canvas) -> u8;
}
extern "C" {
    #[doc = " Get Canvas height\n\n @param      canvas  Canvas instance\n\n @return     height in pixels."]
    pub fn canvas_height(canvas: *const Canvas) -> u8;
}
extern "C" {
    #[doc = " Get current font height\n\n @param      canvas  Canvas instance\n\n @return     height in pixels."]
    pub fn canvas_current_font_height(canvas: *const Canvas) -> u8;
}
extern "C" {
    #[doc = " Get font parameters\n\n @param      canvas  Canvas instance\n @param      font    Font\n\n @return     pointer to CanvasFontParameters structure"]
    pub fn canvas_get_font_params(canvas: *const Canvas, font: Font)
        -> *const CanvasFontParameters;
}
extern "C" {
    #[doc = " Clear canvas\n\n @param      canvas  Canvas instance"]
    pub fn canvas_clear(canvas: *mut Canvas);
}
extern "C" {
    #[doc = " Set drawing color\n\n @param      canvas  Canvas instance\n @param      color   Color"]
    pub fn canvas_set_color(canvas: *mut Canvas, color: Color);
}
extern "C" {
    #[doc = " Set font swap\n Argument String Rotation Description\n\n @param      canvas  Canvas instance\n @param      dir     Direction font"]
    pub fn canvas_set_font_direction(canvas: *mut Canvas, dir: CanvasDirection);
}
extern "C" {
    #[doc = " Invert drawing color\n\n @param      canvas  Canvas instance"]
    pub fn canvas_invert_color(canvas: *mut Canvas);
}
extern "C" {
    #[doc = " Set drawing font\n\n @param      canvas  Canvas instance\n @param      font    Font"]
    pub fn canvas_set_font(canvas: *mut Canvas, font: Font);
}
extern "C" {
    #[doc = " Set custom drawing font\n\n @param      canvas  Canvas instance\n @param      font    Pointer to u8g2 const uint8_t* font array"]
    pub fn canvas_set_custom_u8g2_font(canvas: *mut Canvas, font: *const u8);
}
extern "C" {
    #[doc = " Draw string at position of baseline defined by x, y.\n\n @param      canvas  Canvas instance\n @param      x       anchor point x coordinate\n @param      y       anchor point y coordinate\n @param      str     C-string"]
    pub fn canvas_draw_str(canvas: *mut Canvas, x: u8, y: u8, str_: *const core::ffi::c_char);
}
extern "C" {
    #[doc = " Draw aligned string defined by x, y.\n\n Align calculated from position of baseline, string width and ascent (height\n of the glyphs above the baseline)\n\n @param      canvas      Canvas instance\n @param      x           anchor point x coordinate\n @param      y           anchor point y coordinate\n @param      horizontal  horizontal alignment\n @param      vertical    vertical alignment\n @param      str         C-string"]
    pub fn canvas_draw_str_aligned(
        canvas: *mut Canvas,
        x: u8,
        y: u8,
        horizontal: Align,
        vertical: Align,
        str_: *const core::ffi::c_char,
    );
}
extern "C" {
    #[doc = " Get string width\n\n @param      canvas  Canvas instance\n @param      str     C-string\n\n @return     width in pixels."]
    pub fn canvas_string_width(canvas: *mut Canvas, str_: *const core::ffi::c_char) -> u16;
}
extern "C" {
    #[doc = " Get glyph width\n\n @param      canvas  Canvas instance\n @param[in]  symbol  character\n\n @return     width in pixels"]
    pub fn canvas_glyph_width(canvas: *mut Canvas, symbol: core::ffi::c_char) -> u8;
}
extern "C" {
    #[doc = " Draw bitmap picture at position defined by x,y.\n\n @param      canvas                   Canvas instance\n @param      x                        x coordinate\n @param      y                        y coordinate\n @param      width                    width of bitmap\n @param      height                   height of bitmap\n @param      compressed_bitmap_data   compressed bitmap data"]
    pub fn canvas_draw_bitmap(
        canvas: *mut Canvas,
        x: u8,
        y: u8,
        width: u8,
        height: u8,
        compressed_bitmap_data: *const u8,
    );
}
extern "C" {
    #[doc = " Draw animation at position defined by x,y.\n\n @param      canvas          Canvas instance\n @param      x               x coordinate\n @param      y               y coordinate\n @param      icon_animation  IconAnimation instance"]
    pub fn canvas_draw_icon_animation(
        canvas: *mut Canvas,
        x: u8,
        y: u8,
        icon_animation: *mut IconAnimation,
    );
}
extern "C" {
    #[doc = " Draw icon at position defined by x,y.\n\n @param      canvas  Canvas instance\n @param      x       x coordinate\n @param      y       y coordinate\n @param      icon    Icon instance"]
    pub fn canvas_draw_icon(canvas: *mut Canvas, x: u8, y: u8, icon: *const Icon);
}
extern "C" {
    #[doc = " Draw XBM bitmap\n\n @param      canvas  Canvas instance\n @param      x       x coordinate\n @param      y       y coordinate\n @param      w       bitmap width\n @param      h       bitmap height\n @param      bitmap  pointer to XBM bitmap data"]
    pub fn canvas_draw_xbm(canvas: *mut Canvas, x: u8, y: u8, w: u8, h: u8, bitmap: *const u8);
}
extern "C" {
    #[doc = " Draw dot at x,y\n\n @param      canvas  Canvas instance\n @param      x       x coordinate\n @param      y       y coordinate"]
    pub fn canvas_draw_dot(canvas: *mut Canvas, x: u8, y: u8);
}
extern "C" {
    #[doc = " Draw box of width, height at x,y\n\n @param      canvas  Canvas instance\n @param      x       x coordinate\n @param      y       y coordinate\n @param      width   box width\n @param      height  box height"]
    pub fn canvas_draw_box(canvas: *mut Canvas, x: u8, y: u8, width: u8, height: u8);
}
extern "C" {
    #[doc = " Draw frame of width, height at x,y\n\n @param      canvas  Canvas instance\n @param      x       x coordinate\n @param      y       y coordinate\n @param      width   frame width\n @param      height  frame height"]
    pub fn canvas_draw_frame(canvas: *mut Canvas, x: u8, y: u8, width: u8, height: u8);
}
extern "C" {
    #[doc = " Draw line from x1,y1 to x2,y2\n\n @param      canvas  Canvas instance\n @param      x1      x1 coordinate\n @param      y1      y1 coordinate\n @param      x2      x2 coordinate\n @param      y2      y2 coordinate"]
    pub fn canvas_draw_line(canvas: *mut Canvas, x1: u8, y1: u8, x2: u8, y2: u8);
}
extern "C" {
    #[doc = " Draw circle at x,y with radius r\n\n @param      canvas  Canvas instance\n @param      x       x coordinate\n @param      y       y coordinate\n @param      r       radius"]
    pub fn canvas_draw_circle(canvas: *mut Canvas, x: u8, y: u8, r: u8);
}
extern "C" {
    #[doc = " Draw disc at x,y with radius r\n\n @param      canvas  Canvas instance\n @param      x       x coordinate\n @param      y       y coordinate\n @param      r       radius"]
    pub fn canvas_draw_disc(canvas: *mut Canvas, x: u8, y: u8, r: u8);
}
extern "C" {
    #[doc = " Draw triangle with given base and height lengths and their intersection coordinate\n\n @param       canvas  Canvas instance\n @param       x       x coordinate of base and height intersection\n @param       y       y coordinate of base and height intersection\n @param       base    length of triangle side\n @param       height  length of triangle height\n @param       dir     CanvasDirection triangle orientation"]
    pub fn canvas_draw_triangle(
        canvas: *mut Canvas,
        x: u8,
        y: u8,
        base: u8,
        height: u8,
        dir: CanvasDirection,
    );
}
extern "C" {
    #[doc = " Draw glyph\n\n @param      canvas  Canvas instance\n @param      x       x coordinate\n @param      y       y coordinate\n @param      ch      character"]
    pub fn canvas_draw_glyph(canvas: *mut Canvas, x: u8, y: u8, ch: u16);
}
extern "C" {
    #[doc = " Set transparency mode\n\n @param      canvas  Canvas instance\n @param      alpha   transparency mode"]
    pub fn canvas_set_bitmap_mode(canvas: *mut Canvas, alpha: bool);
}
extern "C" {
    #[doc = " Draw rounded-corner frame of width, height at x,y, with round value radius\n\n @param      canvas  Canvas instance\n @param      x       x coordinate\n @param      y       y coordinate\n @param      width   frame width\n @param      height  frame height\n @param      radius  frame corner radius"]
    pub fn canvas_draw_rframe(canvas: *mut Canvas, x: u8, y: u8, width: u8, height: u8, radius: u8);
}
extern "C" {
    #[doc = " Draw rounded-corner box of width, height at x,y, with round value raduis\n\n @param      canvas  Canvas instance\n @param      x       x coordinate\n @param      y       y coordinate\n @param      width   box width\n @param      height  box height\n @param      radius  box corner radius"]
    pub fn canvas_draw_rbox(canvas: *mut Canvas, x: u8, y: u8, width: u8, height: u8, radius: u8);
}
pub const InputKey_InputKeyUp: InputKey = 0;
pub const InputKey_InputKeyDown: InputKey = 1;
pub const InputKey_InputKeyRight: InputKey = 2;
pub const InputKey_InputKeyLeft: InputKey = 3;
pub const InputKey_InputKeyOk: InputKey = 4;
pub const InputKey_InputKeyBack: InputKey = 5;
#[doc = "< Special value"]
pub const InputKey_InputKeyMAX: InputKey = 6;
pub type InputKey = core::ffi::c_uchar;
pub const Light_LightRed: Light = 1;
pub const Light_LightGreen: Light = 2;
pub const Light_LightBlue: Light = 4;
pub const Light_LightBacklight: Light = 8;
pub type Light = core::ffi::c_uchar;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct InputPin {
    pub gpio: *const GpioPin,
    pub key: InputKey,
    pub inverted: bool,
    pub name: *const core::ffi::c_char,
}
#[test]
fn bindgen_test_layout_InputPin() {
    const UNINIT: ::core::mem::MaybeUninit<InputPin> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<InputPin>(),
        12usize,
        concat!("Size of: ", stringify!(InputPin))
    );
    assert_eq!(
        ::core::mem::align_of::<InputPin>(),
        4usize,
        concat!("Alignment of ", stringify!(InputPin))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).gpio) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(InputPin),
            "::",
            stringify!(gpio)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).key) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(InputPin),
            "::",
            stringify!(key)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).inverted) as usize - ptr as usize },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(InputPin),
            "::",
            stringify!(inverted)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(InputPin),
            "::",
            stringify!(name)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GpioPinRecord {
    pub pin: *const GpioPin,
    pub name: *const core::ffi::c_char,
    pub debug: bool,
}
#[test]
fn bindgen_test_layout_GpioPinRecord() {
    const UNINIT: ::core::mem::MaybeUninit<GpioPinRecord> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<GpioPinRecord>(),
        12usize,
        concat!("Size of: ", stringify!(GpioPinRecord))
    );
    assert_eq!(
        ::core::mem::align_of::<GpioPinRecord>(),
        4usize,
        concat!("Alignment of ", stringify!(GpioPinRecord))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pin) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GpioPinRecord),
            "::",
            stringify!(pin)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(GpioPinRecord),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).debug) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(GpioPinRecord),
            "::",
            stringify!(debug)
        )
    );
}
extern "C" {
    pub static input_pins: [InputPin; 0usize];
}
extern "C" {
    pub static input_pins_count: usize;
}
extern "C" {
    pub static gpio_pins: [GpioPinRecord; 0usize];
}
extern "C" {
    pub static gpio_pins_count: usize;
}
extern "C" {
    pub static vibro_gpio: GpioPin;
}
extern "C" {
    pub static ibutton_gpio: GpioPin;
}
extern "C" {
    pub static gpio_cc1101_g0: GpioPin;
}
extern "C" {
    pub static gpio_rf_sw_0: GpioPin;
}
extern "C" {
    pub static gpio_subghz_cs: GpioPin;
}
extern "C" {
    pub static gpio_display_cs: GpioPin;
}
extern "C" {
    pub static gpio_display_rst_n: GpioPin;
}
extern "C" {
    pub static gpio_display_di: GpioPin;
}
extern "C" {
    pub static gpio_sdcard_cs: GpioPin;
}
extern "C" {
    pub static gpio_sdcard_cd: GpioPin;
}
extern "C" {
    pub static gpio_nfc_cs: GpioPin;
}
extern "C" {
    pub static gpio_button_up: GpioPin;
}
extern "C" {
    pub static gpio_button_down: GpioPin;
}
extern "C" {
    pub static gpio_button_right: GpioPin;
}
extern "C" {
    pub static gpio_button_left: GpioPin;
}
extern "C" {
    pub static gpio_button_ok: GpioPin;
}
extern "C" {
    pub static gpio_button_back: GpioPin;
}
extern "C" {
    pub static gpio_spi_d_miso: GpioPin;
}
extern "C" {
    pub static gpio_spi_d_mosi: GpioPin;
}
extern "C" {
    pub static gpio_spi_d_sck: GpioPin;
}
extern "C" {
    pub static gpio_spi_r_miso: GpioPin;
}
extern "C" {
    pub static gpio_spi_r_mosi: GpioPin;
}
extern "C" {
    pub static gpio_spi_r_sck: GpioPin;
}
extern "C" {
    pub static gpio_ext_pc0: GpioPin;
}
extern "C" {
    pub static gpio_ext_pc1: GpioPin;
}
extern "C" {
    pub static gpio_ext_pc3: GpioPin;
}
extern "C" {
    pub static gpio_ext_pb2: GpioPin;
}
extern "C" {
    pub static gpio_ext_pb3: GpioPin;
}
extern "C" {
    pub static gpio_ext_pa4: GpioPin;
}
extern "C" {
    pub static gpio_ext_pa6: GpioPin;
}
extern "C" {
    pub static gpio_ext_pa7: GpioPin;
}
extern "C" {
    pub static gpio_nfc_irq_rfid_pull: GpioPin;
}
extern "C" {
    pub static gpio_rfid_carrier_out: GpioPin;
}
extern "C" {
    pub static gpio_rfid_data_in: GpioPin;
}
extern "C" {
    pub static gpio_rfid_carrier: GpioPin;
}
extern "C" {
    pub static gpio_infrared_rx: GpioPin;
}
extern "C" {
    pub static gpio_infrared_tx: GpioPin;
}
extern "C" {
    pub static gpio_usart_tx: GpioPin;
}
extern "C" {
    pub static gpio_usart_rx: GpioPin;
}
extern "C" {
    pub static gpio_i2c_power_sda: GpioPin;
}
extern "C" {
    pub static gpio_i2c_power_scl: GpioPin;
}
extern "C" {
    pub static gpio_speaker: GpioPin;
}
extern "C" {
    pub static periph_power: GpioPin;
}
extern "C" {
    pub static gpio_usb_dm: GpioPin;
}
extern "C" {
    pub static gpio_usb_dp: GpioPin;
}
extern "C" {
    #[doc = " Get a corresponding external connector pin number for a gpio\n @param gpio GpioPin\n @return pin number or -1 if gpio is not on the external connector"]
    pub fn furi_hal_resources_get_ext_pin_number(gpio: *const GpioPin) -> i32;
}
#[doc = "< Press event, emitted after debounce"]
pub const InputType_InputTypePress: InputType = 0;
#[doc = "< Release event, emitted after debounce"]
pub const InputType_InputTypeRelease: InputType = 1;
#[doc = "< Short event, emitted after InputTypeRelease done within INPUT_LONG_PRESS interval"]
pub const InputType_InputTypeShort: InputType = 2;
#[doc = "< Long event, emitted after INPUT_LONG_PRESS_COUNTS interval, asynchronous to InputTypeRelease"]
pub const InputType_InputTypeLong: InputType = 3;
#[doc = "< Repeat event, emitted with INPUT_LONG_PRESS_COUNTS period after InputTypeLong event"]
pub const InputType_InputTypeRepeat: InputType = 4;
#[doc = "< Special value for exceptional"]
pub const InputType_InputTypeMAX: InputType = 5;
#[doc = " Input Types\n Some of them are physical events and some logical"]
pub type InputType = core::ffi::c_uchar;
#[doc = " Input Event, dispatches with FuriPubSub"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct InputEvent {
    pub sequence: u32,
    pub key: InputKey,
    pub type_: InputType,
}
#[test]
fn bindgen_test_layout_InputEvent() {
    const UNINIT: ::core::mem::MaybeUninit<InputEvent> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<InputEvent>(),
        8usize,
        concat!("Size of: ", stringify!(InputEvent))
    );
    assert_eq!(
        ::core::mem::align_of::<InputEvent>(),
        4usize,
        concat!("Alignment of ", stringify!(InputEvent))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).sequence) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(InputEvent),
            "::",
            stringify!(sequence)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).key) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(InputEvent),
            "::",
            stringify!(key)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(InputEvent),
            "::",
            stringify!(type_)
        )
    );
}
extern "C" {
    #[doc = " Get human readable input key name\n @param key - InputKey\n @return string"]
    pub fn input_get_key_name(key: InputKey) -> *const core::ffi::c_char;
}
extern "C" {
    #[doc = " Get human readable input type name\n @param type - InputType\n @return string"]
    pub fn input_get_type_name(type_: InputType) -> *const core::ffi::c_char;
}
pub const ViewOrientation_ViewOrientationHorizontal: ViewOrientation = 0;
pub const ViewOrientation_ViewOrientationHorizontalFlip: ViewOrientation = 1;
pub const ViewOrientation_ViewOrientationVertical: ViewOrientation = 2;
pub const ViewOrientation_ViewOrientationVerticalFlip: ViewOrientation = 3;
pub type ViewOrientation = core::ffi::c_uchar;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct View {
    _unused: [u8; 0],
}
#[doc = " View Draw callback\n @param      canvas,      pointer to canvas\n @param      view_model,  pointer to context\n @warning    called from GUI thread"]
pub type ViewDrawCallback = ::core::option::Option<
    unsafe extern "C" fn(canvas: *mut Canvas, model: *mut core::ffi::c_void),
>;
#[doc = " View Input callback\n @param      event,    pointer to input event data\n @param      context,  pointer to context\n @return     true if event handled, false if event ignored\n @warning    called from GUI thread"]
pub type ViewInputCallback = ::core::option::Option<
    unsafe extern "C" fn(event: *mut InputEvent, context: *mut core::ffi::c_void) -> bool,
>;
#[doc = " View Custom callback\n @param      event,    number of custom event\n @param      context,  pointer to context\n @return     true if event handled, false if event ignored"]
pub type ViewCustomCallback = ::core::option::Option<
    unsafe extern "C" fn(event: u32, context: *mut core::ffi::c_void) -> bool,
>;
#[doc = " View navigation callback\n @param      context,  pointer to context\n @return     next view id\n @warning    called from GUI thread"]
pub type ViewNavigationCallback =
    ::core::option::Option<unsafe extern "C" fn(context: *mut core::ffi::c_void) -> u32>;
#[doc = " View callback\n @param      context,  pointer to context\n @warning    called from GUI thread"]
pub type ViewCallback =
    ::core::option::Option<unsafe extern "C" fn(context: *mut core::ffi::c_void)>;
#[doc = " View Update Callback Called upon model change, need to be propagated to GUI\n throw ViewPort update\n @param      view,     pointer to view\n @param      context,  pointer to context\n @warning    called from GUI thread"]
pub type ViewUpdateCallback =
    ::core::option::Option<unsafe extern "C" fn(view: *mut View, context: *mut core::ffi::c_void)>;
#[doc = " Model is not allocated"]
pub const ViewModelType_ViewModelTypeNone: ViewModelType = 0;
#[doc = " Model consist of atomic types and/or partial update is not critical for rendering.\n Lock free."]
pub const ViewModelType_ViewModelTypeLockFree: ViewModelType = 1;
#[doc = " Model access is guarded with mutex.\n Locking gui thread."]
pub const ViewModelType_ViewModelTypeLocking: ViewModelType = 2;
#[doc = " View model types"]
pub type ViewModelType = core::ffi::c_uchar;
extern "C" {
    #[doc = " Allocate and init View\n @return View instance"]
    pub fn view_alloc() -> *mut View;
}
extern "C" {
    #[doc = " Free View\n\n @param      view  instance"]
    pub fn view_free(view: *mut View);
}
extern "C" {
    #[doc = " Tie IconAnimation with View\n\n @param      view            View instance\n @param      icon_animation  IconAnimation instance"]
    pub fn view_tie_icon_animation(view: *mut View, icon_animation: *mut IconAnimation);
}
extern "C" {
    #[doc = " Set View Draw callback\n\n @param      view      View instance\n @param      callback  draw callback"]
    pub fn view_set_draw_callback(view: *mut View, callback: ViewDrawCallback);
}
extern "C" {
    #[doc = " Set View Input callback\n\n @param      view      View instance\n @param      callback  input callback"]
    pub fn view_set_input_callback(view: *mut View, callback: ViewInputCallback);
}
extern "C" {
    #[doc = " Set View Custom callback\n\n @param      view      View instance\n @param      callback  input callback"]
    pub fn view_set_custom_callback(view: *mut View, callback: ViewCustomCallback);
}
extern "C" {
    #[doc = " Set Navigation Previous callback\n\n @param      view      View instance\n @param      callback  input callback"]
    pub fn view_set_previous_callback(view: *mut View, callback: ViewNavigationCallback);
}
extern "C" {
    #[doc = " Set Enter callback\n\n @param      view      View instance\n @param      callback  callback"]
    pub fn view_set_enter_callback(view: *mut View, callback: ViewCallback);
}
extern "C" {
    #[doc = " Set Exit callback\n\n @param      view      View instance\n @param      callback  callback"]
    pub fn view_set_exit_callback(view: *mut View, callback: ViewCallback);
}
extern "C" {
    #[doc = " Set Update callback\n\n @param      view      View instance\n @param      callback  callback"]
    pub fn view_set_update_callback(view: *mut View, callback: ViewUpdateCallback);
}
extern "C" {
    #[doc = " Set View Draw callback\n\n @param      view     View instance\n @param      context  context for callbacks"]
    pub fn view_set_update_callback_context(view: *mut View, context: *mut core::ffi::c_void);
}
extern "C" {
    #[doc = " Set View Draw callback\n\n @param      view     View instance\n @param      context  context for callbacks"]
    pub fn view_set_context(view: *mut View, context: *mut core::ffi::c_void);
}
extern "C" {
    #[doc = " Set View Orientation\n\n @param      view         View instance\n @param      orientation  either vertical or horizontal"]
    pub fn view_set_orientation(view: *mut View, orientation: ViewOrientation);
}
extern "C" {
    #[doc = " Allocate view model.\n\n @param      view  View instance\n @param      type  View Model Type\n @param      size  size"]
    pub fn view_allocate_model(view: *mut View, type_: ViewModelType, size: usize);
}
extern "C" {
    #[doc = " Free view model data memory.\n\n @param      view  View instance"]
    pub fn view_free_model(view: *mut View);
}
extern "C" {
    #[doc = " Get view model data\n\n @param      view  View instance\n\n @return     pointer to model data\n @warning    Don't forget to commit model changes"]
    pub fn view_get_model(view: *mut View) -> *mut core::ffi::c_void;
}
extern "C" {
    #[doc = " Commit view model\n\n @param      view    View instance\n @param      update  true if you want to emit view update, false otherwise"]
    pub fn view_commit_model(view: *mut View, update: bool);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FileBrowser {
    _unused: [u8; 0],
}
pub type FileBrowserCallback =
    ::core::option::Option<unsafe extern "C" fn(context: *mut core::ffi::c_void)>;
pub type FileBrowserLoadItemCallback = ::core::option::Option<
    unsafe extern "C" fn(
        path: *mut FuriString,
        context: *mut core::ffi::c_void,
        icon: *mut *mut u8,
        item_name: *mut FuriString,
    ) -> bool,
>;
extern "C" {
    pub fn file_browser_alloc(result_path: *mut FuriString) -> *mut FileBrowser;
}
extern "C" {
    pub fn file_browser_free(browser: *mut FileBrowser);
}
extern "C" {
    pub fn file_browser_get_view(browser: *mut FileBrowser) -> *mut View;
}
extern "C" {
    pub fn file_browser_configure(
        browser: *mut FileBrowser,
        extension: *const core::ffi::c_char,
        base_path: *const core::ffi::c_char,
        skip_assets: bool,
        hide_dot_files: bool,
        file_icon: *const Icon,
        hide_ext: bool,
    );
}
extern "C" {
    pub fn file_browser_start(browser: *mut FileBrowser, path: *mut FuriString);
}
extern "C" {
    pub fn file_browser_stop(browser: *mut FileBrowser);
}
extern "C" {
    pub fn file_browser_set_callback(
        browser: *mut FileBrowser,
        callback: FileBrowserCallback,
        context: *mut core::ffi::c_void,
    );
}
extern "C" {
    pub fn file_browser_set_item_callback(
        browser: *mut FileBrowser,
        callback: FileBrowserLoadItemCallback,
        context: *mut core::ffi::c_void,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DialogsApp {
    _unused: [u8; 0],
}
#[doc = " File browser dialog extra options\n @param extension file extension to be offered for selection\n @param base_path root folder path for navigation with back key\n @param skip_assets true - do not show assets folders\n @param hide_dot_files true - hide dot files\n @param icon file icon pointer, NULL for default icon\n @param hide_ext true - hide extensions for files\n @param item_loader_callback callback function for providing custom icon & entry name\n @param hide_ext callback context"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DialogsFileBrowserOptions {
    pub extension: *const core::ffi::c_char,
    pub base_path: *const core::ffi::c_char,
    pub skip_assets: bool,
    pub hide_dot_files: bool,
    pub icon: *const Icon,
    pub hide_ext: bool,
    pub item_loader_callback: FileBrowserLoadItemCallback,
    pub item_loader_context: *mut core::ffi::c_void,
}
#[test]
fn bindgen_test_layout_DialogsFileBrowserOptions() {
    const UNINIT: ::core::mem::MaybeUninit<DialogsFileBrowserOptions> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<DialogsFileBrowserOptions>(),
        28usize,
        concat!("Size of: ", stringify!(DialogsFileBrowserOptions))
    );
    assert_eq!(
        ::core::mem::align_of::<DialogsFileBrowserOptions>(),
        4usize,
        concat!("Alignment of ", stringify!(DialogsFileBrowserOptions))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).extension) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DialogsFileBrowserOptions),
            "::",
            stringify!(extension)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).base_path) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(DialogsFileBrowserOptions),
            "::",
            stringify!(base_path)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).skip_assets) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(DialogsFileBrowserOptions),
            "::",
            stringify!(skip_assets)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).hide_dot_files) as usize - ptr as usize },
        9usize,
        concat!(
            "Offset of field: ",
            stringify!(DialogsFileBrowserOptions),
            "::",
            stringify!(hide_dot_files)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).icon) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(DialogsFileBrowserOptions),
            "::",
            stringify!(icon)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).hide_ext) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(DialogsFileBrowserOptions),
            "::",
            stringify!(hide_ext)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).item_loader_callback) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(DialogsFileBrowserOptions),
            "::",
            stringify!(item_loader_callback)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).item_loader_context) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(DialogsFileBrowserOptions),
            "::",
            stringify!(item_loader_context)
        )
    );
}
extern "C" {
    #[doc = " Initialize file browser dialog options\n and set default values\n @param options pointer to options structure\n @param extension file extension to filter\n @param icon file icon pointer, NULL for default icon"]
    pub fn dialog_file_browser_set_basic_options(
        options: *mut DialogsFileBrowserOptions,
        extension: *const core::ffi::c_char,
        icon: *const Icon,
    );
}
extern "C" {
    #[doc = " Shows and processes the file browser dialog\n @param context api pointer\n @param result_path selected file path string pointer\n @param path preselected file path string pointer\n @param options file browser dialog extra options, may be null\n @return bool whether a file was selected"]
    pub fn dialog_file_browser_show(
        context: *mut DialogsApp,
        result_path: *mut FuriString,
        path: *mut FuriString,
        options: *const DialogsFileBrowserOptions,
    ) -> bool;
}
pub const DialogMessageButton_DialogMessageButtonBack: DialogMessageButton = 0;
pub const DialogMessageButton_DialogMessageButtonLeft: DialogMessageButton = 1;
pub const DialogMessageButton_DialogMessageButtonCenter: DialogMessageButton = 2;
pub const DialogMessageButton_DialogMessageButtonRight: DialogMessageButton = 3;
#[doc = " Message result type"]
pub type DialogMessageButton = core::ffi::c_uchar;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DialogMessage {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " Allocate and fill message\n @return DialogMessage*"]
    pub fn dialog_message_alloc() -> *mut DialogMessage;
}
extern "C" {
    #[doc = " Free message struct\n @param message message pointer"]
    pub fn dialog_message_free(message: *mut DialogMessage);
}
extern "C" {
    #[doc = " Set message text\n @param message message pointer\n @param text text, can be NULL if you don't want to display the text\n @param x x position\n @param y y position\n @param horizontal horizontal alignment\n @param vertical vertical alignment"]
    pub fn dialog_message_set_text(
        message: *mut DialogMessage,
        text: *const core::ffi::c_char,
        x: u8,
        y: u8,
        horizontal: Align,
        vertical: Align,
    );
}
extern "C" {
    #[doc = " Set message header\n @param message message pointer\n @param text text, can be NULL if you don't want to display the header\n @param x x position\n @param y y position\n @param horizontal horizontal alignment\n @param vertical vertical alignment"]
    pub fn dialog_message_set_header(
        message: *mut DialogMessage,
        text: *const core::ffi::c_char,
        x: u8,
        y: u8,
        horizontal: Align,
        vertical: Align,
    );
}
extern "C" {
    #[doc = " Set message icon\n @param message message pointer\n @param icon icon pointer, can be NULL if you don't want to display the icon\n @param x x position\n @param y y position"]
    pub fn dialog_message_set_icon(message: *mut DialogMessage, icon: *const Icon, x: u8, y: u8);
}
extern "C" {
    #[doc = " Set message buttons text, button text can be NULL if you don't want to display and process some buttons\n @param message message pointer\n @param left left button text, can be NULL if you don't want to display the left button\n @param center center button text, can be NULL if you don't want to display the center button\n @param right right button text, can be NULL if you don't want to display the right button"]
    pub fn dialog_message_set_buttons(
        message: *mut DialogMessage,
        left: *const core::ffi::c_char,
        center: *const core::ffi::c_char,
        right: *const core::ffi::c_char,
    );
}
extern "C" {
    #[doc = " Show message from filled struct\n @param context api pointer\n @param message message struct pointer to be shown\n @return DialogMessageButton type"]
    pub fn dialog_message_show(
        context: *mut DialogsApp,
        message: *const DialogMessage,
    ) -> DialogMessageButton;
}
extern "C" {
    #[doc = " Show SD error message (with question sign)\n @param context\n @param error_text"]
    pub fn dialog_message_show_storage_error(
        context: *mut DialogsApp,
        error_text: *const core::ffi::c_char,
    );
}
pub const DolphinApp_DolphinAppSubGhz: DolphinApp = 0;
pub const DolphinApp_DolphinAppRfid: DolphinApp = 1;
pub const DolphinApp_DolphinAppNfc: DolphinApp = 2;
pub const DolphinApp_DolphinAppIr: DolphinApp = 3;
pub const DolphinApp_DolphinAppIbutton: DolphinApp = 4;
pub const DolphinApp_DolphinAppBadusb: DolphinApp = 5;
pub const DolphinApp_DolphinAppPlugin: DolphinApp = 6;
pub const DolphinApp_DolphinAppMAX: DolphinApp = 7;
pub type DolphinApp = core::ffi::c_uchar;
pub const DolphinDeed_DolphinDeedSubGhzReceiverInfo: DolphinDeed = 0;
pub const DolphinDeed_DolphinDeedSubGhzSave: DolphinDeed = 1;
pub const DolphinDeed_DolphinDeedSubGhzRawRec: DolphinDeed = 2;
pub const DolphinDeed_DolphinDeedSubGhzAddManually: DolphinDeed = 3;
pub const DolphinDeed_DolphinDeedSubGhzSend: DolphinDeed = 4;
pub const DolphinDeed_DolphinDeedSubGhzFrequencyAnalyzer: DolphinDeed = 5;
pub const DolphinDeed_DolphinDeedRfidRead: DolphinDeed = 6;
pub const DolphinDeed_DolphinDeedRfidReadSuccess: DolphinDeed = 7;
pub const DolphinDeed_DolphinDeedRfidSave: DolphinDeed = 8;
pub const DolphinDeed_DolphinDeedRfidEmulate: DolphinDeed = 9;
pub const DolphinDeed_DolphinDeedRfidAdd: DolphinDeed = 10;
pub const DolphinDeed_DolphinDeedNfcRead: DolphinDeed = 11;
pub const DolphinDeed_DolphinDeedNfcReadSuccess: DolphinDeed = 12;
pub const DolphinDeed_DolphinDeedNfcSave: DolphinDeed = 13;
pub const DolphinDeed_DolphinDeedNfcDetectReader: DolphinDeed = 14;
pub const DolphinDeed_DolphinDeedNfcEmulate: DolphinDeed = 15;
pub const DolphinDeed_DolphinDeedNfcMfcAdd: DolphinDeed = 16;
pub const DolphinDeed_DolphinDeedNfcAddSave: DolphinDeed = 17;
pub const DolphinDeed_DolphinDeedNfcAddEmulate: DolphinDeed = 18;
pub const DolphinDeed_DolphinDeedIrSend: DolphinDeed = 19;
pub const DolphinDeed_DolphinDeedIrLearnSuccess: DolphinDeed = 20;
pub const DolphinDeed_DolphinDeedIrSave: DolphinDeed = 21;
pub const DolphinDeed_DolphinDeedIbuttonRead: DolphinDeed = 22;
pub const DolphinDeed_DolphinDeedIbuttonReadSuccess: DolphinDeed = 23;
pub const DolphinDeed_DolphinDeedIbuttonSave: DolphinDeed = 24;
pub const DolphinDeed_DolphinDeedIbuttonEmulate: DolphinDeed = 25;
pub const DolphinDeed_DolphinDeedIbuttonAdd: DolphinDeed = 26;
pub const DolphinDeed_DolphinDeedBadUsbPlayScript: DolphinDeed = 27;
pub const DolphinDeed_DolphinDeedU2fAuthorized: DolphinDeed = 28;
pub const DolphinDeed_DolphinDeedGpioUartBridge: DolphinDeed = 29;
pub const DolphinDeed_DolphinDeedPluginStart: DolphinDeed = 30;
pub const DolphinDeed_DolphinDeedPluginGameStart: DolphinDeed = 31;
pub const DolphinDeed_DolphinDeedPluginGameWin: DolphinDeed = 32;
pub const DolphinDeed_DolphinDeedMAX: DolphinDeed = 33;
pub const DolphinDeed_DolphinDeedTestLeft: DolphinDeed = 34;
pub const DolphinDeed_DolphinDeedTestRight: DolphinDeed = 35;
pub type DolphinDeed = core::ffi::c_uchar;
extern "C" {
    pub fn dolphin_deed_get_app(deed: DolphinDeed) -> DolphinApp;
}
extern "C" {
    pub fn dolphin_deed_get_app_limit(app: DolphinApp) -> u8;
}
extern "C" {
    pub fn dolphin_deed_get_weight(deed: DolphinDeed) -> u8;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Dolphin {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DolphinStats {
    pub icounter: u32,
    pub butthurt: u32,
    pub timestamp: u64,
    pub level: u8,
    pub level_up_is_pending: bool,
}
#[test]
fn bindgen_test_layout_DolphinStats() {
    const UNINIT: ::core::mem::MaybeUninit<DolphinStats> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<DolphinStats>(),
        24usize,
        concat!("Size of: ", stringify!(DolphinStats))
    );
    assert_eq!(
        ::core::mem::align_of::<DolphinStats>(),
        8usize,
        concat!("Alignment of ", stringify!(DolphinStats))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).icounter) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DolphinStats),
            "::",
            stringify!(icounter)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).butthurt) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(DolphinStats),
            "::",
            stringify!(butthurt)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).timestamp) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(DolphinStats),
            "::",
            stringify!(timestamp)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).level) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(DolphinStats),
            "::",
            stringify!(level)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).level_up_is_pending) as usize - ptr as usize },
        17usize,
        concat!(
            "Offset of field: ",
            stringify!(DolphinStats),
            "::",
            stringify!(level_up_is_pending)
        )
    );
}
extern "C" {
    #[doc = " Deed complete notification. Call it on deed completion.\n See dolphin_deed.h for available deeds. In futures it will become part of assets.\n Thread safe, async"]
    pub fn dolphin_deed(dolphin: *mut Dolphin, deed: DolphinDeed);
}
extern "C" {
    #[doc = " Retrieve dolphin stats\n Thread safe, blocking"]
    pub fn dolphin_stats(dolphin: *mut Dolphin) -> DolphinStats;
}
extern "C" {
    #[doc = " Flush dolphin queue and save state\n Thread safe, blocking"]
    pub fn dolphin_flush(dolphin: *mut Dolphin);
}
extern "C" {
    pub fn dolphin_upgrade_level(dolphin: *mut Dolphin);
}
extern "C" {
    pub fn dolphin_get_pubsub(dolphin: *mut Dolphin) -> *mut FuriPubSub;
}
extern "C" {
    #[doc = " Draw progress bar.\n\n @param   canvas      Canvas instance\n @param   x           progress bar position on X axis\n @param   y           progress bar position on Y axis\n @param   width       progress bar width\n @param   progress    progress (0.0 - 1.0)"]
    pub fn elements_progress_bar(canvas: *mut Canvas, x: u8, y: u8, width: u8, progress: f32);
}
extern "C" {
    #[doc = " Draw progress bar with text.\n\n @param   canvas      Canvas instance\n @param   x           progress bar position on X axis\n @param   y           progress bar position on Y axis\n @param   width       progress bar width\n @param   progress    progress (0.0 - 1.0)\n @param   text        text to draw"]
    pub fn elements_progress_bar_with_text(
        canvas: *mut Canvas,
        x: u8,
        y: u8,
        width: u8,
        progress: f32,
        text: *const core::ffi::c_char,
    );
}
extern "C" {
    #[doc = " Draw scrollbar on canvas at specific position.\n\n @param   canvas  Canvas instance\n @param   x       scrollbar position on X axis\n @param   y       scrollbar position on Y axis\n @param   height  scrollbar height\n @param   pos     current element\n @param   total   total elements"]
    pub fn elements_scrollbar_pos(
        canvas: *mut Canvas,
        x: u8,
        y: u8,
        height: u8,
        pos: u16,
        total: u16,
    );
}
extern "C" {
    #[doc = " Draw scrollbar on canvas.\n @note    width 3px, height equal to canvas height\n\n @param   canvas  Canvas instance\n @param   pos     current element of total elements\n @param   total   total elements"]
    pub fn elements_scrollbar(canvas: *mut Canvas, pos: u16, total: u16);
}
extern "C" {
    #[doc = " Draw rounded frame\n\n @param   canvas          Canvas instance\n @param   x, y            top left corner coordinates\n @param   width, height   frame width and height"]
    pub fn elements_frame(canvas: *mut Canvas, x: u8, y: u8, width: u8, height: u8);
}
extern "C" {
    #[doc = " Draw button in left corner\n\n @param   canvas  Canvas instance\n @param   str     button text"]
    pub fn elements_button_left(canvas: *mut Canvas, str_: *const core::ffi::c_char);
}
extern "C" {
    #[doc = " Draw button in right corner\n\n @param   canvas  Canvas instance\n @param   str     button text"]
    pub fn elements_button_right(canvas: *mut Canvas, str_: *const core::ffi::c_char);
}
extern "C" {
    #[doc = " Draw button in center\n\n @param   canvas  Canvas instance\n @param   str     button text"]
    pub fn elements_button_center(canvas: *mut Canvas, str_: *const core::ffi::c_char);
}
extern "C" {
    #[doc = " Draw aligned multiline text\n\n @param   canvas                  Canvas instance\n @param   x, y                    coordinates based on align param\n @param   horizontal, vertical    alignment of multiline text\n @param   text                    string (possible multiline)"]
    pub fn elements_multiline_text_aligned(
        canvas: *mut Canvas,
        x: u8,
        y: u8,
        horizontal: Align,
        vertical: Align,
        text: *const core::ffi::c_char,
    );
}
extern "C" {
    #[doc = " Draw multiline text\n\n @param   canvas  Canvas instance\n @param   x, y    top left corner coordinates\n @param   text    string (possible multiline)"]
    pub fn elements_multiline_text(
        canvas: *mut Canvas,
        x: u8,
        y: u8,
        text: *const core::ffi::c_char,
    );
}
extern "C" {
    #[doc = " Draw framed multiline text\n\n @param   canvas  Canvas instance\n @param   x, y    top left corner coordinates\n @param   text    string (possible multiline)"]
    pub fn elements_multiline_text_framed(
        canvas: *mut Canvas,
        x: u8,
        y: u8,
        text: *const core::ffi::c_char,
    );
}
extern "C" {
    #[doc = " Draw slightly rounded frame\n\n @param   canvas          Canvas instance\n @param   x, y            top left corner coordinates\n @param   width, height   size of frame"]
    pub fn elements_slightly_rounded_frame(
        canvas: *mut Canvas,
        x: u8,
        y: u8,
        width: u8,
        height: u8,
    );
}
extern "C" {
    #[doc = " Draw slightly rounded box\n\n @param   canvas          Canvas instance\n @param   x, y            top left corner coordinates\n @param   width, height   size of box"]
    pub fn elements_slightly_rounded_box(canvas: *mut Canvas, x: u8, y: u8, width: u8, height: u8);
}
extern "C" {
    #[doc = " Draw bold rounded frame\n\n @param   canvas          Canvas instance\n @param   x, y            top left corner coordinates\n @param   width, height   size of frame"]
    pub fn elements_bold_rounded_frame(canvas: *mut Canvas, x: u8, y: u8, width: u8, height: u8);
}
extern "C" {
    #[doc = " Draw bubble frame for text\n\n @param   canvas  Canvas instance\n @param   x       left x coordinates\n @param   y       top y coordinate\n @param   width   bubble width\n @param   height  bubble height"]
    pub fn elements_bubble(canvas: *mut Canvas, x: u8, y: u8, width: u8, height: u8);
}
extern "C" {
    #[doc = " Draw bubble frame for text with corner\n\n @param   canvas      Canvas instance\n @param   x           left x coordinates\n @param   y           top y coordinate\n @param   width       bubble width\n @param   height      bubble height\n @param   horizontal  horizontal aligning\n @param   vertical    aligning"]
    pub fn elements_bubble_str(
        canvas: *mut Canvas,
        x: u8,
        y: u8,
        text: *const core::ffi::c_char,
        horizontal: Align,
        vertical: Align,
    );
}
extern "C" {
    #[doc = " Trim string buffer to fit width in pixels\n\n @param   canvas  Canvas instance\n @param   string  string to trim\n @param   width   max width"]
    pub fn elements_string_fit_width(canvas: *mut Canvas, string: *mut FuriString, width: u8);
}
extern "C" {
    #[doc = " Draw scrollable text line\n\n @param      canvas    The canvas\n @param[in]  x         X coordinate\n @param[in]  y         Y coordinate\n @param[in]  width     The width\n @param      string    The string\n @param[in]  scroll    The scroll counter: 0 - no scroll, any other number - scroll. Just count up, everything else will be calculated on the inside.\n @param[in]  ellipsis  The ellipsis flag: true to add ellipse"]
    pub fn elements_scrollable_text_line(
        canvas: *mut Canvas,
        x: u8,
        y: u8,
        width: u8,
        string: *mut FuriString,
        scroll: usize,
        ellipsis: bool,
    );
}
extern "C" {
    #[doc = " Draw text box element\n\n @param       canvas          Canvas instance\n @param       x               x coordinate\n @param       y               y coordinate\n @param       width           width to fit text\n @param       height          height to fit text\n @param       horizontal      Align instance\n @param       vertical        Align instance\n @param[in]   text            Formatted text. The following formats are available:\n                              \"\\e#Bold text\\e#\" - bold font is used\n                              \"\\e*Monospaced text\\e*\" - monospaced font is used\n                              \"\\e!Inversed text\\e!\" - white text on black background\n @param      strip_to_dots    Strip text to ... if does not fit to width"]
    pub fn elements_text_box(
        canvas: *mut Canvas,
        x: u8,
        y: u8,
        width: u8,
        height: u8,
        horizontal: Align,
        vertical: Align,
        text: *const core::ffi::c_char,
        strip_to_dots: bool,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ViewPort {
    _unused: [u8; 0],
}
pub const ViewPortOrientation_ViewPortOrientationHorizontal: ViewPortOrientation = 0;
pub const ViewPortOrientation_ViewPortOrientationHorizontalFlip: ViewPortOrientation = 1;
pub const ViewPortOrientation_ViewPortOrientationVertical: ViewPortOrientation = 2;
pub const ViewPortOrientation_ViewPortOrientationVerticalFlip: ViewPortOrientation = 3;
#[doc = "< Special value, don't use it"]
pub const ViewPortOrientation_ViewPortOrientationMAX: ViewPortOrientation = 4;
pub type ViewPortOrientation = core::ffi::c_uchar;
#[doc = " ViewPort Draw callback\n @warning    called from GUI thread"]
pub type ViewPortDrawCallback = ::core::option::Option<
    unsafe extern "C" fn(canvas: *mut Canvas, context: *mut core::ffi::c_void),
>;
#[doc = " ViewPort Input callback\n @warning    called from GUI thread"]
pub type ViewPortInputCallback = ::core::option::Option<
    unsafe extern "C" fn(event: *mut InputEvent, context: *mut core::ffi::c_void),
>;
extern "C" {
    #[doc = " ViewPort allocator\n\n always returns view_port or stops system if not enough memory.\n\n @return     ViewPort instance"]
    pub fn view_port_alloc() -> *mut ViewPort;
}
extern "C" {
    #[doc = " ViewPort deallocator\n\n Ensure that view_port was unregistered in GUI system before use.\n\n @param      view_port  ViewPort instance"]
    pub fn view_port_free(view_port: *mut ViewPort);
}
extern "C" {
    #[doc = " Set view_port width.\n\n Will be used to limit canvas drawing area and autolayout feature.\n\n @param      view_port  ViewPort instance\n @param      width      wanted width, 0 - auto."]
    pub fn view_port_set_width(view_port: *mut ViewPort, width: u8);
}
extern "C" {
    pub fn view_port_get_width(view_port: *const ViewPort) -> u8;
}
extern "C" {
    #[doc = " Set view_port height.\n\n Will be used to limit canvas drawing area and autolayout feature.\n\n @param      view_port  ViewPort instance\n @param      height     wanted height, 0 - auto."]
    pub fn view_port_set_height(view_port: *mut ViewPort, height: u8);
}
extern "C" {
    pub fn view_port_get_height(view_port: *const ViewPort) -> u8;
}
extern "C" {
    #[doc = " Enable or disable view_port rendering.\n\n @param      view_port  ViewPort instance\n @param      enabled    Indicates if enabled\n @warning    automatically dispatches update event"]
    pub fn view_port_enabled_set(view_port: *mut ViewPort, enabled: bool);
}
extern "C" {
    pub fn view_port_is_enabled(view_port: *const ViewPort) -> bool;
}
extern "C" {
    #[doc = " ViewPort event callbacks\n\n @param      view_port  ViewPort instance\n @param      callback   appropriate callback function\n @param      context    context to pass to callback"]
    pub fn view_port_draw_callback_set(
        view_port: *mut ViewPort,
        callback: ViewPortDrawCallback,
        context: *mut core::ffi::c_void,
    );
}
extern "C" {
    pub fn view_port_input_callback_set(
        view_port: *mut ViewPort,
        callback: ViewPortInputCallback,
        context: *mut core::ffi::c_void,
    );
}
extern "C" {
    #[doc = " Emit update signal to GUI system.\n\n Rendering will happen later after GUI system process signal.\n\n @param      view_port  ViewPort instance"]
    pub fn view_port_update(view_port: *mut ViewPort);
}
extern "C" {
    #[doc = " Set ViewPort orientation.\n\n @param      view_port    ViewPort instance\n @param      orientation  display orientation, horizontal or vertical."]
    pub fn view_port_set_orientation(view_port: *mut ViewPort, orientation: ViewPortOrientation);
}
extern "C" {
    pub fn view_port_get_orientation(view_port: *const ViewPort) -> ViewPortOrientation;
}
#[doc = "< Desktop layer for internal use. Like fullscreen but with status bar"]
pub const GuiLayer_GuiLayerDesktop: GuiLayer = 0;
#[doc = "< Window layer, status bar is shown"]
pub const GuiLayer_GuiLayerWindow: GuiLayer = 1;
#[doc = "< Status bar left-side layer, auto-layout"]
pub const GuiLayer_GuiLayerStatusBarLeft: GuiLayer = 2;
#[doc = "< Status bar right-side layer, auto-layout"]
pub const GuiLayer_GuiLayerStatusBarRight: GuiLayer = 3;
#[doc = "< Fullscreen layer, no status bar"]
pub const GuiLayer_GuiLayerFullscreen: GuiLayer = 4;
#[doc = "< Don't use or move, special value"]
pub const GuiLayer_GuiLayerMAX: GuiLayer = 5;
#[doc = " Gui layers"]
pub type GuiLayer = core::ffi::c_uchar;
#[doc = " Gui Canvas Commit Callback"]
pub type GuiCanvasCommitCallback = ::core::option::Option<
    unsafe extern "C" fn(data: *mut u8, size: usize, context: *mut core::ffi::c_void),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Gui {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " Add view_port to view_port tree\n\n @remark     thread safe\n\n @param      gui        Gui instance\n @param      view_port  ViewPort instance\n @param[in]  layer      GuiLayer where to place view_port"]
    pub fn gui_add_view_port(gui: *mut Gui, view_port: *mut ViewPort, layer: GuiLayer);
}
extern "C" {
    #[doc = " Remove view_port from rendering tree\n\n @remark     thread safe\n\n @param      gui        Gui instance\n @param      view_port  ViewPort instance"]
    pub fn gui_remove_view_port(gui: *mut Gui, view_port: *mut ViewPort);
}
extern "C" {
    #[doc = " Send ViewPort to the front\n\n Places selected ViewPort to the top of the drawing stack\n\n @param      gui        Gui instance\n @param      view_port  ViewPort instance"]
    pub fn gui_view_port_send_to_front(gui: *mut Gui, view_port: *mut ViewPort);
}
extern "C" {
    #[doc = " Add gui canvas commit callback\n\n This callback will be called upon Canvas commit Callback dispatched from GUI\n thread and is time critical\n\n @param      gui       Gui instance\n @param      callback  GuiCanvasCommitCallback\n @param      context   GuiCanvasCommitCallback context"]
    pub fn gui_add_framebuffer_callback(
        gui: *mut Gui,
        callback: GuiCanvasCommitCallback,
        context: *mut core::ffi::c_void,
    );
}
extern "C" {
    #[doc = " Remove gui canvas commit callback\n\n @param      gui       Gui instance\n @param      callback  GuiCanvasCommitCallback\n @param      context   GuiCanvasCommitCallback context"]
    pub fn gui_remove_framebuffer_callback(
        gui: *mut Gui,
        callback: GuiCanvasCommitCallback,
        context: *mut core::ffi::c_void,
    );
}
extern "C" {
    #[doc = " Get gui canvas frame buffer size\n *\n @param      gui       Gui instance\n @return     size_t    size of frame buffer in bytes"]
    pub fn gui_get_framebuffer_size(gui: *const Gui) -> usize;
}
extern "C" {
    #[doc = " Set lockdown mode\n\n When lockdown mode is enabled, only GuiLayerDesktop is shown.\n This feature prevents services from showing sensitive information when flipper is locked.\n\n @param      gui       Gui instance\n @param      lockdown  bool, true if enabled"]
    pub fn gui_set_lockdown(gui: *mut Gui, lockdown: bool);
}
extern "C" {
    #[doc = " Acquire Direct Draw lock and get Canvas instance\n\n This method return Canvas instance for use in monopoly mode. Direct draw lock\n disables input and draw call dispatch functions in GUI service. No other\n applications or services will be able to draw until gui_direct_draw_release\n call.\n\n @param      gui   The graphical user interface\n\n @return     Canvas instance"]
    pub fn gui_direct_draw_acquire(gui: *mut Gui) -> *mut Canvas;
}
extern "C" {
    #[doc = " Release Direct Draw Lock\n\n Release Direct Draw Lock, enables Input and Draw call processing. Canvas\n acquired in gui_direct_draw_acquire will become invalid after this call.\n\n @param      gui   Gui instance"]
    pub fn gui_direct_draw_release(gui: *mut Gui);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Icon {
    pub width: u8,
    pub height: u8,
    pub frame_count: u8,
    pub frame_rate: u8,
    pub frames: *const *const u8,
}
#[test]
fn bindgen_test_layout_Icon() {
    const UNINIT: ::core::mem::MaybeUninit<Icon> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<Icon>(),
        8usize,
        concat!("Size of: ", stringify!(Icon))
    );
    assert_eq!(
        ::core::mem::align_of::<Icon>(),
        4usize,
        concat!("Alignment of ", stringify!(Icon))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).width) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Icon),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).height) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(Icon),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).frame_count) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(Icon),
            "::",
            stringify!(frame_count)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).frame_rate) as usize - ptr as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(Icon),
            "::",
            stringify!(frame_rate)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).frames) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(Icon),
            "::",
            stringify!(frames)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ButtonMenu {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ButtonMenuItem {
    _unused: [u8; 0],
}
#[doc = " Callback for any button menu actions"]
pub type ButtonMenuItemCallback = ::core::option::Option<
    unsafe extern "C" fn(context: *mut core::ffi::c_void, index: i32, type_: InputType),
>;
pub const ButtonMenuItemType_ButtonMenuItemTypeCommon: ButtonMenuItemType = 0;
pub const ButtonMenuItemType_ButtonMenuItemTypeControl: ButtonMenuItemType = 1;
#[doc = " Type of button. Difference in drawing buttons."]
pub type ButtonMenuItemType = core::ffi::c_uchar;
extern "C" {
    #[doc = " Get button menu view\n\n @param      button_menu  ButtonMenu instance\n\n @return     View instance that can be used for embedding"]
    pub fn button_menu_get_view(button_menu: *mut ButtonMenu) -> *mut View;
}
extern "C" {
    #[doc = " Clean button menu\n\n @param      button_menu  ButtonMenu instance"]
    pub fn button_menu_reset(button_menu: *mut ButtonMenu);
}
extern "C" {
    #[doc = " Add item to button menu instance\n\n @param      button_menu       ButtonMenu instance\n @param      label             text inside new button\n @param      index             value to distinct between buttons inside\n                               ButtonMenuItemCallback\n @param      callback          The callback\n @param      type              type of button to create. Differ by button\n                               drawing. Control buttons have no frames, and\n                               have more squared borders.\n @param      callback_context  The callback context\n\n @return     pointer to just-created item"]
    pub fn button_menu_add_item(
        button_menu: *mut ButtonMenu,
        label: *const core::ffi::c_char,
        index: i32,
        callback: ButtonMenuItemCallback,
        type_: ButtonMenuItemType,
        callback_context: *mut core::ffi::c_void,
    ) -> *mut ButtonMenuItem;
}
extern "C" {
    #[doc = " Allocate and initialize new instance of ButtonMenu model\n\n @return     just-created ButtonMenu model"]
    pub fn button_menu_alloc() -> *mut ButtonMenu;
}
extern "C" {
    #[doc = " Free ButtonMenu element\n\n @param      button_menu  ButtonMenu instance"]
    pub fn button_menu_free(button_menu: *mut ButtonMenu);
}
extern "C" {
    #[doc = " Set ButtonMenu header on top of canvas\n\n @param      button_menu  ButtonMenu instance\n @param      header       header on the top of button menu"]
    pub fn button_menu_set_header(button_menu: *mut ButtonMenu, header: *const core::ffi::c_char);
}
extern "C" {
    #[doc = " Set selected item\n\n @param      button_menu  ButtonMenu instance\n @param      index        index of ButtonMenu to be selected"]
    pub fn button_menu_set_selected_item(button_menu: *mut ButtonMenu, index: u32);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ButtonPanel {
    _unused: [u8; 0],
}
#[doc = " Callback type to call for handling selecting button_panel items"]
pub type ButtonItemCallback =
    ::core::option::Option<unsafe extern "C" fn(context: *mut core::ffi::c_void, index: u32)>;
extern "C" {
    #[doc = " Allocate new button_panel module.\n\n @return     ButtonPanel instance"]
    pub fn button_panel_alloc() -> *mut ButtonPanel;
}
extern "C" {
    #[doc = " Free button_panel module.\n\n @param      button_panel  ButtonPanel instance"]
    pub fn button_panel_free(button_panel: *mut ButtonPanel);
}
extern "C" {
    #[doc = " Free items from button_panel module. Preallocated matrix stays unchanged.\n\n @param      button_panel  ButtonPanel instance"]
    pub fn button_panel_reset(button_panel: *mut ButtonPanel);
}
extern "C" {
    #[doc = " Reserve space for adding items.\n\n One does not simply use button_panel_add_item() without this function. It\n should be allocated space for it first.\n\n @param      button_panel  ButtonPanel instance\n @param      reserve_x     number of columns in button_panel\n @param      reserve_y     number of rows in button_panel"]
    pub fn button_panel_reserve(button_panel: *mut ButtonPanel, reserve_x: usize, reserve_y: usize);
}
extern "C" {
    #[doc = " Add item to button_panel module.\n\n Have to set element in bounds of allocated size by X and by Y.\n\n @param      button_panel        ButtonPanel instance\n @param      index               value to pass to callback\n @param      matrix_place_x      coordinates by x-axis on virtual grid, it\n                                 is only used for navigation\n @param      matrix_place_y      coordinates by y-axis on virtual grid, it\n                                 is only used for naviagation\n @param      x                   x-coordinate to draw icon on\n @param      y                   y-coordinate to draw icon on\n @param      icon_name           name of the icon to draw\n @param      icon_name_selected  name of the icon to draw when current\n                                 element is selected\n @param      callback            function to call when specific element is\n                                 selected (pressed Ok on selected item)\n @param      callback_context    context to pass to callback"]
    pub fn button_panel_add_item(
        button_panel: *mut ButtonPanel,
        index: u32,
        matrix_place_x: u16,
        matrix_place_y: u16,
        x: u16,
        y: u16,
        icon_name: *const Icon,
        icon_name_selected: *const Icon,
        callback: ButtonItemCallback,
        callback_context: *mut core::ffi::c_void,
    );
}
extern "C" {
    #[doc = " Get button_panel view.\n\n @param      button_panel  ButtonPanel instance\n\n @return     acquired view"]
    pub fn button_panel_get_view(button_panel: *mut ButtonPanel) -> *mut View;
}
extern "C" {
    #[doc = " Add label to button_panel module.\n\n @param      button_panel  ButtonPanel instance\n @param      x             x-coordinate to place label\n @param      y             y-coordinate to place label\n @param      font          font to write label with\n @param      label_str     string label to write"]
    pub fn button_panel_add_label(
        button_panel: *mut ButtonPanel,
        x: u16,
        y: u16,
        font: Font,
        label_str: *const core::ffi::c_char,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ByteInput {
    _unused: [u8; 0],
}
#[doc = " callback that is executed on save button press"]
pub type ByteInputCallback =
    ::core::option::Option<unsafe extern "C" fn(context: *mut core::ffi::c_void)>;
#[doc = " callback that is executed when byte buffer is changed"]
pub type ByteChangedCallback =
    ::core::option::Option<unsafe extern "C" fn(context: *mut core::ffi::c_void)>;
extern "C" {
    #[doc = " Allocate and initialize byte input. This byte input is used to enter bytes.\n\n @return     ByteInput instance pointer"]
    pub fn byte_input_alloc() -> *mut ByteInput;
}
extern "C" {
    #[doc = " Deinitialize and free byte input\n\n @param      byte_input  Byte input instance"]
    pub fn byte_input_free(byte_input: *mut ByteInput);
}
extern "C" {
    #[doc = " Get byte input view\n\n @param      byte_input  byte input instance\n\n @return     View instance that can be used for embedding"]
    pub fn byte_input_get_view(byte_input: *mut ByteInput) -> *mut View;
}
extern "C" {
    #[doc = " Set byte input result callback\n\n @param      byte_input        byte input instance\n @param      input_callback    input callback fn\n @param      changed_callback  changed callback fn\n @param      callback_context  callback context\n @param      bytes             buffer to use\n @param      bytes_count       buffer length"]
    pub fn byte_input_set_result_callback(
        byte_input: *mut ByteInput,
        input_callback: ByteInputCallback,
        changed_callback: ByteChangedCallback,
        callback_context: *mut core::ffi::c_void,
        bytes: *mut u8,
        bytes_count: u8,
    );
}
extern "C" {
    #[doc = " Set byte input header text\n\n @param      byte_input  byte input instance\n @param      text        text to be shown"]
    pub fn byte_input_set_header_text(byte_input: *mut ByteInput, text: *const core::ffi::c_char);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DialogEx {
    _unused: [u8; 0],
}
pub const DialogExResult_DialogExResultLeft: DialogExResult = 0;
pub const DialogExResult_DialogExResultCenter: DialogExResult = 1;
pub const DialogExResult_DialogExResultRight: DialogExResult = 2;
pub const DialogExResult_DialogExPressLeft: DialogExResult = 3;
pub const DialogExResult_DialogExPressCenter: DialogExResult = 4;
pub const DialogExResult_DialogExPressRight: DialogExResult = 5;
pub const DialogExResult_DialogExReleaseLeft: DialogExResult = 6;
pub const DialogExResult_DialogExReleaseCenter: DialogExResult = 7;
pub const DialogExResult_DialogExReleaseRight: DialogExResult = 8;
#[doc = " DialogEx result"]
pub type DialogExResult = core::ffi::c_uchar;
#[doc = " DialogEx result callback type\n @warning comes from GUI thread"]
pub type DialogExResultCallback = ::core::option::Option<
    unsafe extern "C" fn(result: DialogExResult, context: *mut core::ffi::c_void),
>;
extern "C" {
    #[doc = " Allocate and initialize dialog\n\n This dialog used to ask simple questions\n\n @return     DialogEx instance"]
    pub fn dialog_ex_alloc() -> *mut DialogEx;
}
extern "C" {
    #[doc = " Deinitialize and free dialog\n\n @param      dialog_ex  DialogEx instance"]
    pub fn dialog_ex_free(dialog_ex: *mut DialogEx);
}
extern "C" {
    #[doc = " Get dialog view\n\n @param      dialog_ex  DialogEx instance\n\n @return     View instance that can be used for embedding"]
    pub fn dialog_ex_get_view(dialog_ex: *mut DialogEx) -> *mut View;
}
extern "C" {
    #[doc = " Set dialog result callback\n\n @param      dialog_ex  DialogEx instance\n @param      callback   result callback function"]
    pub fn dialog_ex_set_result_callback(
        dialog_ex: *mut DialogEx,
        callback: DialogExResultCallback,
    );
}
extern "C" {
    #[doc = " Set dialog context\n\n @param      dialog_ex  DialogEx instance\n @param      context    context pointer, will be passed to result callback"]
    pub fn dialog_ex_set_context(dialog_ex: *mut DialogEx, context: *mut core::ffi::c_void);
}
extern "C" {
    #[doc = " Set dialog header text\n\n If text is null, dialog header will not be rendered\n\n @param      dialog_ex   DialogEx instance\n @param      text        text to be shown, can be multiline\n @param      x           x position\n @param      y           y position\n @param      horizontal  horizontal text alignment\n @param      vertical    vertical text alignment"]
    pub fn dialog_ex_set_header(
        dialog_ex: *mut DialogEx,
        text: *const core::ffi::c_char,
        x: u8,
        y: u8,
        horizontal: Align,
        vertical: Align,
    );
}
extern "C" {
    #[doc = " Set dialog text\n\n If text is null, dialog text will not be rendered\n\n @param      dialog_ex   DialogEx instance\n @param      text        text to be shown, can be multiline\n @param      x           x position\n @param      y           y position\n @param      horizontal  horizontal text alignment\n @param      vertical    vertical text alignment"]
    pub fn dialog_ex_set_text(
        dialog_ex: *mut DialogEx,
        text: *const core::ffi::c_char,
        x: u8,
        y: u8,
        horizontal: Align,
        vertical: Align,
    );
}
extern "C" {
    #[doc = " Set dialog icon\n\n If x or y is negative, dialog icon will not be rendered\n\n @param      dialog_ex  DialogEx instance\n @param      x          x position\n @param      y          y position\n @param      icon       The icon\n @param      name  icon to be shown"]
    pub fn dialog_ex_set_icon(dialog_ex: *mut DialogEx, x: u8, y: u8, icon: *const Icon);
}
extern "C" {
    #[doc = " Set left button text\n\n If text is null, left button will not be rendered and processed\n\n @param      dialog_ex  DialogEx instance\n @param      text       text to be shown"]
    pub fn dialog_ex_set_left_button_text(dialog_ex: *mut DialogEx, text: *const core::ffi::c_char);
}
extern "C" {
    #[doc = " Set center button text\n\n If text is null, center button will not be rendered and processed\n\n @param      dialog_ex  DialogEx instance\n @param      text       text to be shown"]
    pub fn dialog_ex_set_center_button_text(
        dialog_ex: *mut DialogEx,
        text: *const core::ffi::c_char,
    );
}
extern "C" {
    #[doc = " Set right button text\n\n If text is null, right button will not be rendered and processed\n\n @param      dialog_ex  DialogEx instance\n @param      text       text to be shown"]
    pub fn dialog_ex_set_right_button_text(
        dialog_ex: *mut DialogEx,
        text: *const core::ffi::c_char,
    );
}
extern "C" {
    #[doc = " Clean dialog\n\n @param      dialog_ex  DialogEx instance"]
    pub fn dialog_ex_reset(dialog_ex: *mut DialogEx);
}
extern "C" {
    #[doc = " Enable press/release events\n\n @param      dialog_ex  DialogEx instance"]
    pub fn dialog_ex_enable_extended_events(dialog_ex: *mut DialogEx);
}
extern "C" {
    #[doc = " Disable press/release events\n\n @param      dialog_ex  DialogEx instance"]
    pub fn dialog_ex_disable_extended_events(dialog_ex: *mut DialogEx);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct EmptyScreen {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " Allocate and initialize empty screen\n\n This empty screen used to ask simple questions like Yes/\n\n @return     EmptyScreen instance"]
    pub fn empty_screen_alloc() -> *mut EmptyScreen;
}
extern "C" {
    #[doc = " Deinitialize and free empty screen\n\n @param      empty_screen  Empty screen instance"]
    pub fn empty_screen_free(empty_screen: *mut EmptyScreen);
}
extern "C" {
    #[doc = " Get empty screen view\n\n @param      empty_screen  Empty screen instance\n\n @return     View instance that can be used for embedding"]
    pub fn empty_screen_get_view(empty_screen: *mut EmptyScreen) -> *mut View;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct BrowserWorker {
    _unused: [u8; 0],
}
pub type BrowserWorkerFolderOpenCallback = ::core::option::Option<
    unsafe extern "C" fn(
        context: *mut core::ffi::c_void,
        item_cnt: u32,
        file_idx: i32,
        is_root: bool,
    ),
>;
pub type BrowserWorkerListLoadCallback = ::core::option::Option<
    unsafe extern "C" fn(context: *mut core::ffi::c_void, list_load_offset: u32),
>;
pub type BrowserWorkerListItemCallback = ::core::option::Option<
    unsafe extern "C" fn(
        context: *mut core::ffi::c_void,
        item_path: *mut FuriString,
        is_folder: bool,
        is_last: bool,
    ),
>;
pub type BrowserWorkerLongLoadCallback =
    ::core::option::Option<unsafe extern "C" fn(context: *mut core::ffi::c_void)>;
extern "C" {
    pub fn file_browser_worker_alloc(
        path: *mut FuriString,
        base_path: *const core::ffi::c_char,
        filter_ext: *const core::ffi::c_char,
        skip_assets: bool,
        hide_dot_files: bool,
    ) -> *mut BrowserWorker;
}
extern "C" {
    pub fn file_browser_worker_free(browser: *mut BrowserWorker);
}
extern "C" {
    pub fn file_browser_worker_set_callback_context(
        browser: *mut BrowserWorker,
        context: *mut core::ffi::c_void,
    );
}
extern "C" {
    pub fn file_browser_worker_set_folder_callback(
        browser: *mut BrowserWorker,
        cb: BrowserWorkerFolderOpenCallback,
    );
}
extern "C" {
    pub fn file_browser_worker_set_list_callback(
        browser: *mut BrowserWorker,
        cb: BrowserWorkerListLoadCallback,
    );
}
extern "C" {
    pub fn file_browser_worker_set_item_callback(
        browser: *mut BrowserWorker,
        cb: BrowserWorkerListItemCallback,
    );
}
extern "C" {
    pub fn file_browser_worker_set_long_load_callback(
        browser: *mut BrowserWorker,
        cb: BrowserWorkerLongLoadCallback,
    );
}
extern "C" {
    pub fn file_browser_worker_set_config(
        browser: *mut BrowserWorker,
        path: *mut FuriString,
        filter_ext: *const core::ffi::c_char,
        skip_assets: bool,
        hide_dot_files: bool,
    );
}
extern "C" {
    pub fn file_browser_worker_folder_enter(
        browser: *mut BrowserWorker,
        path: *mut FuriString,
        item_idx: i32,
    );
}
extern "C" {
    pub fn file_browser_worker_is_in_start_folder(browser: *mut BrowserWorker) -> bool;
}
extern "C" {
    pub fn file_browser_worker_folder_exit(browser: *mut BrowserWorker);
}
extern "C" {
    pub fn file_browser_worker_folder_refresh(browser: *mut BrowserWorker, item_idx: i32);
}
extern "C" {
    pub fn file_browser_worker_load(browser: *mut BrowserWorker, offset: u32, count: u32);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Loading {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " Allocate and initialize\n\n This View used to show system is doing some processing\n\n @return     Loading View instance"]
    pub fn loading_alloc() -> *mut Loading;
}
extern "C" {
    #[doc = " Deinitialize and free Loading View\n\n @param      instance  Loading instance"]
    pub fn loading_free(instance: *mut Loading);
}
extern "C" {
    #[doc = " Get Loading view\n\n @param      instance  Loading instance\n\n @return     View instance that can be used for embedding"]
    pub fn loading_get_view(instance: *mut Loading) -> *mut View;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Menu {
    _unused: [u8; 0],
}
#[doc = " Menu Item Callback"]
pub type MenuItemCallback =
    ::core::option::Option<unsafe extern "C" fn(context: *mut core::ffi::c_void, index: u32)>;
extern "C" {
    #[doc = " Menu allocation and initialization\n\n @return     Menu instance"]
    pub fn menu_alloc() -> *mut Menu;
}
extern "C" {
    #[doc = " Free menu\n\n @param      menu  Menu instance"]
    pub fn menu_free(menu: *mut Menu);
}
extern "C" {
    #[doc = " Get Menu view\n\n @param      menu  Menu instance\n\n @return     View instance"]
    pub fn menu_get_view(menu: *mut Menu) -> *mut View;
}
extern "C" {
    #[doc = " Add item to menu\n\n @param      menu      Menu instance\n @param      label     menu item string label\n @param      icon      IconAnimation instance\n @param      index     menu item index\n @param      callback  MenuItemCallback instance\n @param      context   pointer to context"]
    pub fn menu_add_item(
        menu: *mut Menu,
        label: *const core::ffi::c_char,
        icon: *const Icon,
        index: u32,
        callback: MenuItemCallback,
        context: *mut core::ffi::c_void,
    );
}
extern "C" {
    #[doc = " Clean menu\n @note       this function does not free menu instance\n\n @param      menu  Menu instance"]
    pub fn menu_reset(menu: *mut Menu);
}
extern "C" {
    #[doc = " Set current menu item\n\n @param      menu   Menu instance\n @param      index  The index"]
    pub fn menu_set_selected_item(menu: *mut Menu, index: u32);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Popup {
    _unused: [u8; 0],
}
#[doc = " Popup result callback type\n @warning    comes from GUI thread"]
pub type PopupCallback =
    ::core::option::Option<unsafe extern "C" fn(context: *mut core::ffi::c_void)>;
extern "C" {
    #[doc = " Allocate and initialize popup\n\n This popup used to ask simple questions like Yes/\n\n @return     Popup instance"]
    pub fn popup_alloc() -> *mut Popup;
}
extern "C" {
    #[doc = " Deinitialize and free popup\n\n @param      popup  Popup instance"]
    pub fn popup_free(popup: *mut Popup);
}
extern "C" {
    #[doc = " Get popup view\n\n @param      popup  Popup instance\n\n @return     View instance that can be used for embedding"]
    pub fn popup_get_view(popup: *mut Popup) -> *mut View;
}
extern "C" {
    #[doc = " Set popup header text\n\n @param      popup     Popup instance\n @param      callback  PopupCallback"]
    pub fn popup_set_callback(popup: *mut Popup, callback: PopupCallback);
}
extern "C" {
    #[doc = " Set popup context\n\n @param      popup    Popup instance\n @param      context  context pointer, will be passed to result callback"]
    pub fn popup_set_context(popup: *mut Popup, context: *mut core::ffi::c_void);
}
extern "C" {
    #[doc = " Set popup header text\n\n If text is null, popup header will not be rendered\n\n @param      popup       Popup instance\n @param      text        text to be shown, can be multiline\n @param      x           x position\n @param      y           y position\n @param      horizontal  horizontal alignment\n @param      vertical    vertical alignment"]
    pub fn popup_set_header(
        popup: *mut Popup,
        text: *const core::ffi::c_char,
        x: u8,
        y: u8,
        horizontal: Align,
        vertical: Align,
    );
}
extern "C" {
    #[doc = " Set popup text\n\n If text is null, popup text will not be rendered\n\n @param      popup       Popup instance\n @param      text        text to be shown, can be multiline\n @param      x           x position\n @param      y           y position\n @param      horizontal  horizontal alignment\n @param      vertical    vertical alignment"]
    pub fn popup_set_text(
        popup: *mut Popup,
        text: *const core::ffi::c_char,
        x: u8,
        y: u8,
        horizontal: Align,
        vertical: Align,
    );
}
extern "C" {
    #[doc = " Set popup icon\n\n If icon position is negative, popup icon will not be rendered\n\n @param      popup  Popup instance\n @param      x      x position\n @param      y      y position\n @param      icon   pointer to Icon data"]
    pub fn popup_set_icon(popup: *mut Popup, x: u8, y: u8, icon: *const Icon);
}
extern "C" {
    #[doc = " Set popup timeout\n\n @param      popup          Popup instance\n @param      timeout_in_ms  popup timeout value in milliseconds"]
    pub fn popup_set_timeout(popup: *mut Popup, timeout_in_ms: u32);
}
extern "C" {
    #[doc = " Enable popup timeout\n\n @param      popup  Popup instance"]
    pub fn popup_enable_timeout(popup: *mut Popup);
}
extern "C" {
    #[doc = " Disable popup timeout\n\n @param      popup  Popup instance"]
    pub fn popup_disable_timeout(popup: *mut Popup);
}
extern "C" {
    #[doc = " Reset popup instance state\n\n @param       popup Popup instance"]
    pub fn popup_reset(popup: *mut Popup);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Submenu {
    _unused: [u8; 0],
}
pub type SubmenuItemCallback =
    ::core::option::Option<unsafe extern "C" fn(context: *mut core::ffi::c_void, index: u32)>;
extern "C" {
    #[doc = " Allocate and initialize submenu\n\n This submenu is used to select one option\n\n @return     Submenu instance"]
    pub fn submenu_alloc() -> *mut Submenu;
}
extern "C" {
    #[doc = " Deinitialize and free submenu\n\n @param      submenu  Submenu instance"]
    pub fn submenu_free(submenu: *mut Submenu);
}
extern "C" {
    #[doc = " Get submenu view\n\n @param      submenu  Submenu instance\n\n @return     View instance that can be used for embedding"]
    pub fn submenu_get_view(submenu: *mut Submenu) -> *mut View;
}
extern "C" {
    #[doc = " Add item to submenu\n\n @param      submenu           Submenu instance\n @param      label             menu item label\n @param      index             menu item index, used for callback, may be\n                               the same with other items\n @param      callback          menu item callback\n @param      callback_context  menu item callback context"]
    pub fn submenu_add_item(
        submenu: *mut Submenu,
        label: *const core::ffi::c_char,
        index: u32,
        callback: SubmenuItemCallback,
        callback_context: *mut core::ffi::c_void,
    );
}
extern "C" {
    #[doc = " Remove all items from submenu\n\n @param      submenu  Submenu instance"]
    pub fn submenu_reset(submenu: *mut Submenu);
}
extern "C" {
    #[doc = " Set submenu item selector\n\n @param      submenu  Submenu instance\n @param      index    The index"]
    pub fn submenu_set_selected_item(submenu: *mut Submenu, index: u32);
}
extern "C" {
    #[doc = " Set optional header for submenu\n\n @param      submenu  Submenu instance\n @param      header   header to set"]
    pub fn submenu_set_header(submenu: *mut Submenu, header: *const core::ffi::c_char);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TextBox {
    _unused: [u8; 0],
}
pub const TextBoxFont_TextBoxFontText: TextBoxFont = 0;
pub const TextBoxFont_TextBoxFontHex: TextBoxFont = 1;
pub type TextBoxFont = core::ffi::c_uchar;
pub const TextBoxFocus_TextBoxFocusStart: TextBoxFocus = 0;
pub const TextBoxFocus_TextBoxFocusEnd: TextBoxFocus = 1;
pub type TextBoxFocus = core::ffi::c_uchar;
extern "C" {
    #[doc = " Allocate and initialize text_box\n\n @return     TextBox instance"]
    pub fn text_box_alloc() -> *mut TextBox;
}
extern "C" {
    #[doc = " Deinitialize and free text_box\n\n @param      text_box  text_box instance"]
    pub fn text_box_free(text_box: *mut TextBox);
}
extern "C" {
    #[doc = " Get text_box view\n\n @param      text_box  TextBox instance\n\n @return     View instance that can be used for embedding"]
    pub fn text_box_get_view(text_box: *mut TextBox) -> *mut View;
}
extern "C" {
    #[doc = " Clean text_box\n\n @param      text_box  TextBox instance"]
    pub fn text_box_reset(text_box: *mut TextBox);
}
extern "C" {
    #[doc = " Set text for text_box\n\n @param      text_box  TextBox instance\n @param      text      text to set"]
    pub fn text_box_set_text(text_box: *mut TextBox, text: *const core::ffi::c_char);
}
extern "C" {
    #[doc = " Set TextBox font\n\n @param      text_box  TextBox instance\n @param      font      TextBoxFont instance"]
    pub fn text_box_set_font(text_box: *mut TextBox, font: TextBoxFont);
}
extern "C" {
    #[doc = " Set TextBox focus\n @note Use to display from start or from end\n\n @param      text_box  TextBox instance\n @param      focus     TextBoxFocus instance"]
    pub fn text_box_set_focus(text_box: *mut TextBox, focus: TextBoxFocus);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ValidatorIsFile {
    _unused: [u8; 0],
}
extern "C" {
    pub fn validator_is_file_alloc_init(
        app_path_folder: *const core::ffi::c_char,
        app_extension: *const core::ffi::c_char,
        current_name: *const core::ffi::c_char,
    ) -> *mut ValidatorIsFile;
}
extern "C" {
    pub fn validator_is_file_free(instance: *mut ValidatorIsFile);
}
extern "C" {
    pub fn validator_is_file_callback(
        text: *const core::ffi::c_char,
        error: *mut FuriString,
        context: *mut core::ffi::c_void,
    ) -> bool;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TextInput {
    _unused: [u8; 0],
}
pub type TextInputCallback =
    ::core::option::Option<unsafe extern "C" fn(context: *mut core::ffi::c_void)>;
pub type TextInputValidatorCallback = ::core::option::Option<
    unsafe extern "C" fn(
        text: *const core::ffi::c_char,
        error: *mut FuriString,
        context: *mut core::ffi::c_void,
    ) -> bool,
>;
extern "C" {
    #[doc = " Allocate and initialize text input\n\n This text input is used to enter string\n\n @return     TextInput instance"]
    pub fn text_input_alloc() -> *mut TextInput;
}
extern "C" {
    #[doc = " Deinitialize and free text input\n\n @param      text_input  TextInput instance"]
    pub fn text_input_free(text_input: *mut TextInput);
}
extern "C" {
    #[doc = " Clean text input view Note: this function does not free memory\n\n @param      text_input  Text input instance"]
    pub fn text_input_reset(text_input: *mut TextInput);
}
extern "C" {
    #[doc = " Get text input view\n\n @param      text_input  TextInput instance\n\n @return     View instance that can be used for embedding"]
    pub fn text_input_get_view(text_input: *mut TextInput) -> *mut View;
}
extern "C" {
    #[doc = " Set text input result callback\n\n @param      text_input          TextInput instance\n @param      callback            callback fn\n @param      callback_context    callback context\n @param      text_buffer         pointer to YOUR text buffer, that we going\n                                 to modify\n @param      text_buffer_size    YOUR text buffer size in bytes. Max string\n                                 length will be text_buffer_size-1.\n @param      clear_default_text  clear text from text_buffer on first OK\n                                 event"]
    pub fn text_input_set_result_callback(
        text_input: *mut TextInput,
        callback: TextInputCallback,
        callback_context: *mut core::ffi::c_void,
        text_buffer: *mut core::ffi::c_char,
        text_buffer_size: usize,
        clear_default_text: bool,
    );
}
extern "C" {
    pub fn text_input_set_validator(
        text_input: *mut TextInput,
        callback: TextInputValidatorCallback,
        callback_context: *mut core::ffi::c_void,
    );
}
extern "C" {
    pub fn text_input_get_validator_callback(
        text_input: *mut TextInput,
    ) -> TextInputValidatorCallback;
}
extern "C" {
    pub fn text_input_get_validator_callback_context(
        text_input: *mut TextInput,
    ) -> *mut core::ffi::c_void;
}
extern "C" {
    #[doc = " Set text input header text\n\n @param      text_input  TextInput instance\n @param      text        text to be shown"]
    pub fn text_input_set_header_text(text_input: *mut TextInput, text: *const core::ffi::c_char);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VariableItemList {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VariableItem {
    _unused: [u8; 0],
}
pub type VariableItemChangeCallback =
    ::core::option::Option<unsafe extern "C" fn(item: *mut VariableItem)>;
pub type VariableItemListEnterCallback =
    ::core::option::Option<unsafe extern "C" fn(context: *mut core::ffi::c_void, index: u32)>;
extern "C" {
    #[doc = " Allocate and initialize VariableItemList\n\n @return     VariableItemList*"]
    pub fn variable_item_list_alloc() -> *mut VariableItemList;
}
extern "C" {
    #[doc = " Deinitialize and free VariableItemList\n\n @param      variable_item_list  VariableItemList instance"]
    pub fn variable_item_list_free(variable_item_list: *mut VariableItemList);
}
extern "C" {
    #[doc = " Clear all elements from list\n\n @param      variable_item_list  VariableItemList instance"]
    pub fn variable_item_list_reset(variable_item_list: *mut VariableItemList);
}
extern "C" {
    #[doc = " Get VariableItemList View instance\n\n @param      variable_item_list  VariableItemList instance\n\n @return     View instance"]
    pub fn variable_item_list_get_view(variable_item_list: *mut VariableItemList) -> *mut View;
}
extern "C" {
    #[doc = " Add item to VariableItemList\n\n @param      variable_item_list  VariableItemList instance\n @param      label               item name\n @param      values_count        item values count\n @param      change_callback     called on value change in gui\n @param      context             item context\n\n @return     VariableItem* item instance"]
    pub fn variable_item_list_add(
        variable_item_list: *mut VariableItemList,
        label: *const core::ffi::c_char,
        values_count: u8,
        change_callback: VariableItemChangeCallback,
        context: *mut core::ffi::c_void,
    ) -> *mut VariableItem;
}
extern "C" {
    #[doc = " Set enter callback\n\n @param      variable_item_list  VariableItemList instance\n @param      callback            VariableItemListEnterCallback instance\n @param      context             pointer to context"]
    pub fn variable_item_list_set_enter_callback(
        variable_item_list: *mut VariableItemList,
        callback: VariableItemListEnterCallback,
        context: *mut core::ffi::c_void,
    );
}
extern "C" {
    pub fn variable_item_list_set_selected_item(
        variable_item_list: *mut VariableItemList,
        index: u8,
    );
}
extern "C" {
    pub fn variable_item_list_get_selected_item_index(
        variable_item_list: *mut VariableItemList,
    ) -> u8;
}
extern "C" {
    #[doc = " Set item current selected index\n\n @param      item                 VariableItem* instance\n @param      current_value_index  The current value index"]
    pub fn variable_item_set_current_value_index(item: *mut VariableItem, current_value_index: u8);
}
extern "C" {
    #[doc = " Set number of values for item\n\n @param      item                 VariableItem* instance\n @param      values_count         The new values count"]
    pub fn variable_item_set_values_count(item: *mut VariableItem, values_count: u8);
}
extern "C" {
    #[doc = " Set item current selected text\n\n @param      item                VariableItem* instance\n @param      current_value_text  The current value text"]
    pub fn variable_item_set_current_value_text(
        item: *mut VariableItem,
        current_value_text: *const core::ffi::c_char,
    );
}
extern "C" {
    #[doc = " Get item current selected index\n\n @param      item  VariableItem* instance\n\n @return     uint8_t current selected index"]
    pub fn variable_item_get_current_value_index(item: *mut VariableItem) -> u8;
}
extern "C" {
    #[doc = " Get item context\n\n @param      item  VariableItem* instance\n\n @return     void* item context"]
    pub fn variable_item_get_context(item: *mut VariableItem) -> *mut core::ffi::c_void;
}
pub const GuiButtonType_GuiButtonTypeLeft: GuiButtonType = 0;
pub const GuiButtonType_GuiButtonTypeCenter: GuiButtonType = 1;
pub const GuiButtonType_GuiButtonTypeRight: GuiButtonType = 2;
pub type GuiButtonType = core::ffi::c_uchar;
pub type ButtonCallback = ::core::option::Option<
    unsafe extern "C" fn(result: GuiButtonType, type_: InputType, context: *mut core::ffi::c_void),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Widget {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " Allocate Widget that holds Widget Elements\n\n @return     Widget instance"]
    pub fn widget_alloc() -> *mut Widget;
}
extern "C" {
    #[doc = " Free Widget\n @note       this function free allocated Widget Elements\n\n @param      widget  Widget instance"]
    pub fn widget_free(widget: *mut Widget);
}
extern "C" {
    #[doc = " Reset Widget\n\n @param      widget  Widget instance"]
    pub fn widget_reset(widget: *mut Widget);
}
extern "C" {
    #[doc = " Get Widget view\n\n @param      widget  Widget instance\n\n @return     View instance"]
    pub fn widget_get_view(widget: *mut Widget) -> *mut View;
}
extern "C" {
    #[doc = " Add Multi String Element\n\n @param      widget      Widget instance\n @param      x           x coordinate\n @param      y           y coordinate\n @param      horizontal  Align instance\n @param      vertical    Align instance\n @param      font        Font instance\n @param[in]  text        The text"]
    pub fn widget_add_string_multiline_element(
        widget: *mut Widget,
        x: u8,
        y: u8,
        horizontal: Align,
        vertical: Align,
        font: Font,
        text: *const core::ffi::c_char,
    );
}
extern "C" {
    #[doc = " Add String Element\n\n @param      widget      Widget instance\n @param      x           x coordinate\n @param      y           y coordinate\n @param      horizontal  Align instance\n @param      vertical    Align instance\n @param      font        Font instance\n @param[in]  text        The text"]
    pub fn widget_add_string_element(
        widget: *mut Widget,
        x: u8,
        y: u8,
        horizontal: Align,
        vertical: Align,
        font: Font,
        text: *const core::ffi::c_char,
    );
}
extern "C" {
    #[doc = " Add Text Box Element\n\n @param      widget           Widget instance\n @param      x                x coordinate\n @param      y                y coordinate\n @param      width            width to fit text\n @param      height           height to fit text\n @param      horizontal       Align instance\n @param      vertical         Align instance\n @param[in]  text             Formatted text. The following formats are available:\n                               \"\\e#Bold text\\e#\" - bold font is used\n                               \"\\e*Monospaced text\\e*\" - monospaced font is used\n                               \"\\e!Inversed text\\e!\" - white text on black background\n @param      strip_to_dots    Strip text to ... if does not fit to width"]
    pub fn widget_add_text_box_element(
        widget: *mut Widget,
        x: u8,
        y: u8,
        width: u8,
        height: u8,
        horizontal: Align,
        vertical: Align,
        text: *const core::ffi::c_char,
        strip_to_dots: bool,
    );
}
extern "C" {
    #[doc = " Add Text Scroll Element\n\n @param      widget           Widget instance\n @param      x                x coordinate\n @param      y                y coordinate\n @param      width            width to fit text\n @param      height           height to fit text\n @param[in]  text             Formatted text. Default format: align left, Secondary font.\n                              The following formats are available:\n                               \"\\e#Bold text\" - sets bold font before until next '\\n' symbol\n                               \"\\ecCenter-aligned text\" - sets center horizontal align until the next '\\n' symbol\n                               \"\\erRight-aligned text\" - sets right horizontal align until the next '\\n' symbol"]
    pub fn widget_add_text_scroll_element(
        widget: *mut Widget,
        x: u8,
        y: u8,
        width: u8,
        height: u8,
        text: *const core::ffi::c_char,
    );
}
extern "C" {
    #[doc = " Add Button Element\n\n @param      widget       Widget instance\n @param      button_type  GuiButtonType instance\n @param      text         text on allocated button\n @param      callback     ButtonCallback instance\n @param      context      pointer to context"]
    pub fn widget_add_button_element(
        widget: *mut Widget,
        button_type: GuiButtonType,
        text: *const core::ffi::c_char,
        callback: ButtonCallback,
        context: *mut core::ffi::c_void,
    );
}
extern "C" {
    #[doc = " Add Icon Element\n\n @param      widget  Widget instance\n @param      x       top left x coordinate\n @param      y       top left y coordinate\n @param      icon    Icon instance"]
    pub fn widget_add_icon_element(widget: *mut Widget, x: u8, y: u8, icon: *const Icon);
}
extern "C" {
    #[doc = " Add Frame Element\n\n @param      widget  Widget instance\n @param      x       top left x coordinate\n @param      y       top left y coordinate\n @param      width   frame width\n @param      height  frame height\n @param      radius  frame radius"]
    pub fn widget_add_frame_element(
        widget: *mut Widget,
        x: u8,
        y: u8,
        width: u8,
        height: u8,
        radius: u8,
    );
}
pub const SceneManagerEventType_SceneManagerEventTypeCustom: SceneManagerEventType = 0;
pub const SceneManagerEventType_SceneManagerEventTypeBack: SceneManagerEventType = 1;
pub const SceneManagerEventType_SceneManagerEventTypeTick: SceneManagerEventType = 2;
#[doc = " Scene Manager events type"]
pub type SceneManagerEventType = core::ffi::c_uchar;
#[doc = " Scene Manager event"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceneManagerEvent {
    pub type_: SceneManagerEventType,
    pub event: u32,
}
#[test]
fn bindgen_test_layout_SceneManagerEvent() {
    const UNINIT: ::core::mem::MaybeUninit<SceneManagerEvent> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SceneManagerEvent>(),
        8usize,
        concat!("Size of: ", stringify!(SceneManagerEvent))
    );
    assert_eq!(
        ::core::mem::align_of::<SceneManagerEvent>(),
        4usize,
        concat!("Alignment of ", stringify!(SceneManagerEvent))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SceneManagerEvent),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).event) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SceneManagerEvent),
            "::",
            stringify!(event)
        )
    );
}
#[doc = " Prototype for Scene on_enter handler"]
pub type AppSceneOnEnterCallback =
    ::core::option::Option<unsafe extern "C" fn(context: *mut core::ffi::c_void)>;
#[doc = " Prototype for Scene on_event handler"]
pub type AppSceneOnEventCallback = ::core::option::Option<
    unsafe extern "C" fn(context: *mut core::ffi::c_void, event: SceneManagerEvent) -> bool,
>;
#[doc = " Prototype for Scene on_exit handler"]
pub type AppSceneOnExitCallback =
    ::core::option::Option<unsafe extern "C" fn(context: *mut core::ffi::c_void)>;
#[doc = " Scene Manager configuration structure\n Contains array of Scene handlers"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceneManagerHandlers {
    pub on_enter_handlers: *const AppSceneOnEnterCallback,
    pub on_event_handlers: *const AppSceneOnEventCallback,
    pub on_exit_handlers: *const AppSceneOnExitCallback,
    pub scene_num: u32,
}
#[test]
fn bindgen_test_layout_SceneManagerHandlers() {
    const UNINIT: ::core::mem::MaybeUninit<SceneManagerHandlers> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SceneManagerHandlers>(),
        16usize,
        concat!("Size of: ", stringify!(SceneManagerHandlers))
    );
    assert_eq!(
        ::core::mem::align_of::<SceneManagerHandlers>(),
        4usize,
        concat!("Alignment of ", stringify!(SceneManagerHandlers))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).on_enter_handlers) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SceneManagerHandlers),
            "::",
            stringify!(on_enter_handlers)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).on_event_handlers) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SceneManagerHandlers),
            "::",
            stringify!(on_event_handlers)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).on_exit_handlers) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SceneManagerHandlers),
            "::",
            stringify!(on_exit_handlers)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).scene_num) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(SceneManagerHandlers),
            "::",
            stringify!(scene_num)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceneManager {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " Set Scene state\n\n @param      scene_manager  SceneManager instance\n @param      scene_id       Scene ID\n @param      state          Scene new state"]
    pub fn scene_manager_set_scene_state(
        scene_manager: *mut SceneManager,
        scene_id: u32,
        state: u32,
    );
}
extern "C" {
    #[doc = " Get Scene state\n\n @param      scene_manager  SceneManager instance\n @param      scene_id       Scene ID\n\n @return     Scene state"]
    pub fn scene_manager_get_scene_state(scene_manager: *const SceneManager, scene_id: u32) -> u32;
}
extern "C" {
    #[doc = " Scene Manager allocation and configuration\n\n Scene Manager allocates all scenes internally\n\n @param      app_scene_handlers  SceneManagerHandlers instance\n @param      context             context to be set on Scene handlers calls\n\n @return     SceneManager instance"]
    pub fn scene_manager_alloc(
        app_scene_handlers: *const SceneManagerHandlers,
        context: *mut core::ffi::c_void,
    ) -> *mut SceneManager;
}
extern "C" {
    #[doc = " Free Scene Manager with allocated Scenes\n\n @param      scene_manager  SceneManager instance"]
    pub fn scene_manager_free(scene_manager: *mut SceneManager);
}
extern "C" {
    #[doc = " Custom event handler\n\n Calls Scene event handler with Custom event parameter\n\n @param      scene_manager  SceneManager instance\n @param      custom_event   Custom event code\n\n @return     true if event was consumed, false otherwise"]
    pub fn scene_manager_handle_custom_event(
        scene_manager: *mut SceneManager,
        custom_event: u32,
    ) -> bool;
}
extern "C" {
    #[doc = " Back event handler\n\n Calls Scene event handler with Back event parameter\n\n @param      scene_manager  SceneManager instance\n\n @return     true if event was consumed, false otherwise"]
    pub fn scene_manager_handle_back_event(scene_manager: *mut SceneManager) -> bool;
}
extern "C" {
    #[doc = " Tick event handler\n\n Calls Scene event handler with Tick event parameter\n\n @param      scene_manager  SceneManager instance\n @return     true if event was consumed, false otherwise"]
    pub fn scene_manager_handle_tick_event(scene_manager: *mut SceneManager);
}
extern "C" {
    #[doc = " Add and run next Scene\n\n @param      scene_manager  SceneManager instance\n @param      next_scene_id  next Scene ID"]
    pub fn scene_manager_next_scene(scene_manager: *mut SceneManager, next_scene_id: u32);
}
extern "C" {
    #[doc = " Run previous Scene\n\n @param      scene_manager  SceneManager instance\n\n @return     true if previous scene was found, false otherwise"]
    pub fn scene_manager_previous_scene(scene_manager: *mut SceneManager) -> bool;
}
extern "C" {
    #[doc = " Search previous Scene\n\n @param      scene_manager  SceneManager instance\n @param      scene_id       Scene ID\n\n @return     true if previous scene was found, false otherwise"]
    pub fn scene_manager_has_previous_scene(
        scene_manager: *const SceneManager,
        scene_id: u32,
    ) -> bool;
}
extern "C" {
    #[doc = " Search and switch to previous Scene\n\n @param      scene_manager  SceneManager instance\n @param      scene_id       Scene ID\n\n @return     true if previous scene was found, false otherwise"]
    pub fn scene_manager_search_and_switch_to_previous_scene(
        scene_manager: *mut SceneManager,
        scene_id: u32,
    ) -> bool;
}
extern "C" {
    #[doc = " Search and switch to previous Scene, multiple choice\n\n @param      scene_manager    SceneManager instance\n @param      scene_ids        Array of scene IDs\n @param      scene_ids_size   Array of scene IDs size\n\n @return     true if one of previous scenes was found, false otherwise"]
    pub fn scene_manager_search_and_switch_to_previous_scene_one_of(
        scene_manager: *mut SceneManager,
        scene_ids: *const u32,
        scene_ids_size: usize,
    ) -> bool;
}
extern "C" {
    #[doc = " Clear Scene stack and switch to another Scene\n\n @param      scene_manager  SceneManager instance\n @param      scene_id       Scene ID\n\n @return     true if previous scene was found, false otherwise"]
    pub fn scene_manager_search_and_switch_to_another_scene(
        scene_manager: *mut SceneManager,
        scene_id: u32,
    ) -> bool;
}
extern "C" {
    #[doc = " Exit from current scene\n\n @param      scene_manager  SceneManager instance"]
    pub fn scene_manager_stop(scene_manager: *mut SceneManager);
}
#[doc = "< Desktop layer: fullscreen with status bar on top of it. For internal usage."]
pub const ViewDispatcherType_ViewDispatcherTypeDesktop: ViewDispatcherType = 0;
#[doc = "< Window layer: with status bar"]
pub const ViewDispatcherType_ViewDispatcherTypeWindow: ViewDispatcherType = 1;
#[doc = "< Fullscreen layer: without status bar"]
pub const ViewDispatcherType_ViewDispatcherTypeFullscreen: ViewDispatcherType = 2;
#[doc = " ViewDispatcher view_port placement"]
pub type ViewDispatcherType = core::ffi::c_uchar;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ViewDispatcher {
    _unused: [u8; 0],
}
#[doc = " Prototype for custom event callback"]
pub type ViewDispatcherCustomEventCallback = ::core::option::Option<
    unsafe extern "C" fn(context: *mut core::ffi::c_void, event: u32) -> bool,
>;
#[doc = " Prototype for navigation event callback"]
pub type ViewDispatcherNavigationEventCallback =
    ::core::option::Option<unsafe extern "C" fn(context: *mut core::ffi::c_void) -> bool>;
#[doc = " Prototype for tick event callback"]
pub type ViewDispatcherTickEventCallback =
    ::core::option::Option<unsafe extern "C" fn(context: *mut core::ffi::c_void)>;
extern "C" {
    #[doc = " Allocate ViewDispatcher instance\n\n @return     pointer to ViewDispatcher instance"]
    pub fn view_dispatcher_alloc() -> *mut ViewDispatcher;
}
extern "C" {
    #[doc = " Free ViewDispatcher instance\n\n @param      view_dispatcher  pointer to ViewDispatcher"]
    pub fn view_dispatcher_free(view_dispatcher: *mut ViewDispatcher);
}
extern "C" {
    #[doc = " Enable queue support\n\n If queue enabled all input and custom events will be dispatched throw\n internal queue\n\n @param      view_dispatcher  ViewDispatcher instance"]
    pub fn view_dispatcher_enable_queue(view_dispatcher: *mut ViewDispatcher);
}
extern "C" {
    #[doc = " Send custom event\n\n @param      view_dispatcher  ViewDispatcher instance\n @param[in]  event            The event"]
    pub fn view_dispatcher_send_custom_event(view_dispatcher: *mut ViewDispatcher, event: u32);
}
extern "C" {
    #[doc = " Set custom event handler\n\n Called on Custom Event, if it is not consumed by view\n\n @param      view_dispatcher  ViewDispatcher instance\n @param      callback         ViewDispatcherCustomEventCallback instance"]
    pub fn view_dispatcher_set_custom_event_callback(
        view_dispatcher: *mut ViewDispatcher,
        callback: ViewDispatcherCustomEventCallback,
    );
}
extern "C" {
    #[doc = " Set navigation event handler\n\n Called on Input Short Back Event, if it is not consumed by view\n\n @param      view_dispatcher  ViewDispatcher instance\n @param      callback         ViewDispatcherNavigationEventCallback instance"]
    pub fn view_dispatcher_set_navigation_event_callback(
        view_dispatcher: *mut ViewDispatcher,
        callback: ViewDispatcherNavigationEventCallback,
    );
}
extern "C" {
    #[doc = " Set tick event handler\n\n @param      view_dispatcher  ViewDispatcher instance\n @param      callback         ViewDispatcherTickEventCallback\n @param      tick_period      callback call period"]
    pub fn view_dispatcher_set_tick_event_callback(
        view_dispatcher: *mut ViewDispatcher,
        callback: ViewDispatcherTickEventCallback,
        tick_period: u32,
    );
}
extern "C" {
    #[doc = " Set event callback context\n\n @param      view_dispatcher  ViewDispatcher instance\n @param      context          pointer to context"]
    pub fn view_dispatcher_set_event_callback_context(
        view_dispatcher: *mut ViewDispatcher,
        context: *mut core::ffi::c_void,
    );
}
extern "C" {
    #[doc = " Run ViewDispatcher\n\n Use only after queue enabled\n\n @param      view_dispatcher  ViewDispatcher instance"]
    pub fn view_dispatcher_run(view_dispatcher: *mut ViewDispatcher);
}
extern "C" {
    #[doc = " Stop ViewDispatcher\n\n Use only after queue enabled\n\n @param      view_dispatcher  ViewDispatcher instance"]
    pub fn view_dispatcher_stop(view_dispatcher: *mut ViewDispatcher);
}
extern "C" {
    #[doc = " Add view to ViewDispatcher\n\n @param      view_dispatcher  ViewDispatcher instance\n @param      view_id          View id to register\n @param      view             View instance"]
    pub fn view_dispatcher_add_view(
        view_dispatcher: *mut ViewDispatcher,
        view_id: u32,
        view: *mut View,
    );
}
extern "C" {
    #[doc = " Remove view from ViewDispatcher\n\n @param      view_dispatcher  ViewDispatcher instance\n @param      view_id          View id to remove"]
    pub fn view_dispatcher_remove_view(view_dispatcher: *mut ViewDispatcher, view_id: u32);
}
extern "C" {
    #[doc = " Switch to View\n\n @param      view_dispatcher  ViewDispatcher instance\n @param      view_id          View id to register\n @warning    switching may be delayed till input events complementarity\n             reached"]
    pub fn view_dispatcher_switch_to_view(view_dispatcher: *mut ViewDispatcher, view_id: u32);
}
extern "C" {
    #[doc = " Send ViewPort of this ViewDispatcher instance to front\n\n @param      view_dispatcher  ViewDispatcher instance"]
    pub fn view_dispatcher_send_to_front(view_dispatcher: *mut ViewDispatcher);
}
extern "C" {
    #[doc = " Send ViewPort of this ViewDispatcher instance to back\n\n @param      view_dispatcher  ViewDispatcher instance"]
    pub fn view_dispatcher_send_to_back(view_dispatcher: *mut ViewDispatcher);
}
extern "C" {
    #[doc = " Attach ViewDispatcher to GUI\n\n @param      view_dispatcher  ViewDispatcher instance\n @param      gui              GUI instance to attach to\n @param[in]  type             The type"]
    pub fn view_dispatcher_attach_to_gui(
        view_dispatcher: *mut ViewDispatcher,
        gui: *mut Gui,
        type_: ViewDispatcherType,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ViewStack {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " Allocate and init ViewStack\n\n @return      ViewStack instance"]
    pub fn view_stack_alloc() -> *mut ViewStack;
}
extern "C" {
    #[doc = " Free ViewStack instance\n\n @param       view_stack  instance"]
    pub fn view_stack_free(view_stack: *mut ViewStack);
}
extern "C" {
    #[doc = " Get View of ViewStack.\n Should this View to any view manager such as\n ViewDispatcher or ViewHolder.\n\n @param       view_stack  instance"]
    pub fn view_stack_get_view(view_stack: *mut ViewStack) -> *mut View;
}
extern "C" {
    #[doc = " Add View to ViewStack.\n Adds View on top of ViewStack.\n\n @param       view_stack  instance\n @view        view        view to add"]
    pub fn view_stack_add_view(view_stack: *mut ViewStack, view: *mut View);
}
extern "C" {
    #[doc = " Remove any View in ViewStack.\n If no View to remove found - ignore.\n\n @param       view_stack  instance\n @view        view        view to remove"]
    pub fn view_stack_remove_view(view_stack: *mut ViewStack, view: *mut View);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Loader {
    _unused: [u8; 0],
}
pub const LoaderStatus_LoaderStatusOk: LoaderStatus = 0;
pub const LoaderStatus_LoaderStatusErrorAppStarted: LoaderStatus = 1;
pub const LoaderStatus_LoaderStatusErrorUnknownApp: LoaderStatus = 2;
pub const LoaderStatus_LoaderStatusErrorInternal: LoaderStatus = 3;
pub type LoaderStatus = core::ffi::c_uchar;
extern "C" {
    #[doc = " Start application\n @param name - application name\n @param args - application arguments\n @retval true on success"]
    pub fn loader_start(
        instance: *mut Loader,
        name: *const core::ffi::c_char,
        args: *const core::ffi::c_char,
    ) -> LoaderStatus;
}
extern "C" {
    #[doc = " Lock application start\n @retval true on success"]
    pub fn loader_lock(instance: *mut Loader) -> bool;
}
extern "C" {
    #[doc = " Unlock application start"]
    pub fn loader_unlock(instance: *mut Loader);
}
extern "C" {
    #[doc = " Get loader lock status"]
    pub fn loader_is_locked(instance: *const Loader) -> bool;
}
extern "C" {
    #[doc = " Show primary loader"]
    pub fn loader_show_menu();
}
extern "C" {
    #[doc = " Show primary loader"]
    pub fn loader_update_menu();
}
extern "C" {
    #[doc = " Show primary loader"]
    pub fn loader_get_pubsub(instance: *mut Loader) -> *mut FuriPubSub;
}
#[doc = " Cortex timer provides high precision low level expiring timer"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FuriHalCortexTimer {
    pub start: u32,
    pub value: u32,
}
#[test]
fn bindgen_test_layout_FuriHalCortexTimer() {
    const UNINIT: ::core::mem::MaybeUninit<FuriHalCortexTimer> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<FuriHalCortexTimer>(),
        8usize,
        concat!("Size of: ", stringify!(FuriHalCortexTimer))
    );
    assert_eq!(
        ::core::mem::align_of::<FuriHalCortexTimer>(),
        4usize,
        concat!("Alignment of ", stringify!(FuriHalCortexTimer))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).start) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FuriHalCortexTimer),
            "::",
            stringify!(start)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(FuriHalCortexTimer),
            "::",
            stringify!(value)
        )
    );
}
extern "C" {
    #[doc = " Microseconds delay\n\n @param[in]  microseconds  The microseconds to wait"]
    pub fn furi_hal_cortex_delay_us(microseconds: u32);
}
extern "C" {
    #[doc = " Get instructions per microsecond count\n\n @return     instructions per microsecond count"]
    pub fn furi_hal_cortex_instructions_per_microsecond() -> u32;
}
extern "C" {
    #[doc = " Get Timer\n\n @param[in]  timeout_us  The expire timeout in us\n\n @return     The FuriHalCortexTimer"]
    pub fn furi_hal_cortex_timer_get(timeout_us: u32) -> FuriHalCortexTimer;
}
extern "C" {
    #[doc = " Check if timer expired\n\n @param[in]  cortex_timer  The FuriHalCortexTimer\n\n @return     true if expired"]
    pub fn furi_hal_cortex_timer_is_expired(cortex_timer: FuriHalCortexTimer) -> bool;
}
extern "C" {
    #[doc = " Wait for timer expire\n\n @param[in]  cortex_timer  The FuriHalCortexTimer"]
    pub fn furi_hal_cortex_timer_wait(cortex_timer: FuriHalCortexTimer);
}
extern "C" {
    pub fn LL_RCC_GetUSARTClockFreq(USARTxSource: u32) -> u32;
}
extern "C" {
    pub fn LL_RCC_GetLPUARTClockFreq(LPUARTxSource: u32) -> u32;
}
pub const FuriHalClockMcoSourceId_FuriHalClockMcoLse: FuriHalClockMcoSourceId = 0;
pub const FuriHalClockMcoSourceId_FuriHalClockMcoSysclk: FuriHalClockMcoSourceId = 1;
pub const FuriHalClockMcoSourceId_FuriHalClockMcoMsi100k: FuriHalClockMcoSourceId = 2;
pub const FuriHalClockMcoSourceId_FuriHalClockMcoMsi200k: FuriHalClockMcoSourceId = 3;
pub const FuriHalClockMcoSourceId_FuriHalClockMcoMsi400k: FuriHalClockMcoSourceId = 4;
pub const FuriHalClockMcoSourceId_FuriHalClockMcoMsi800k: FuriHalClockMcoSourceId = 5;
pub const FuriHalClockMcoSourceId_FuriHalClockMcoMsi1m: FuriHalClockMcoSourceId = 6;
pub const FuriHalClockMcoSourceId_FuriHalClockMcoMsi2m: FuriHalClockMcoSourceId = 7;
pub const FuriHalClockMcoSourceId_FuriHalClockMcoMsi4m: FuriHalClockMcoSourceId = 8;
pub const FuriHalClockMcoSourceId_FuriHalClockMcoMsi8m: FuriHalClockMcoSourceId = 9;
pub const FuriHalClockMcoSourceId_FuriHalClockMcoMsi16m: FuriHalClockMcoSourceId = 10;
pub const FuriHalClockMcoSourceId_FuriHalClockMcoMsi24m: FuriHalClockMcoSourceId = 11;
pub const FuriHalClockMcoSourceId_FuriHalClockMcoMsi32m: FuriHalClockMcoSourceId = 12;
pub const FuriHalClockMcoSourceId_FuriHalClockMcoMsi48m: FuriHalClockMcoSourceId = 13;
pub type FuriHalClockMcoSourceId = core::ffi::c_uchar;
pub const FuriHalClockMcoDivisorId_FuriHalClockMcoDiv1: FuriHalClockMcoDivisorId = 0;
pub const FuriHalClockMcoDivisorId_FuriHalClockMcoDiv2: FuriHalClockMcoDivisorId = 268435456;
pub const FuriHalClockMcoDivisorId_FuriHalClockMcoDiv4: FuriHalClockMcoDivisorId = 536870912;
pub const FuriHalClockMcoDivisorId_FuriHalClockMcoDiv8: FuriHalClockMcoDivisorId = 805306368;
pub const FuriHalClockMcoDivisorId_FuriHalClockMcoDiv16: FuriHalClockMcoDivisorId = 1073741824;
pub type FuriHalClockMcoDivisorId = core::ffi::c_uint;
extern "C" {
    #[doc = " Enable clock output on MCO pin\n\n @param      source  MCO clock source\n @param      div     MCO clock division"]
    pub fn furi_hal_clock_mco_enable(
        source: FuriHalClockMcoSourceId,
        div: FuriHalClockMcoDivisorId,
    );
}
extern "C" {
    #[doc = " Disable clock output on MCO pin"]
    pub fn furi_hal_clock_mco_disable();
}
#[doc = "< Master key"]
pub const FuriHalCryptoKeyType_FuriHalCryptoKeyTypeMaster: FuriHalCryptoKeyType = 0;
#[doc = "< Simple enencrypted key"]
pub const FuriHalCryptoKeyType_FuriHalCryptoKeyTypeSimple: FuriHalCryptoKeyType = 1;
#[doc = "< Encrypted with Master key"]
pub const FuriHalCryptoKeyType_FuriHalCryptoKeyTypeEncrypted: FuriHalCryptoKeyType = 2;
#[doc = " FuriHalCryptoKey Type"]
pub type FuriHalCryptoKeyType = core::ffi::c_uchar;
pub const FuriHalCryptoKeySize_FuriHalCryptoKeySize128: FuriHalCryptoKeySize = 0;
pub const FuriHalCryptoKeySize_FuriHalCryptoKeySize256: FuriHalCryptoKeySize = 1;
#[doc = " FuriHalCryptoKey Size in bits"]
pub type FuriHalCryptoKeySize = core::ffi::c_uchar;
#[doc = " FuriHalCryptoKey"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FuriHalCryptoKey {
    pub type_: FuriHalCryptoKeyType,
    pub size: FuriHalCryptoKeySize,
    pub data: *mut u8,
}
#[test]
fn bindgen_test_layout_FuriHalCryptoKey() {
    const UNINIT: ::core::mem::MaybeUninit<FuriHalCryptoKey> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<FuriHalCryptoKey>(),
        8usize,
        concat!("Size of: ", stringify!(FuriHalCryptoKey))
    );
    assert_eq!(
        ::core::mem::align_of::<FuriHalCryptoKey>(),
        4usize,
        concat!("Alignment of ", stringify!(FuriHalCryptoKey))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FuriHalCryptoKey),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(FuriHalCryptoKey),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(FuriHalCryptoKey),
            "::",
            stringify!(data)
        )
    );
}
extern "C" {
    pub fn furi_hal_crypto_verify_enclave(keys_nb: *mut u8, valid_keys_nb: *mut u8) -> bool;
}
extern "C" {
    pub fn furi_hal_crypto_verify_key(key_slot: u8) -> bool;
}
extern "C" {
    #[doc = " Store key in crypto storage\n\n @param      key   FuriHalCryptoKey to store. Only Master, Simple or\n                   Encrypted\n @param      slot  pinter to int where store slot number will be saved\n\n @return     true on success"]
    pub fn furi_hal_crypto_store_add_key(key: *mut FuriHalCryptoKey, slot: *mut u8) -> bool;
}
extern "C" {
    #[doc = " Init AES engine and load key from crypto store\n\n @param      slot  store slot number\n @param[in]  iv    pointer to 16 bytes Initialization Vector data\n\n @return     true on success"]
    pub fn furi_hal_crypto_store_load_key(slot: u8, iv: *const u8) -> bool;
}
extern "C" {
    #[doc = " Unload key engine and deinit AES engine\n\n @param      slot  store slot number\n\n @return     true on success"]
    pub fn furi_hal_crypto_store_unload_key(slot: u8) -> bool;
}
extern "C" {
    #[doc = " Encrypt data\n\n @param      input   pointer to input data\n @param      output  pointer to output data\n @param      size    input/output buffer size in bytes\n\n @return     true on success"]
    pub fn furi_hal_crypto_encrypt(input: *const u8, output: *mut u8, size: usize) -> bool;
}
extern "C" {
    #[doc = " Decrypt data\n\n @param      input   pointer to input data\n @param      output  pointer to output data\n @param      size    input/output buffer size in bytes\n\n @return     true on success"]
    pub fn furi_hal_crypto_decrypt(input: *const u8, output: *mut u8, size: usize) -> bool;
}
pub type FuriHalConsoleTxCallback = ::core::option::Option<
    unsafe extern "C" fn(buffer: *const u8, size: usize, context: *mut core::ffi::c_void),
>;
extern "C" {
    pub fn furi_hal_console_init();
}
extern "C" {
    pub fn furi_hal_console_enable();
}
extern "C" {
    pub fn furi_hal_console_disable();
}
extern "C" {
    pub fn furi_hal_console_set_tx_callback(
        callback: FuriHalConsoleTxCallback,
        context: *mut core::ffi::c_void,
    );
}
extern "C" {
    pub fn furi_hal_console_tx(buffer: *const u8, buffer_size: usize);
}
extern "C" {
    pub fn furi_hal_console_tx_with_new_line(buffer: *const u8, buffer_size: usize);
}
extern "C" {
    #[doc = " Printf-like plain uart interface\n @warning Will not work in ISR context\n @param format\n @param ..."]
    pub fn furi_hal_console_printf(format: *const core::ffi::c_char, ...);
}
extern "C" {
    pub fn furi_hal_console_puts(data: *const core::ffi::c_char);
}
extern "C" {
    #[doc = " Enable MCU debug"]
    pub fn furi_hal_debug_enable();
}
extern "C" {
    #[doc = " Disable MCU debug"]
    pub fn furi_hal_debug_disable();
}
extern "C" {
    pub fn furi_hal_os_tick();
}
#[doc = " @brief  SPI Init structures definition"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LL_SPI_InitTypeDef {
    #[doc = "< Specifies the SPI unidirectional or bidirectional data mode.\nThis parameter can be a value of @ref SPI_LL_EC_TRANSFER_MODE.\n\nThis feature can be modified afterwards using unitary function @ref LL_SPI_SetTransferDirection()."]
    pub TransferDirection: u32,
    #[doc = "< Specifies the SPI mode (Master/Slave).\nThis parameter can be a value of @ref SPI_LL_EC_MODE.\n\nThis feature can be modified afterwards using unitary function @ref LL_SPI_SetMode()."]
    pub Mode: u32,
    #[doc = "< Specifies the SPI data width.\nThis parameter can be a value of @ref SPI_LL_EC_DATAWIDTH.\n\nThis feature can be modified afterwards using unitary function @ref LL_SPI_SetDataWidth()."]
    pub DataWidth: u32,
    #[doc = "< Specifies the serial clock steady state.\nThis parameter can be a value of @ref SPI_LL_EC_POLARITY.\n\nThis feature can be modified afterwards using unitary function @ref LL_SPI_SetClockPolarity()."]
    pub ClockPolarity: u32,
    #[doc = "< Specifies the clock active edge for the bit capture.\nThis parameter can be a value of @ref SPI_LL_EC_PHASE.\n\nThis feature can be modified afterwards using unitary function @ref LL_SPI_SetClockPhase()."]
    pub ClockPhase: u32,
    #[doc = "< Specifies whether the NSS signal is managed by hardware (NSS pin) or by software using the SSI bit.\nThis parameter can be a value of @ref SPI_LL_EC_NSS_MODE.\n\nThis feature can be modified afterwards using unitary function @ref LL_SPI_SetNSSMode()."]
    pub NSS: u32,
    #[doc = "< Specifies the BaudRate prescaler value which will be used to configure the transmit and receive SCK clock.\nThis parameter can be a value of @ref SPI_LL_EC_BAUDRATEPRESCALER.\n@note The communication clock is derived from the master clock. The slave clock does not need to be set.\n\nThis feature can be modified afterwards using unitary function @ref LL_SPI_SetBaudRatePrescaler()."]
    pub BaudRate: u32,
    #[doc = "< Specifies whether data transfers start from MSB or LSB bit.\nThis parameter can be a value of @ref SPI_LL_EC_BIT_ORDER.\n\nThis feature can be modified afterwards using unitary function @ref LL_SPI_SetTransferBitOrder()."]
    pub BitOrder: u32,
    #[doc = "< Specifies if the CRC calculation is enabled or not.\nThis parameter can be a value of @ref SPI_LL_EC_CRC_CALCULATION.\n\nThis feature can be modified afterwards using unitary functions @ref LL_SPI_EnableCRC() and @ref LL_SPI_DisableCRC()."]
    pub CRCCalculation: u32,
    #[doc = "< Specifies the polynomial used for the CRC calculation.\nThis parameter must be a number between Min_Data = 0x00 and Max_Data = 0xFFFF.\n\nThis feature can be modified afterwards using unitary function @ref LL_SPI_SetCRCPolynomial()."]
    pub CRCPoly: u32,
}
#[test]
fn bindgen_test_layout_LL_SPI_InitTypeDef() {
    const UNINIT: ::core::mem::MaybeUninit<LL_SPI_InitTypeDef> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<LL_SPI_InitTypeDef>(),
        40usize,
        concat!("Size of: ", stringify!(LL_SPI_InitTypeDef))
    );
    assert_eq!(
        ::core::mem::align_of::<LL_SPI_InitTypeDef>(),
        4usize,
        concat!("Alignment of ", stringify!(LL_SPI_InitTypeDef))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).TransferDirection) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(LL_SPI_InitTypeDef),
            "::",
            stringify!(TransferDirection)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Mode) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(LL_SPI_InitTypeDef),
            "::",
            stringify!(Mode)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).DataWidth) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(LL_SPI_InitTypeDef),
            "::",
            stringify!(DataWidth)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ClockPolarity) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(LL_SPI_InitTypeDef),
            "::",
            stringify!(ClockPolarity)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ClockPhase) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(LL_SPI_InitTypeDef),
            "::",
            stringify!(ClockPhase)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).NSS) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(LL_SPI_InitTypeDef),
            "::",
            stringify!(NSS)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).BaudRate) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(LL_SPI_InitTypeDef),
            "::",
            stringify!(BaudRate)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).BitOrder) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(LL_SPI_InitTypeDef),
            "::",
            stringify!(BitOrder)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CRCCalculation) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(LL_SPI_InitTypeDef),
            "::",
            stringify!(CRCCalculation)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CRCPoly) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(LL_SPI_InitTypeDef),
            "::",
            stringify!(CRCPoly)
        )
    );
}
extern "C" {
    pub fn LL_SPI_Init(
        SPIx: *mut SPI_TypeDef,
        SPI_InitStruct: *mut LL_SPI_InitTypeDef,
    ) -> ErrorStatus;
}
#[doc = "< Bus initialization event, called on system start"]
pub const FuriHalSpiBusEvent_FuriHalSpiBusEventInit: FuriHalSpiBusEvent = 0;
#[doc = "< Bus deinitialization event, called on system stop"]
pub const FuriHalSpiBusEvent_FuriHalSpiBusEventDeinit: FuriHalSpiBusEvent = 1;
#[doc = "< Bus lock event, called before activation"]
pub const FuriHalSpiBusEvent_FuriHalSpiBusEventLock: FuriHalSpiBusEvent = 2;
#[doc = "< Bus unlock event, called after deactivation"]
pub const FuriHalSpiBusEvent_FuriHalSpiBusEventUnlock: FuriHalSpiBusEvent = 3;
#[doc = "< Bus activation event, called before handle activation"]
pub const FuriHalSpiBusEvent_FuriHalSpiBusEventActivate: FuriHalSpiBusEvent = 4;
#[doc = "< Bus deactivation event, called after handle deactivation"]
pub const FuriHalSpiBusEvent_FuriHalSpiBusEventDeactivate: FuriHalSpiBusEvent = 5;
#[doc = " FuriHal spi bus states"]
pub type FuriHalSpiBusEvent = core::ffi::c_uchar;
#[doc = " FuriHal spi bus event callback"]
pub type FuriHalSpiBusEventCallback = ::core::option::Option<
    unsafe extern "C" fn(bus: *mut FuriHalSpiBus, event: FuriHalSpiBusEvent),
>;
#[doc = " FuriHal spi bus"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FuriHalSpiBus {
    pub spi: *mut SPI_TypeDef,
    pub callback: FuriHalSpiBusEventCallback,
    pub current_handle: *mut FuriHalSpiBusHandle,
}
#[test]
fn bindgen_test_layout_FuriHalSpiBus() {
    const UNINIT: ::core::mem::MaybeUninit<FuriHalSpiBus> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<FuriHalSpiBus>(),
        12usize,
        concat!("Size of: ", stringify!(FuriHalSpiBus))
    );
    assert_eq!(
        ::core::mem::align_of::<FuriHalSpiBus>(),
        4usize,
        concat!("Alignment of ", stringify!(FuriHalSpiBus))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).spi) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FuriHalSpiBus),
            "::",
            stringify!(spi)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).callback) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(FuriHalSpiBus),
            "::",
            stringify!(callback)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).current_handle) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(FuriHalSpiBus),
            "::",
            stringify!(current_handle)
        )
    );
}
#[doc = "< Handle init, called on system start, initialize gpio for idle state"]
pub const FuriHalSpiBusHandleEvent_FuriHalSpiBusHandleEventInit: FuriHalSpiBusHandleEvent = 0;
#[doc = "< Handle deinit, called on system stop, deinitialize gpio for default state"]
pub const FuriHalSpiBusHandleEvent_FuriHalSpiBusHandleEventDeinit: FuriHalSpiBusHandleEvent = 1;
#[doc = "< Handle activate: connect gpio and apply bus config"]
pub const FuriHalSpiBusHandleEvent_FuriHalSpiBusHandleEventActivate: FuriHalSpiBusHandleEvent = 2;
#[doc = "< Handle deactivate: disconnect gpio and reset bus config"]
pub const FuriHalSpiBusHandleEvent_FuriHalSpiBusHandleEventDeactivate: FuriHalSpiBusHandleEvent = 3;
#[doc = " FuriHal spi handle states"]
pub type FuriHalSpiBusHandleEvent = core::ffi::c_uchar;
#[doc = " FuriHal spi handle event callback"]
pub type FuriHalSpiBusHandleEventCallback = ::core::option::Option<
    unsafe extern "C" fn(handle: *mut FuriHalSpiBusHandle, event: FuriHalSpiBusHandleEvent),
>;
#[doc = " FuriHal spi handle"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FuriHalSpiBusHandle {
    pub bus: *mut FuriHalSpiBus,
    pub callback: FuriHalSpiBusHandleEventCallback,
    pub miso: *const GpioPin,
    pub mosi: *const GpioPin,
    pub sck: *const GpioPin,
    pub cs: *const GpioPin,
}
#[test]
fn bindgen_test_layout_FuriHalSpiBusHandle() {
    const UNINIT: ::core::mem::MaybeUninit<FuriHalSpiBusHandle> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<FuriHalSpiBusHandle>(),
        24usize,
        concat!("Size of: ", stringify!(FuriHalSpiBusHandle))
    );
    assert_eq!(
        ::core::mem::align_of::<FuriHalSpiBusHandle>(),
        4usize,
        concat!("Alignment of ", stringify!(FuriHalSpiBusHandle))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bus) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FuriHalSpiBusHandle),
            "::",
            stringify!(bus)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).callback) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(FuriHalSpiBusHandle),
            "::",
            stringify!(callback)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).miso) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(FuriHalSpiBusHandle),
            "::",
            stringify!(miso)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).mosi) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(FuriHalSpiBusHandle),
            "::",
            stringify!(mosi)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).sck) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(FuriHalSpiBusHandle),
            "::",
            stringify!(sck)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).cs) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(FuriHalSpiBusHandle),
            "::",
            stringify!(cs)
        )
    );
}
extern "C" {
    #[doc = " Init SD card detect"]
    pub fn hal_sd_detect_init();
}
extern "C" {
    #[doc = " Set SD card detect pin to low"]
    pub fn hal_sd_detect_set_low();
}
extern "C" {
    #[doc = " Get SD card status\n\n @return     true if SD card present, false if SD card not present"]
    pub fn hal_sd_detect() -> bool;
}
extern "C" {
    #[doc = " Pointer to currently used SPI Handle"]
    pub static mut furi_hal_sd_spi_handle: *mut FuriHalSpiBusHandle;
}
#[doc = " @defgroup I2C_LL_ES_INIT I2C Exported Init structure\n @{"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LL_I2C_InitTypeDef {
    #[doc = "< Specifies the peripheral mode.\nThis parameter can be a value of @ref I2C_LL_EC_PERIPHERAL_MODE.\n\nThis feature can be modified afterwards using unitary function\n@ref LL_I2C_SetMode()."]
    pub PeripheralMode: u32,
    #[doc = "< Specifies the SDA setup, hold time and the SCL high, low period values.\nThis parameter must be set by referring to the STM32CubeMX Tool and\nthe helper macro @ref __LL_I2C_CONVERT_TIMINGS().\n\nThis feature can be modified afterwards using unitary function\n@ref LL_I2C_SetTiming()."]
    pub Timing: u32,
    #[doc = "< Enables or disables analog noise filter.\nThis parameter can be a value of @ref I2C_LL_EC_ANALOGFILTER_SELECTION.\n\nThis feature can be modified afterwards using unitary functions\n@ref LL_I2C_EnableAnalogFilter() or LL_I2C_DisableAnalogFilter()."]
    pub AnalogFilter: u32,
    #[doc = "< Configures the digital noise filter.\nThis parameter can be a number between Min_Data = 0x00 and Max_Data = 0x0F.\n\nThis feature can be modified afterwards using unitary function\n@ref LL_I2C_SetDigitalFilter()."]
    pub DigitalFilter: u32,
    #[doc = "< Specifies the device own address 1.\nThis parameter must be a value between Min_Data = 0x00 and Max_Data = 0x3FF.\n\nThis feature can be modified afterwards using unitary function\n@ref LL_I2C_SetOwnAddress1()."]
    pub OwnAddress1: u32,
    #[doc = "< Specifies the ACKnowledge or Non ACKnowledge condition after the address receive\nmatch code or next received byte.\nThis parameter can be a value of @ref I2C_LL_EC_I2C_ACKNOWLEDGE.\n\nThis feature can be modified afterwards using unitary function\n@ref LL_I2C_AcknowledgeNextData()."]
    pub TypeAcknowledge: u32,
    #[doc = "< Specifies the device own address 1 size (7-bit or 10-bit).\nThis parameter can be a value of @ref I2C_LL_EC_OWNADDRESS1.\n\nThis feature can be modified afterwards using unitary function\n@ref LL_I2C_SetOwnAddress1()."]
    pub OwnAddrSize: u32,
}
#[test]
fn bindgen_test_layout_LL_I2C_InitTypeDef() {
    const UNINIT: ::core::mem::MaybeUninit<LL_I2C_InitTypeDef> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<LL_I2C_InitTypeDef>(),
        28usize,
        concat!("Size of: ", stringify!(LL_I2C_InitTypeDef))
    );
    assert_eq!(
        ::core::mem::align_of::<LL_I2C_InitTypeDef>(),
        4usize,
        concat!("Alignment of ", stringify!(LL_I2C_InitTypeDef))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).PeripheralMode) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(LL_I2C_InitTypeDef),
            "::",
            stringify!(PeripheralMode)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Timing) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(LL_I2C_InitTypeDef),
            "::",
            stringify!(Timing)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).AnalogFilter) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(LL_I2C_InitTypeDef),
            "::",
            stringify!(AnalogFilter)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).DigitalFilter) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(LL_I2C_InitTypeDef),
            "::",
            stringify!(DigitalFilter)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).OwnAddress1) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(LL_I2C_InitTypeDef),
            "::",
            stringify!(OwnAddress1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).TypeAcknowledge) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(LL_I2C_InitTypeDef),
            "::",
            stringify!(TypeAcknowledge)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).OwnAddrSize) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(LL_I2C_InitTypeDef),
            "::",
            stringify!(OwnAddrSize)
        )
    );
}
extern "C" {
    #[doc = " @defgroup I2C_LL_EF_Init Initialization and de-initialization functions\n @{"]
    pub fn LL_I2C_Init(
        I2Cx: *mut I2C_TypeDef,
        I2C_InitStruct: *mut LL_I2C_InitTypeDef,
    ) -> ErrorStatus;
}
#[doc = "< Bus initialization event, called on system start"]
pub const FuriHalI2cBusEvent_FuriHalI2cBusEventInit: FuriHalI2cBusEvent = 0;
#[doc = "< Bus deinitialization event, called on system stop"]
pub const FuriHalI2cBusEvent_FuriHalI2cBusEventDeinit: FuriHalI2cBusEvent = 1;
#[doc = "< Bus lock event, called before activation"]
pub const FuriHalI2cBusEvent_FuriHalI2cBusEventLock: FuriHalI2cBusEvent = 2;
#[doc = "< Bus unlock event, called after deactivation"]
pub const FuriHalI2cBusEvent_FuriHalI2cBusEventUnlock: FuriHalI2cBusEvent = 3;
#[doc = "< Bus activation event, called before handle activation"]
pub const FuriHalI2cBusEvent_FuriHalI2cBusEventActivate: FuriHalI2cBusEvent = 4;
#[doc = "< Bus deactivation event, called after handle deactivation"]
pub const FuriHalI2cBusEvent_FuriHalI2cBusEventDeactivate: FuriHalI2cBusEvent = 5;
#[doc = " FuriHal i2c bus states"]
pub type FuriHalI2cBusEvent = core::ffi::c_uchar;
#[doc = " FuriHal i2c bus event callback"]
pub type FuriHalI2cBusEventCallback = ::core::option::Option<
    unsafe extern "C" fn(bus: *mut FuriHalI2cBus, event: FuriHalI2cBusEvent),
>;
#[doc = " FuriHal i2c bus"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FuriHalI2cBus {
    pub i2c: *mut I2C_TypeDef,
    pub current_handle: *mut FuriHalI2cBusHandle,
    pub callback: FuriHalI2cBusEventCallback,
}
#[test]
fn bindgen_test_layout_FuriHalI2cBus() {
    const UNINIT: ::core::mem::MaybeUninit<FuriHalI2cBus> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<FuriHalI2cBus>(),
        12usize,
        concat!("Size of: ", stringify!(FuriHalI2cBus))
    );
    assert_eq!(
        ::core::mem::align_of::<FuriHalI2cBus>(),
        4usize,
        concat!("Alignment of ", stringify!(FuriHalI2cBus))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).i2c) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FuriHalI2cBus),
            "::",
            stringify!(i2c)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).current_handle) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(FuriHalI2cBus),
            "::",
            stringify!(current_handle)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).callback) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(FuriHalI2cBus),
            "::",
            stringify!(callback)
        )
    );
}
#[doc = "< Handle activate: connect gpio and apply bus config"]
pub const FuriHalI2cBusHandleEvent_FuriHalI2cBusHandleEventActivate: FuriHalI2cBusHandleEvent = 0;
#[doc = "< Handle deactivate: disconnect gpio and reset bus config"]
pub const FuriHalI2cBusHandleEvent_FuriHalI2cBusHandleEventDeactivate: FuriHalI2cBusHandleEvent = 1;
#[doc = " FuriHal i2c handle states"]
pub type FuriHalI2cBusHandleEvent = core::ffi::c_uchar;
#[doc = " FuriHal i2c handle event callback"]
pub type FuriHalI2cBusHandleEventCallback = ::core::option::Option<
    unsafe extern "C" fn(handle: *mut FuriHalI2cBusHandle, event: FuriHalI2cBusHandleEvent),
>;
#[doc = " FuriHal i2c handle"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FuriHalI2cBusHandle {
    pub bus: *mut FuriHalI2cBus,
    pub callback: FuriHalI2cBusHandleEventCallback,
}
#[test]
fn bindgen_test_layout_FuriHalI2cBusHandle() {
    const UNINIT: ::core::mem::MaybeUninit<FuriHalI2cBusHandle> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<FuriHalI2cBusHandle>(),
        8usize,
        concat!("Size of: ", stringify!(FuriHalI2cBusHandle))
    );
    assert_eq!(
        ::core::mem::align_of::<FuriHalI2cBusHandle>(),
        4usize,
        concat!("Alignment of ", stringify!(FuriHalI2cBusHandle))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bus) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FuriHalI2cBusHandle),
            "::",
            stringify!(bus)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).callback) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(FuriHalI2cBusHandle),
            "::",
            stringify!(callback)
        )
    );
}
extern "C" {
    #[doc = " Internal(power) i2c bus, I2C1, under reset when not used"]
    pub static mut furi_hal_i2c_bus_power: FuriHalI2cBus;
}
extern "C" {
    #[doc = " External i2c bus, I2C3, under reset when not used"]
    pub static mut furi_hal_i2c_bus_external: FuriHalI2cBus;
}
extern "C" {
    #[doc = " Handle for internal(power) i2c bus\n Bus: furi_hal_i2c_bus_external\n Pins: PA9(SCL) / PA10(SDA), float on release\n Params: 400khz"]
    pub static mut furi_hal_i2c_handle_power: FuriHalI2cBusHandle;
}
extern "C" {
    #[doc = " Handle for external i2c bus\n Bus: furi_hal_i2c_bus_external\n Pins: PC0(SCL) / PC1(SDA), float on release\n Params: 100khz"]
    pub static mut furi_hal_i2c_handle_external: FuriHalI2cBusHandle;
}
extern "C" {
    #[doc = " Acquire i2c bus handle\n\n @return     Instance of FuriHalI2cBus"]
    pub fn furi_hal_i2c_acquire(handle: *mut FuriHalI2cBusHandle);
}
extern "C" {
    #[doc = " Release i2c bus handle\n\n @param      bus   instance of FuriHalI2cBus aquired in `furi_hal_i2c_acquire`"]
    pub fn furi_hal_i2c_release(handle: *mut FuriHalI2cBusHandle);
}
extern "C" {
    #[doc = " Perform I2C tx transfer\n\n @param      handle   pointer to FuriHalI2cBusHandle instance\n @param      address  I2C slave address\n @param      data     pointer to data buffer\n @param      size     size of data buffer\n @param      timeout  timeout in ticks\n\n @return     true on successful transfer, false otherwise"]
    pub fn furi_hal_i2c_tx(
        handle: *mut FuriHalI2cBusHandle,
        address: u8,
        data: *const u8,
        size: u8,
        timeout: u32,
    ) -> bool;
}
extern "C" {
    #[doc = " Perform I2C rx transfer\n\n @param      handle   pointer to FuriHalI2cBusHandle instance\n @param      address  I2C slave address\n @param      data     pointer to data buffer\n @param      size     size of data buffer\n @param      timeout  timeout in ticks\n\n @return     true on successful transfer, false otherwise"]
    pub fn furi_hal_i2c_rx(
        handle: *mut FuriHalI2cBusHandle,
        address: u8,
        data: *mut u8,
        size: u8,
        timeout: u32,
    ) -> bool;
}
extern "C" {
    #[doc = " Perform I2C tx and rx transfers\n\n @param      handle   pointer to FuriHalI2cBusHandle instance\n @param      address  I2C slave address\n @param      tx_data  pointer to tx data buffer\n @param      tx_size  size of tx data buffer\n @param      rx_data  pointer to rx data buffer\n @param      rx_size  size of rx data buffer\n @param      timeout  timeout in ticks\n\n @return     true on successful transfer, false otherwise"]
    pub fn furi_hal_i2c_trx(
        handle: *mut FuriHalI2cBusHandle,
        address: u8,
        tx_data: *const u8,
        tx_size: u8,
        rx_data: *mut u8,
        rx_size: u8,
        timeout: u32,
    ) -> bool;
}
extern "C" {
    #[doc = " Check if I2C device presents on bus\n\n @param      handle   pointer to FuriHalI2cBusHandle instance\n @param      i2c_addr I2C slave address\n @param      timeout  timeout in ticks\n\n @return     true if device present and is ready, false otherwise"]
    pub fn furi_hal_i2c_is_device_ready(
        handle: *mut FuriHalI2cBusHandle,
        i2c_addr: u8,
        timeout: u32,
    ) -> bool;
}
extern "C" {
    #[doc = " Perform I2C device register read (8-bit)\n\n @param      handle   pointer to FuriHalI2cBusHandle instance\n @param      i2c_addr I2C slave address\n @param      reg_addr register address\n @param      data     pointer to register value\n @param      timeout  timeout in ticks\n\n @return     true on successful transfer, false otherwise"]
    pub fn furi_hal_i2c_read_reg_8(
        handle: *mut FuriHalI2cBusHandle,
        i2c_addr: u8,
        reg_addr: u8,
        data: *mut u8,
        timeout: u32,
    ) -> bool;
}
extern "C" {
    #[doc = " Perform I2C device register read (16-bit)\n\n @param      handle   pointer to FuriHalI2cBusHandle instance\n @param      i2c_addr I2C slave address\n @param      reg_addr register address\n @param      data     pointer to register value\n @param      timeout  timeout in ticks\n\n @return     true on successful transfer, false otherwise"]
    pub fn furi_hal_i2c_read_reg_16(
        handle: *mut FuriHalI2cBusHandle,
        i2c_addr: u8,
        reg_addr: u8,
        data: *mut u16,
        timeout: u32,
    ) -> bool;
}
extern "C" {
    #[doc = " Perform I2C device memory read\n\n @param      handle   pointer to FuriHalI2cBusHandle instance\n @param      i2c_addr I2C slave address\n @param      mem_addr memory start address\n @param      data     pointer to data buffer\n @param      len      size of data buffer\n @param      timeout  timeout in ticks\n\n @return     true on successful transfer, false otherwise"]
    pub fn furi_hal_i2c_read_mem(
        handle: *mut FuriHalI2cBusHandle,
        i2c_addr: u8,
        mem_addr: u8,
        data: *mut u8,
        len: u8,
        timeout: u32,
    ) -> bool;
}
extern "C" {
    #[doc = " Perform I2C device register write (8-bit)\n\n @param      handle   pointer to FuriHalI2cBusHandle instance\n @param      i2c_addr I2C slave address\n @param      reg_addr register address\n @param      data     register value\n @param      timeout  timeout in ticks\n\n @return     true on successful transfer, false otherwise"]
    pub fn furi_hal_i2c_write_reg_8(
        handle: *mut FuriHalI2cBusHandle,
        i2c_addr: u8,
        reg_addr: u8,
        data: u8,
        timeout: u32,
    ) -> bool;
}
extern "C" {
    #[doc = " Perform I2C device register write (16-bit)\n\n @param      handle   pointer to FuriHalI2cBusHandle instance\n @param      i2c_addr I2C slave address\n @param      reg_addr register address\n @param      data     register value\n @param      timeout  timeout in ticks\n\n @return     true on successful transfer, false otherwise"]
    pub fn furi_hal_i2c_write_reg_16(
        handle: *mut FuriHalI2cBusHandle,
        i2c_addr: u8,
        reg_addr: u8,
        data: u16,
        timeout: u32,
    ) -> bool;
}
extern "C" {
    #[doc = " Perform I2C device memory\n\n @param      handle   pointer to FuriHalI2cBusHandle instance\n @param      i2c_addr I2C slave address\n @param      mem_addr memory start address\n @param      data     pointer to data buffer\n @param      len      size of data buffer\n @param      timeout  timeout in ticks\n\n @return     true on successful transfer, false otherwise"]
    pub fn furi_hal_i2c_write_mem(
        handle: *mut FuriHalI2cBusHandle,
        i2c_addr: u8,
        mem_addr: u8,
        data: *mut u8,
        len: u8,
        timeout: u32,
    ) -> bool;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FuriHalRegionBand {
    pub start: u32,
    pub end: u32,
    pub power_limit: i8,
    pub duty_cycle: u8,
}
#[test]
fn bindgen_test_layout_FuriHalRegionBand() {
    const UNINIT: ::core::mem::MaybeUninit<FuriHalRegionBand> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<FuriHalRegionBand>(),
        12usize,
        concat!("Size of: ", stringify!(FuriHalRegionBand))
    );
    assert_eq!(
        ::core::mem::align_of::<FuriHalRegionBand>(),
        4usize,
        concat!("Alignment of ", stringify!(FuriHalRegionBand))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).start) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FuriHalRegionBand),
            "::",
            stringify!(start)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).end) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(FuriHalRegionBand),
            "::",
            stringify!(end)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).power_limit) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(FuriHalRegionBand),
            "::",
            stringify!(power_limit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).duty_cycle) as usize - ptr as usize },
        9usize,
        concat!(
            "Offset of field: ",
            stringify!(FuriHalRegionBand),
            "::",
            stringify!(duty_cycle)
        )
    );
}
#[repr(C)]
#[derive(Debug)]
pub struct FuriHalRegion {
    pub country_code: [core::ffi::c_char; 4usize],
    pub bands_count: u16,
    pub bands: __IncompleteArrayField<FuriHalRegionBand>,
}
#[test]
fn bindgen_test_layout_FuriHalRegion() {
    const UNINIT: ::core::mem::MaybeUninit<FuriHalRegion> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<FuriHalRegion>(),
        8usize,
        concat!("Size of: ", stringify!(FuriHalRegion))
    );
    assert_eq!(
        ::core::mem::align_of::<FuriHalRegion>(),
        4usize,
        concat!("Alignment of ", stringify!(FuriHalRegion))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).country_code) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FuriHalRegion),
            "::",
            stringify!(country_code)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bands_count) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(FuriHalRegion),
            "::",
            stringify!(bands_count)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bands) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(FuriHalRegion),
            "::",
            stringify!(bands)
        )
    );
}
extern "C" {
    #[doc = " Get Region Data.\n\n Region data may be allocated in Flash or in RAM.\n Keep in mind that we don't do memory management on our side.\n\n @return     pointer to FuriHalRegion instance (in RAM or Flash, check before freeing on region update)"]
    pub fn furi_hal_region_get() -> *const FuriHalRegion;
}
extern "C" {
    #[doc = " Set device region data\n\n @param      region  pointer to the FuriHalRegion"]
    pub fn furi_hal_region_set(region: *mut FuriHalRegion);
}
extern "C" {
    #[doc = " Check if region data provisioned\n\n @return     true if provisioned, false otherwise"]
    pub fn furi_hal_region_is_provisioned() -> bool;
}
extern "C" {
    #[doc = " Get region name\n\n 2 letter Region code according to iso 3166 standard\n There are 2 extra values that we use in special cases:\n - \"00\" - developer edition, unlocked\n - \"WW\" - world wide, region provisioned by default\n - \"--\" - no provisioned region\n\n @return     Pointer to string"]
    pub fn furi_hal_region_get_name() -> *const core::ffi::c_char;
}
extern "C" {
    #[doc = " Сheck if transmission is allowed on this frequency for your flipper region\n\n @param[in]  frequency  The frequency\n @param      value  frequency in Hz\n\n @return     true if allowed"]
    pub fn furi_hal_region_is_frequency_allowed(frequency: u32) -> bool;
}
extern "C" {
    #[doc = " Get band data for frequency\n\n\n\n @param[in]  frequency  The frequency\n\n @return     { description_of_the_return_value }"]
    pub fn furi_hal_region_get_band(frequency: u32) -> *const FuriHalRegionBand;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FuriHalRtcDateTime {
    #[doc = "< Hour in 24H format: 0-23"]
    pub hour: u8,
    #[doc = "< Minute: 0-59"]
    pub minute: u8,
    #[doc = "< Second: 0-59"]
    pub second: u8,
    #[doc = "< Current day: 1-31"]
    pub day: u8,
    #[doc = "< Current month: 1-12"]
    pub month: u8,
    #[doc = "< Current year: 2000-2099"]
    pub year: u16,
    #[doc = "< Current weekday: 1-7"]
    pub weekday: u8,
}
#[test]
fn bindgen_test_layout_FuriHalRtcDateTime() {
    const UNINIT: ::core::mem::MaybeUninit<FuriHalRtcDateTime> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<FuriHalRtcDateTime>(),
        10usize,
        concat!("Size of: ", stringify!(FuriHalRtcDateTime))
    );
    assert_eq!(
        ::core::mem::align_of::<FuriHalRtcDateTime>(),
        2usize,
        concat!("Alignment of ", stringify!(FuriHalRtcDateTime))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).hour) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FuriHalRtcDateTime),
            "::",
            stringify!(hour)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).minute) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(FuriHalRtcDateTime),
            "::",
            stringify!(minute)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).second) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(FuriHalRtcDateTime),
            "::",
            stringify!(second)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).day) as usize - ptr as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(FuriHalRtcDateTime),
            "::",
            stringify!(day)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).month) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(FuriHalRtcDateTime),
            "::",
            stringify!(month)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).year) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(FuriHalRtcDateTime),
            "::",
            stringify!(year)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).weekday) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(FuriHalRtcDateTime),
            "::",
            stringify!(weekday)
        )
    );
}
pub const FuriHalRtcFlag_FuriHalRtcFlagDebug: FuriHalRtcFlag = 1;
pub const FuriHalRtcFlag_FuriHalRtcFlagFactoryReset: FuriHalRtcFlag = 2;
pub const FuriHalRtcFlag_FuriHalRtcFlagLock: FuriHalRtcFlag = 4;
pub const FuriHalRtcFlag_FuriHalRtcFlagC2Update: FuriHalRtcFlag = 8;
pub type FuriHalRtcFlag = core::ffi::c_uchar;
#[doc = "< Normal boot mode, default value"]
pub const FuriHalRtcBootMode_FuriHalRtcBootModeNormal: FuriHalRtcBootMode = 0;
#[doc = "< Boot to DFU (MCU bootloader by ST)"]
pub const FuriHalRtcBootMode_FuriHalRtcBootModeDfu: FuriHalRtcBootMode = 1;
#[doc = "< Boot to Update, pre update"]
pub const FuriHalRtcBootMode_FuriHalRtcBootModePreUpdate: FuriHalRtcBootMode = 2;
#[doc = "< Boot to Update, main"]
pub const FuriHalRtcBootMode_FuriHalRtcBootModeUpdate: FuriHalRtcBootMode = 3;
#[doc = "< Boot to Update, post update"]
pub const FuriHalRtcBootMode_FuriHalRtcBootModePostUpdate: FuriHalRtcBootMode = 4;
pub type FuriHalRtcBootMode = core::ffi::c_uchar;
#[doc = "< Disable allocation tracking"]
pub const FuriHalRtcHeapTrackMode_FuriHalRtcHeapTrackModeNone: FuriHalRtcHeapTrackMode = 0;
#[doc = "< Enable allocation tracking for main application thread"]
pub const FuriHalRtcHeapTrackMode_FuriHalRtcHeapTrackModeMain: FuriHalRtcHeapTrackMode = 1;
#[doc = "< Enable allocation tracking for main and children application threads"]
pub const FuriHalRtcHeapTrackMode_FuriHalRtcHeapTrackModeTree: FuriHalRtcHeapTrackMode = 2;
#[doc = "< Enable allocation tracking for all threads"]
pub const FuriHalRtcHeapTrackMode_FuriHalRtcHeapTrackModeAll: FuriHalRtcHeapTrackMode = 3;
pub type FuriHalRtcHeapTrackMode = core::ffi::c_uchar;
#[doc = "< RTC structure header"]
pub const FuriHalRtcRegister_FuriHalRtcRegisterHeader: FuriHalRtcRegister = 0;
#[doc = "< Various system bits"]
pub const FuriHalRtcRegister_FuriHalRtcRegisterSystem: FuriHalRtcRegister = 1;
#[doc = "< Pointer to Version"]
pub const FuriHalRtcRegister_FuriHalRtcRegisterVersion: FuriHalRtcRegister = 2;
#[doc = "< LFS geometry fingerprint"]
pub const FuriHalRtcRegister_FuriHalRtcRegisterLfsFingerprint: FuriHalRtcRegister = 3;
#[doc = "< Pointer to last fault message"]
pub const FuriHalRtcRegister_FuriHalRtcRegisterFaultData: FuriHalRtcRegister = 4;
#[doc = "< Failed pins count"]
pub const FuriHalRtcRegister_FuriHalRtcRegisterPinFails: FuriHalRtcRegister = 5;
pub const FuriHalRtcRegister_FuriHalRtcRegisterUpdateFolderFSIndex: FuriHalRtcRegister = 6;
#[doc = "< Service value, do not use"]
pub const FuriHalRtcRegister_FuriHalRtcRegisterMAX: FuriHalRtcRegister = 7;
pub type FuriHalRtcRegister = core::ffi::c_uchar;
#[doc = "< Metric measurement units"]
pub const FuriHalRtcLocaleUnits_FuriHalRtcLocaleUnitsMetric: FuriHalRtcLocaleUnits = 0;
#[doc = "< Imperial measurement units"]
pub const FuriHalRtcLocaleUnits_FuriHalRtcLocaleUnitsImperial: FuriHalRtcLocaleUnits = 1;
pub type FuriHalRtcLocaleUnits = core::ffi::c_uchar;
#[doc = "< 24-hour format"]
pub const FuriHalRtcLocaleTimeFormat_FuriHalRtcLocaleTimeFormat24h: FuriHalRtcLocaleTimeFormat = 0;
#[doc = "< 12-hour format"]
pub const FuriHalRtcLocaleTimeFormat_FuriHalRtcLocaleTimeFormat12h: FuriHalRtcLocaleTimeFormat = 1;
pub type FuriHalRtcLocaleTimeFormat = core::ffi::c_uchar;
#[doc = "< Day/Month/Year"]
pub const FuriHalRtcLocaleDateFormat_FuriHalRtcLocaleDateFormatDMY: FuriHalRtcLocaleDateFormat = 0;
#[doc = "< Month/Day/Year"]
pub const FuriHalRtcLocaleDateFormat_FuriHalRtcLocaleDateFormatMDY: FuriHalRtcLocaleDateFormat = 1;
#[doc = "< Year/Month/Day"]
pub const FuriHalRtcLocaleDateFormat_FuriHalRtcLocaleDateFormatYMD: FuriHalRtcLocaleDateFormat = 2;
pub type FuriHalRtcLocaleDateFormat = core::ffi::c_uchar;
extern "C" {
    #[doc = " Get RTC register content\n\n @param[in]  reg   The register identifier\n\n @return     content of the register"]
    pub fn furi_hal_rtc_get_register(reg: FuriHalRtcRegister) -> u32;
}
extern "C" {
    #[doc = " Set register content\n\n @param[in]  reg    The register identifier\n @param[in]  value  The value to store into register"]
    pub fn furi_hal_rtc_set_register(reg: FuriHalRtcRegister, value: u32);
}
extern "C" {
    #[doc = " Set Log Level value\n\n @param[in]  level  The level to store"]
    pub fn furi_hal_rtc_set_log_level(level: u8);
}
extern "C" {
    #[doc = " Get Log Level value\n\n @return     The Log Level value"]
    pub fn furi_hal_rtc_get_log_level() -> u8;
}
extern "C" {
    #[doc = " Set RTC Flag\n\n @param[in]  flag  The flag to set"]
    pub fn furi_hal_rtc_set_flag(flag: FuriHalRtcFlag);
}
extern "C" {
    #[doc = " Reset RTC Flag\n\n @param[in]  flag  The flag to reset"]
    pub fn furi_hal_rtc_reset_flag(flag: FuriHalRtcFlag);
}
extern "C" {
    #[doc = " Check if RTC Flag is set\n\n @param[in]  flag  The flag to check\n\n @return     true if set"]
    pub fn furi_hal_rtc_is_flag_set(flag: FuriHalRtcFlag) -> bool;
}
extern "C" {
    #[doc = " Set RTC boot mode\n\n @param[in]  mode  The mode to set"]
    pub fn furi_hal_rtc_set_boot_mode(mode: FuriHalRtcBootMode);
}
extern "C" {
    #[doc = " Get RTC boot mode\n\n @return     The RTC boot mode."]
    pub fn furi_hal_rtc_get_boot_mode() -> FuriHalRtcBootMode;
}
extern "C" {
    #[doc = " Set Heap Track mode\n\n @param[in]  mode  The mode to set"]
    pub fn furi_hal_rtc_set_heap_track_mode(mode: FuriHalRtcHeapTrackMode);
}
extern "C" {
    #[doc = " Get RTC Heap Track mode\n\n @return     The RTC heap track mode."]
    pub fn furi_hal_rtc_get_heap_track_mode() -> FuriHalRtcHeapTrackMode;
}
extern "C" {
    #[doc = " Set locale units\n\n @param[in]  mode  The RTC Locale Units"]
    pub fn furi_hal_rtc_set_locale_units(value: FuriHalRtcLocaleUnits);
}
extern "C" {
    #[doc = " Get RTC Locale Units\n\n @return     The RTC Locale Units."]
    pub fn furi_hal_rtc_get_locale_units() -> FuriHalRtcLocaleUnits;
}
extern "C" {
    #[doc = " Set RTC Locale Time Format\n\n @param[in]  value  The RTC Locale Time Format"]
    pub fn furi_hal_rtc_set_locale_timeformat(value: FuriHalRtcLocaleTimeFormat);
}
extern "C" {
    #[doc = " Get RTC Locale Time Format\n\n @return     The RTC Locale Time Format."]
    pub fn furi_hal_rtc_get_locale_timeformat() -> FuriHalRtcLocaleTimeFormat;
}
extern "C" {
    #[doc = " Set RTC Locale Date Format\n\n @param[in]  value  The RTC Locale Date Format"]
    pub fn furi_hal_rtc_set_locale_dateformat(value: FuriHalRtcLocaleDateFormat);
}
extern "C" {
    #[doc = " Get RTC Locale Date Format\n\n @return     The RTC Locale Date Format"]
    pub fn furi_hal_rtc_get_locale_dateformat() -> FuriHalRtcLocaleDateFormat;
}
extern "C" {
    #[doc = " Set RTC Date Time\n\n @param      datetime  The date time to set"]
    pub fn furi_hal_rtc_set_datetime(datetime: *mut FuriHalRtcDateTime);
}
extern "C" {
    #[doc = " Get RTC Date Time\n\n @param      datetime  The datetime"]
    pub fn furi_hal_rtc_get_datetime(datetime: *mut FuriHalRtcDateTime);
}
extern "C" {
    #[doc = " Validate Date Time\n\n @param      datetime  The datetime to validate\n\n @return     { description_of_the_return_value }"]
    pub fn furi_hal_rtc_validate_datetime(datetime: *mut FuriHalRtcDateTime) -> bool;
}
extern "C" {
    #[doc = " Set RTC Fault Data\n\n @param[in]  value  The value"]
    pub fn furi_hal_rtc_set_fault_data(value: u32);
}
extern "C" {
    #[doc = " Get RTC Fault Data\n\n @return     RTC Fault Data value"]
    pub fn furi_hal_rtc_get_fault_data() -> u32;
}
extern "C" {
    #[doc = " Set Pin Fails count\n\n @param[in]  value  The Pin Fails count"]
    pub fn furi_hal_rtc_set_pin_fails(value: u32);
}
extern "C" {
    #[doc = " Get Pin Fails count\n\n @return     Pin Fails Count"]
    pub fn furi_hal_rtc_get_pin_fails() -> u32;
}
extern "C" {
    #[doc = " Get UNIX Timestamp\n\n @return     Unix Timestamp in seconds from UNIX epoch start"]
    pub fn furi_hal_rtc_get_timestamp() -> u32;
}
extern "C" {
    #[doc = " Convert DateTime to UNIX timestamp\n\n @param      datetime  The datetime\n\n @return     UNIX Timestamp in seconds from UNIX epoch start"]
    pub fn furi_hal_rtc_datetime_to_timestamp(datetime: *mut FuriHalRtcDateTime) -> u32;
}
extern "C" {
    #[doc = " Acquire speaker ownership\n\n @warning    You must acquire speaker ownership before use\n\n @param      timeout  Timeout during which speaker ownership must be acquired\n\n @return     bool  returns true on success"]
    pub fn furi_hal_speaker_acquire(timeout: u32) -> bool;
}
extern "C" {
    #[doc = " Release speaker ownership\n\n @warning    You must release speaker ownership after use"]
    pub fn furi_hal_speaker_release();
}
extern "C" {
    #[doc = " Check current process speaker ownership\n\n @warning    always returns true if called from ISR\n\n @return     bool returns true if process owns speaker"]
    pub fn furi_hal_speaker_is_mine() -> bool;
}
extern "C" {
    #[doc = " Play a note\n\n @warning    no ownership check if called from ISR\n\n @param      frequency  The frequency\n @param      volume     The volume"]
    pub fn furi_hal_speaker_start(frequency: f32, volume: f32);
}
extern "C" {
    #[doc = " Set volume\n\n @warning    no ownership check if called from ISR\n\n @param      volume  The volume"]
    pub fn furi_hal_speaker_set_volume(volume: f32);
}
extern "C" {
    #[doc = " Stop playback\n\n @warning    no ownership check if called from ISR"]
    pub fn furi_hal_speaker_stop();
}
extern "C" {
    #[doc = " Set light value\n\n @param      light  Light\n @param      value  light brightness [0-255]"]
    pub fn furi_hal_light_set(light: Light, value: u8);
}
extern "C" {
    #[doc = " Start hardware LED blinking mode\n\n @param      light  Light\n @param      brightness  light brightness [0-255]\n @param      on_time  LED on time in ms\n @param      period  LED blink period in ms"]
    pub fn furi_hal_light_blink_start(light: Light, brightness: u8, on_time: u16, period: u16);
}
extern "C" {
    #[doc = " Stop hardware LED blinking mode"]
    pub fn furi_hal_light_blink_stop();
}
extern "C" {
    #[doc = " Set color in hardware LED blinking mode\n\n @param      light  Light"]
    pub fn furi_hal_light_blink_set_color(light: Light);
}
extern "C" {
    #[doc = " Execute sequence\n\n @param      sequence  Sequence to execute"]
    pub fn furi_hal_light_sequence(sequence: *const core::ffi::c_char);
}
#[doc = " Callback type called every time another key-value pair of device information is ready\n\n @param      key[in]      device information type identifier\n @param      value[in]    device information value\n @param      last[in]     whether the passed key-value pair is the last one\n @param      context[in]  to pass to callback"]
pub type PropertyValueCallback = ::core::option::Option<
    unsafe extern "C" fn(
        key: *const core::ffi::c_char,
        value: *const core::ffi::c_char,
        last: bool,
        context: *mut core::ffi::c_void,
    ),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PropertyValueContext {
    #[doc = "< key string buffer, must be initialised before use"]
    pub key: *mut FuriString,
    #[doc = "< value string buffer, must be initialised before use"]
    pub value: *mut FuriString,
    #[doc = "< output callback function"]
    pub out: PropertyValueCallback,
    #[doc = "< separator character between key parts"]
    pub sep: core::ffi::c_char,
    #[doc = "< flag to indicate last element"]
    pub last: bool,
    #[doc = "< user-defined context, passed through to out callback"]
    pub context: *mut core::ffi::c_void,
}
#[test]
fn bindgen_test_layout_PropertyValueContext() {
    const UNINIT: ::core::mem::MaybeUninit<PropertyValueContext> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<PropertyValueContext>(),
        20usize,
        concat!("Size of: ", stringify!(PropertyValueContext))
    );
    assert_eq!(
        ::core::mem::align_of::<PropertyValueContext>(),
        4usize,
        concat!("Alignment of ", stringify!(PropertyValueContext))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).key) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PropertyValueContext),
            "::",
            stringify!(key)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(PropertyValueContext),
            "::",
            stringify!(value)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).out) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(PropertyValueContext),
            "::",
            stringify!(out)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).sep) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(PropertyValueContext),
            "::",
            stringify!(sep)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).last) as usize - ptr as usize },
        13usize,
        concat!(
            "Offset of field: ",
            stringify!(PropertyValueContext),
            "::",
            stringify!(last)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).context) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(PropertyValueContext),
            "::",
            stringify!(context)
        )
    );
}
extern "C" {
    #[doc = " Builds key and value strings and outputs them via a callback function\n\n @param       ctx[in]     local property context\n @param       fmt[in]     value format, set to NULL to bypass formatting\n @param       nparts[in]  number of key parts (separated by character)\n @param       ...[in]     list of key parts followed by value"]
    pub fn property_value_out(
        ctx: *mut PropertyValueContext,
        fmt: *const core::ffi::c_char,
        nparts: core::ffi::c_uint,
        ...
    );
}
pub const FuriHalPowerIC_FuriHalPowerICCharger: FuriHalPowerIC = 0;
pub const FuriHalPowerIC_FuriHalPowerICFuelGauge: FuriHalPowerIC = 1;
#[doc = " Power IC type"]
pub type FuriHalPowerIC = core::ffi::c_uchar;
extern "C" {
    #[doc = " Check if gauge is ok\n\n Verifies that:\n - gauge is alive\n - correct profile loaded\n - self diagnostic status is good\n\n @return true if gauge is ok"]
    pub fn furi_hal_power_gauge_is_ok() -> bool;
}
extern "C" {
    #[doc = " Enter insomnia mode Prevents device from going to sleep\n @warning    Internally increases insomnia level Must be paired with\n             furi_hal_power_insomnia_exit"]
    pub fn furi_hal_power_insomnia_enter();
}
extern "C" {
    #[doc = " Exit insomnia mode Allow device to go to sleep\n @warning    Internally decreases insomnia level. Must be paired with\n             furi_hal_power_insomnia_enter"]
    pub fn furi_hal_power_insomnia_exit();
}
extern "C" {
    #[doc = " Check if sleep availble\n\n @return     true if available"]
    pub fn furi_hal_power_sleep_available() -> bool;
}
extern "C" {
    #[doc = " Check if deep sleep availble\n\n @return     true if available"]
    pub fn furi_hal_power_deep_sleep_available() -> bool;
}
extern "C" {
    #[doc = " Go to sleep"]
    pub fn furi_hal_power_sleep();
}
extern "C" {
    #[doc = " Get predicted remaining battery capacity in percents\n\n @return     remaining battery capacity in percents"]
    pub fn furi_hal_power_get_pct() -> u8;
}
extern "C" {
    #[doc = " Get battery health state in percents\n\n @return     health in percents"]
    pub fn furi_hal_power_get_bat_health_pct() -> u8;
}
extern "C" {
    #[doc = " Get charging status\n\n @return     true if charging"]
    pub fn furi_hal_power_is_charging() -> bool;
}
extern "C" {
    #[doc = " Get charge complete status\n\n @return     true if done charging and connected to charger"]
    pub fn furi_hal_power_is_charging_done() -> bool;
}
extern "C" {
    #[doc = " Switch MCU to SHUTDOWN"]
    pub fn furi_hal_power_shutdown();
}
extern "C" {
    #[doc = " Poweroff device"]
    pub fn furi_hal_power_off();
}
extern "C" {
    #[doc = " Reset device"]
    pub fn furi_hal_power_reset();
}
extern "C" {
    #[doc = " OTG enable"]
    pub fn furi_hal_power_enable_otg();
}
extern "C" {
    #[doc = " OTG disable"]
    pub fn furi_hal_power_disable_otg();
}
extern "C" {
    #[doc = " Check OTG status and disable it if falt happened"]
    pub fn furi_hal_power_check_otg_status();
}
extern "C" {
    #[doc = " Get OTG status\n\n @return     true if enabled"]
    pub fn furi_hal_power_is_otg_enabled() -> bool;
}
extern "C" {
    #[doc = " Get battery charging voltage in V\n\n @return     voltage in V"]
    pub fn furi_hal_power_get_battery_charging_voltage() -> f32;
}
extern "C" {
    #[doc = " Set battery charging voltage in V\n\n Invalid values will be clamped to the nearest valid value.\n\n @param      voltage[in]  voltage in V\n\n @return     voltage in V"]
    pub fn furi_hal_power_set_battery_charging_voltage(voltage: f32);
}
extern "C" {
    #[doc = " Get remaining battery battery capacity in mAh\n\n @return     capacity in mAh"]
    pub fn furi_hal_power_get_battery_remaining_capacity() -> u32;
}
extern "C" {
    #[doc = " Get full charge battery capacity in mAh\n\n @return     capacity in mAh"]
    pub fn furi_hal_power_get_battery_full_capacity() -> u32;
}
extern "C" {
    #[doc = " Get battery capacity in mAh from battery profile\n\n @return     capacity in mAh"]
    pub fn furi_hal_power_get_battery_design_capacity() -> u32;
}
extern "C" {
    #[doc = " Get battery voltage in V\n\n @param      ic    FuriHalPowerIc to get measurment\n\n @return     voltage in V"]
    pub fn furi_hal_power_get_battery_voltage(ic: FuriHalPowerIC) -> f32;
}
extern "C" {
    #[doc = " Get battery current in A\n\n @param      ic    FuriHalPowerIc to get measurment\n\n @return     current in A"]
    pub fn furi_hal_power_get_battery_current(ic: FuriHalPowerIC) -> f32;
}
extern "C" {
    #[doc = " Get temperature in C\n\n @param      ic    FuriHalPowerIc to get measurment\n\n @return     temperature in C"]
    pub fn furi_hal_power_get_battery_temperature(ic: FuriHalPowerIC) -> f32;
}
extern "C" {
    #[doc = " Get USB voltage in V\n\n @return     voltage in V"]
    pub fn furi_hal_power_get_usb_voltage() -> f32;
}
extern "C" {
    #[doc = " Enable 3.3v on external gpio and sd card"]
    pub fn furi_hal_power_enable_external_3_3v();
}
extern "C" {
    #[doc = " Disable 3.3v on external gpio and sd card"]
    pub fn furi_hal_power_disable_external_3_3v();
}
extern "C" {
    #[doc = " Enter supress charge mode.\n\n Use this function when your application need clean power supply."]
    pub fn furi_hal_power_suppress_charge_enter();
}
extern "C" {
    #[doc = " Exit supress charge mode"]
    pub fn furi_hal_power_suppress_charge_exit();
}
extern "C" {
    #[doc = " Get power information\n\n @param[in]  callback     callback to provide with new data\n @param[in]  sep          category separator character\n @param[in]  context      context to pass to callback"]
    pub fn furi_hal_power_info_get(
        callback: PropertyValueCallback,
        sep: core::ffi::c_char,
        context: *mut core::ffi::c_void,
    );
}
extern "C" {
    #[doc = " Get power debug information\n\n @param[in]  callback     callback to provide with new data\n @param[in]  context      context to pass to callback"]
    pub fn furi_hal_power_debug_get(
        callback: PropertyValueCallback,
        context: *mut core::ffi::c_void,
    );
}
#[doc = " @brief  TIM Time Base configuration structure definition."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LL_TIM_InitTypeDef {
    #[doc = "< Specifies the prescaler value used to divide the TIM clock.\nThis parameter can be a number between Min_Data=0x0000 and Max_Data=0xFFFF.\n\nThis feature can be modified afterwards using unitary function\n@ref LL_TIM_SetPrescaler()."]
    pub Prescaler: u16,
    #[doc = "< Specifies the counter mode.\nThis parameter can be a value of @ref TIM_LL_EC_COUNTERMODE.\n\nThis feature can be modified afterwards using unitary function\n@ref LL_TIM_SetCounterMode()."]
    pub CounterMode: u32,
    #[doc = "< Specifies the auto reload value to be loaded into the active\nAuto-Reload Register at the next update event.\nThis parameter must be a number between Min_Data=0x0000 and Max_Data=0xFFFF.\nSome timer instances may support 32 bits counters. In that case this parameter must\nbe a number between 0x0000 and 0xFFFFFFFF.\n\nThis feature can be modified afterwards using unitary function\n@ref LL_TIM_SetAutoReload()."]
    pub Autoreload: u32,
    #[doc = "< Specifies the clock division.\nThis parameter can be a value of @ref TIM_LL_EC_CLOCKDIVISION.\n\nThis feature can be modified afterwards using unitary function\n@ref LL_TIM_SetClockDivision()."]
    pub ClockDivision: u32,
    #[doc = "< Specifies the repetition counter value. Each time the RCR downcounter\nreaches zero, an update event is generated and counting restarts\nfrom the RCR value (N).\nThis means in PWM mode that (N+1) corresponds to:\n- the number of PWM periods in edge-aligned mode\n- the number of half PWM period in center-aligned mode\nGP timers: this parameter must be a number between Min_Data = 0x00 and\nMax_Data = 0xFF.\nAdvanced timers: this parameter must be a number between Min_Data = 0x0000 and\nMax_Data = 0xFFFF.\n\nThis feature can be modified afterwards using unitary function\n@ref LL_TIM_SetRepetitionCounter()."]
    pub RepetitionCounter: u32,
}
#[test]
fn bindgen_test_layout_LL_TIM_InitTypeDef() {
    const UNINIT: ::core::mem::MaybeUninit<LL_TIM_InitTypeDef> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<LL_TIM_InitTypeDef>(),
        20usize,
        concat!("Size of: ", stringify!(LL_TIM_InitTypeDef))
    );
    assert_eq!(
        ::core::mem::align_of::<LL_TIM_InitTypeDef>(),
        4usize,
        concat!("Alignment of ", stringify!(LL_TIM_InitTypeDef))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Prescaler) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(LL_TIM_InitTypeDef),
            "::",
            stringify!(Prescaler)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CounterMode) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(LL_TIM_InitTypeDef),
            "::",
            stringify!(CounterMode)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Autoreload) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(LL_TIM_InitTypeDef),
            "::",
            stringify!(Autoreload)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ClockDivision) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(LL_TIM_InitTypeDef),
            "::",
            stringify!(ClockDivision)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).RepetitionCounter) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(LL_TIM_InitTypeDef),
            "::",
            stringify!(RepetitionCounter)
        )
    );
}
#[doc = " @brief  TIM Output Compare configuration structure definition."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LL_TIM_OC_InitTypeDef {
    #[doc = "< Specifies the output mode.\nThis parameter can be a value of @ref TIM_LL_EC_OCMODE.\n\nThis feature can be modified afterwards using unitary function\n@ref LL_TIM_OC_SetMode()."]
    pub OCMode: u32,
    #[doc = "< Specifies the TIM Output Compare state.\nThis parameter can be a value of @ref TIM_LL_EC_OCSTATE.\n\nThis feature can be modified afterwards using unitary functions\n@ref LL_TIM_CC_EnableChannel() or @ref LL_TIM_CC_DisableChannel()."]
    pub OCState: u32,
    #[doc = "< Specifies the TIM complementary Output Compare state.\nThis parameter can be a value of @ref TIM_LL_EC_OCSTATE.\n\nThis feature can be modified afterwards using unitary functions\n@ref LL_TIM_CC_EnableChannel() or @ref LL_TIM_CC_DisableChannel()."]
    pub OCNState: u32,
    #[doc = "< Specifies the Compare value to be loaded into the Capture Compare Register.\nThis parameter can be a number between Min_Data=0x0000 and Max_Data=0xFFFF.\n\nThis feature can be modified afterwards using unitary function\nLL_TIM_OC_SetCompareCHx (x=1..6)."]
    pub CompareValue: u32,
    #[doc = "< Specifies the output polarity.\nThis parameter can be a value of @ref TIM_LL_EC_OCPOLARITY.\n\nThis feature can be modified afterwards using unitary function\n@ref LL_TIM_OC_SetPolarity()."]
    pub OCPolarity: u32,
    #[doc = "< Specifies the complementary output polarity.\nThis parameter can be a value of @ref TIM_LL_EC_OCPOLARITY.\n\nThis feature can be modified afterwards using unitary function\n@ref LL_TIM_OC_SetPolarity()."]
    pub OCNPolarity: u32,
    #[doc = "< Specifies the TIM Output Compare pin state during Idle state.\nThis parameter can be a value of @ref TIM_LL_EC_OCIDLESTATE.\n\nThis feature can be modified afterwards using unitary function\n@ref LL_TIM_OC_SetIdleState()."]
    pub OCIdleState: u32,
    #[doc = "< Specifies the TIM Output Compare pin state during Idle state.\nThis parameter can be a value of @ref TIM_LL_EC_OCIDLESTATE.\n\nThis feature can be modified afterwards using unitary function\n@ref LL_TIM_OC_SetIdleState()."]
    pub OCNIdleState: u32,
}
#[test]
fn bindgen_test_layout_LL_TIM_OC_InitTypeDef() {
    const UNINIT: ::core::mem::MaybeUninit<LL_TIM_OC_InitTypeDef> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<LL_TIM_OC_InitTypeDef>(),
        32usize,
        concat!("Size of: ", stringify!(LL_TIM_OC_InitTypeDef))
    );
    assert_eq!(
        ::core::mem::align_of::<LL_TIM_OC_InitTypeDef>(),
        4usize,
        concat!("Alignment of ", stringify!(LL_TIM_OC_InitTypeDef))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).OCMode) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(LL_TIM_OC_InitTypeDef),
            "::",
            stringify!(OCMode)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).OCState) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(LL_TIM_OC_InitTypeDef),
            "::",
            stringify!(OCState)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).OCNState) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(LL_TIM_OC_InitTypeDef),
            "::",
            stringify!(OCNState)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CompareValue) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(LL_TIM_OC_InitTypeDef),
            "::",
            stringify!(CompareValue)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).OCPolarity) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(LL_TIM_OC_InitTypeDef),
            "::",
            stringify!(OCPolarity)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).OCNPolarity) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(LL_TIM_OC_InitTypeDef),
            "::",
            stringify!(OCNPolarity)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).OCIdleState) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(LL_TIM_OC_InitTypeDef),
            "::",
            stringify!(OCIdleState)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).OCNIdleState) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(LL_TIM_OC_InitTypeDef),
            "::",
            stringify!(OCNIdleState)
        )
    );
}
extern "C" {
    #[doc = " @defgroup TIM_LL_EF_Init Initialisation and deinitialisation functions\n @{"]
    pub fn LL_TIM_DeInit(TIMx: *mut TIM_TypeDef) -> ErrorStatus;
}
extern "C" {
    pub fn LL_TIM_Init(
        TIMx: *mut TIM_TypeDef,
        TIM_InitStruct: *mut LL_TIM_InitTypeDef,
    ) -> ErrorStatus;
}
extern "C" {
    pub fn LL_TIM_OC_Init(
        TIMx: *mut TIM_TypeDef,
        Channel: u32,
        TIM_OC_InitStruct: *mut LL_TIM_OC_InitTypeDef,
    ) -> ErrorStatus;
}
#[doc = " Timer ISR"]
pub type FuriHalInterruptISR =
    ::core::option::Option<unsafe extern "C" fn(context: *mut core::ffi::c_void)>;
pub const FuriHalInterruptId_FuriHalInterruptIdTim1TrgComTim17: FuriHalInterruptId = 0;
pub const FuriHalInterruptId_FuriHalInterruptIdTim1Cc: FuriHalInterruptId = 1;
pub const FuriHalInterruptId_FuriHalInterruptIdTim1UpTim16: FuriHalInterruptId = 2;
pub const FuriHalInterruptId_FuriHalInterruptIdTIM2: FuriHalInterruptId = 3;
pub const FuriHalInterruptId_FuriHalInterruptIdDma1Ch1: FuriHalInterruptId = 4;
pub const FuriHalInterruptId_FuriHalInterruptIdDma1Ch2: FuriHalInterruptId = 5;
pub const FuriHalInterruptId_FuriHalInterruptIdDma1Ch3: FuriHalInterruptId = 6;
pub const FuriHalInterruptId_FuriHalInterruptIdDma1Ch4: FuriHalInterruptId = 7;
pub const FuriHalInterruptId_FuriHalInterruptIdDma1Ch5: FuriHalInterruptId = 8;
pub const FuriHalInterruptId_FuriHalInterruptIdDma1Ch6: FuriHalInterruptId = 9;
pub const FuriHalInterruptId_FuriHalInterruptIdDma1Ch7: FuriHalInterruptId = 10;
pub const FuriHalInterruptId_FuriHalInterruptIdDma2Ch1: FuriHalInterruptId = 11;
pub const FuriHalInterruptId_FuriHalInterruptIdDma2Ch2: FuriHalInterruptId = 12;
pub const FuriHalInterruptId_FuriHalInterruptIdDma2Ch3: FuriHalInterruptId = 13;
pub const FuriHalInterruptId_FuriHalInterruptIdDma2Ch4: FuriHalInterruptId = 14;
pub const FuriHalInterruptId_FuriHalInterruptIdDma2Ch5: FuriHalInterruptId = 15;
pub const FuriHalInterruptId_FuriHalInterruptIdDma2Ch6: FuriHalInterruptId = 16;
pub const FuriHalInterruptId_FuriHalInterruptIdDma2Ch7: FuriHalInterruptId = 17;
pub const FuriHalInterruptId_FuriHalInterruptIdRcc: FuriHalInterruptId = 18;
pub const FuriHalInterruptId_FuriHalInterruptIdCOMP: FuriHalInterruptId = 19;
pub const FuriHalInterruptId_FuriHalInterruptIdHsem: FuriHalInterruptId = 20;
pub const FuriHalInterruptId_FuriHalInterruptIdLpTim1: FuriHalInterruptId = 21;
pub const FuriHalInterruptId_FuriHalInterruptIdLpTim2: FuriHalInterruptId = 22;
pub const FuriHalInterruptId_FuriHalInterruptIdMax: FuriHalInterruptId = 23;
pub type FuriHalInterruptId = core::ffi::c_uchar;
extern "C" {
    #[doc = " Set ISR and enable interrupt with default priority\n We don't clear interrupt flags for you, do it by your self.\n @param index - interrupt ID\n @param isr - your interrupt service routine or use NULL to clear\n @param context - isr context"]
    pub fn furi_hal_interrupt_set_isr(
        index: FuriHalInterruptId,
        isr: FuriHalInterruptISR,
        context: *mut core::ffi::c_void,
    );
}
extern "C" {
    #[doc = " Set ISR and enable interrupt with custom priority\n We don't clear interrupt flags for you, do it by your self.\n @param index - interrupt ID\n @param priority - 0 to 15, 0 highest\n @param isr - your interrupt service routine or use NULL to clear\n @param context - isr context"]
    pub fn furi_hal_interrupt_set_isr_ex(
        index: FuriHalInterruptId,
        priority: u16,
        isr: FuriHalInterruptISR,
        context: *mut core::ffi::c_void,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Version {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " Get current running firmware version handle.\n\n You can store it somewhere. But if you want to retrieve data, you have to use\n 'version_*_get()' set of functions. Also, 'version_*_get()' imply to use this\n handle if no handle (NULL_PTR) provided.\n\n @return     pointer to Version data."]
    pub fn version_get() -> *const Version;
}
extern "C" {
    #[doc = " Get git commit hash.\n\n @param      v     pointer to Version data. NULL for currently running\n                   software.\n\n @return     git hash"]
    pub fn version_get_githash(v: *const Version) -> *const core::ffi::c_char;
}
extern "C" {
    #[doc = " Get git branch.\n\n @param      v     pointer to Version data. NULL for currently running\n                   software.\n\n @return     git branch"]
    pub fn version_get_gitbranch(v: *const Version) -> *const core::ffi::c_char;
}
extern "C" {
    #[doc = " Get number of commit in git branch.\n\n @param      v     pointer to Version data. NULL for currently running\n                   software.\n\n @return     number of commit"]
    pub fn version_get_gitbranchnum(v: *const Version) -> *const core::ffi::c_char;
}
extern "C" {
    #[doc = " Get build date.\n\n @param      v     pointer to Version data. NULL for currently running\n                   software.\n\n @return     build date"]
    pub fn version_get_builddate(v: *const Version) -> *const core::ffi::c_char;
}
extern "C" {
    #[doc = " Get build version. Build version is last tag in git history.\n\n @param      v     pointer to Version data. NULL for currently running\n                   software.\n\n @return     build date"]
    pub fn version_get_version(v: *const Version) -> *const core::ffi::c_char;
}
extern "C" {
    #[doc = " Get hardware target this firmware was built for\n\n @param      v     pointer to Version data. NULL for currently running\n                   software.\n\n @return     build date"]
    pub fn version_get_target(v: *const Version) -> u8;
}
extern "C" {
    #[doc = " Get flag indicating if this build is \"dirty\" (source code had uncommited changes)\n\n @param      v     pointer to Version data. NULL for currently running\n                   software.\n\n @return     build date"]
    pub fn version_get_dirty_flag(v: *const Version) -> bool;
}
pub const FuriHalVersionOtpVersion_FuriHalVersionOtpVersion0: FuriHalVersionOtpVersion = 0;
pub const FuriHalVersionOtpVersion_FuriHalVersionOtpVersion1: FuriHalVersionOtpVersion = 1;
pub const FuriHalVersionOtpVersion_FuriHalVersionOtpVersion2: FuriHalVersionOtpVersion = 2;
pub const FuriHalVersionOtpVersion_FuriHalVersionOtpVersionEmpty: FuriHalVersionOtpVersion =
    4294967294;
pub const FuriHalVersionOtpVersion_FuriHalVersionOtpVersionUnknown: FuriHalVersionOtpVersion =
    4294967295;
#[doc = " OTP Versions enum"]
pub type FuriHalVersionOtpVersion = core::ffi::c_uint;
pub const FuriHalVersionColor_FuriHalVersionColorUnknown: FuriHalVersionColor = 0;
pub const FuriHalVersionColor_FuriHalVersionColorBlack: FuriHalVersionColor = 1;
pub const FuriHalVersionColor_FuriHalVersionColorWhite: FuriHalVersionColor = 2;
#[doc = " Device Colors"]
pub type FuriHalVersionColor = core::ffi::c_uchar;
pub const FuriHalVersionRegion_FuriHalVersionRegionUnknown: FuriHalVersionRegion = 0;
pub const FuriHalVersionRegion_FuriHalVersionRegionEuRu: FuriHalVersionRegion = 1;
pub const FuriHalVersionRegion_FuriHalVersionRegionUsCaAu: FuriHalVersionRegion = 2;
pub const FuriHalVersionRegion_FuriHalVersionRegionJp: FuriHalVersionRegion = 3;
pub const FuriHalVersionRegion_FuriHalVersionRegionWorld: FuriHalVersionRegion = 4;
#[doc = " Device Regions"]
pub type FuriHalVersionRegion = core::ffi::c_uchar;
pub const FuriHalVersionDisplay_FuriHalVersionDisplayUnknown: FuriHalVersionDisplay = 0;
pub const FuriHalVersionDisplay_FuriHalVersionDisplayErc: FuriHalVersionDisplay = 1;
pub const FuriHalVersionDisplay_FuriHalVersionDisplayMgg: FuriHalVersionDisplay = 2;
#[doc = " Device Display"]
pub type FuriHalVersionDisplay = core::ffi::c_uchar;
extern "C" {
    #[doc = " Check target firmware version\n\n @return     true if target and real matches"]
    pub fn furi_hal_version_do_i_belong_here() -> bool;
}
extern "C" {
    #[doc = " Get model name\n\n @return     model name C-string"]
    pub fn furi_hal_version_get_model_name() -> *const core::ffi::c_char;
}
extern "C" {
    #[doc = " Get model name\n\n @return     model code C-string"]
    pub fn furi_hal_version_get_model_code() -> *const core::ffi::c_char;
}
extern "C" {
    #[doc = " Get FCC ID\n\n @return     FCC id as C-string"]
    pub fn furi_hal_version_get_fcc_id() -> *const core::ffi::c_char;
}
extern "C" {
    #[doc = " Get IC id\n\n @return     IC id as C-string"]
    pub fn furi_hal_version_get_ic_id() -> *const core::ffi::c_char;
}
extern "C" {
    #[doc = " Get OTP version\n\n @return     OTP Version"]
    pub fn furi_hal_version_get_otp_version() -> FuriHalVersionOtpVersion;
}
extern "C" {
    #[doc = " Get hardware version\n\n @return     Hardware Version"]
    pub fn furi_hal_version_get_hw_version() -> u8;
}
extern "C" {
    #[doc = " Get hardware target\n\n @return     Hardware Target"]
    pub fn furi_hal_version_get_hw_target() -> u8;
}
extern "C" {
    #[doc = " Get hardware body\n\n @return     Hardware Body"]
    pub fn furi_hal_version_get_hw_body() -> u8;
}
extern "C" {
    #[doc = " Get hardware body color\n\n @return     Hardware Color"]
    pub fn furi_hal_version_get_hw_color() -> FuriHalVersionColor;
}
extern "C" {
    #[doc = " Get hardware connect\n\n @return     Hardware Interconnect"]
    pub fn furi_hal_version_get_hw_connect() -> u8;
}
extern "C" {
    #[doc = " Get hardware region\n\n @return     Hardware Region"]
    pub fn furi_hal_version_get_hw_region() -> FuriHalVersionRegion;
}
extern "C" {
    #[doc = " Get hardware region name\n\n @return     Hardware Region name"]
    pub fn furi_hal_version_get_hw_region_name() -> *const core::ffi::c_char;
}
extern "C" {
    #[doc = " Get hardware display id\n\n @return     Display id"]
    pub fn furi_hal_version_get_hw_display() -> FuriHalVersionDisplay;
}
extern "C" {
    #[doc = " Get hardware timestamp\n\n @return     Hardware Manufacture timestamp"]
    pub fn furi_hal_version_get_hw_timestamp() -> u32;
}
extern "C" {
    #[doc = " Get pointer to target name\n\n @return     Hardware Name C-string"]
    pub fn furi_hal_version_get_name_ptr() -> *const core::ffi::c_char;
}
extern "C" {
    #[doc = " Get pointer to target device name\n\n @return     Hardware Device Name C-string"]
    pub fn furi_hal_version_get_device_name_ptr() -> *const core::ffi::c_char;
}
extern "C" {
    #[doc = " Get pointer to target ble local device name\n\n @return     Ble Device Name C-string"]
    pub fn furi_hal_version_get_ble_local_device_name_ptr() -> *const core::ffi::c_char;
}
extern "C" {
    #[doc = " Get BLE MAC address\n\n @return     pointer to BLE MAC address"]
    pub fn furi_hal_version_get_ble_mac() -> *const u8;
}
extern "C" {
    #[doc = " Get address of version structure of firmware.\n\n @return     Address of firmware version structure."]
    pub fn furi_hal_version_get_firmware_version() -> *const Version;
}
extern "C" {
    #[doc = " Get platform UID size in bytes\n\n @return     UID size in bytes"]
    pub fn furi_hal_version_uid_size() -> usize;
}
extern "C" {
    #[doc = " Get const pointer to UID\n\n @return     pointer to UID"]
    pub fn furi_hal_version_uid() -> *const u8;
}
pub const GapEventType_GapEventTypeConnected: GapEventType = 0;
pub const GapEventType_GapEventTypeDisconnected: GapEventType = 1;
pub const GapEventType_GapEventTypeStartAdvertising: GapEventType = 2;
pub const GapEventType_GapEventTypeStopAdvertising: GapEventType = 3;
pub const GapEventType_GapEventTypePinCodeShow: GapEventType = 4;
pub const GapEventType_GapEventTypePinCodeVerify: GapEventType = 5;
pub const GapEventType_GapEventTypeUpdateMTU: GapEventType = 6;
pub type GapEventType = core::ffi::c_uchar;
#[repr(C)]
#[derive(Copy, Clone)]
pub union GapEventData {
    pub pin_code: u32,
    pub max_packet_size: u16,
}
#[test]
fn bindgen_test_layout_GapEventData() {
    const UNINIT: ::core::mem::MaybeUninit<GapEventData> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<GapEventData>(),
        4usize,
        concat!("Size of: ", stringify!(GapEventData))
    );
    assert_eq!(
        ::core::mem::align_of::<GapEventData>(),
        4usize,
        concat!("Alignment of ", stringify!(GapEventData))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pin_code) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GapEventData),
            "::",
            stringify!(pin_code)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).max_packet_size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GapEventData),
            "::",
            stringify!(max_packet_size)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct GapEvent {
    pub type_: GapEventType,
    pub data: GapEventData,
}
#[test]
fn bindgen_test_layout_GapEvent() {
    const UNINIT: ::core::mem::MaybeUninit<GapEvent> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<GapEvent>(),
        8usize,
        concat!("Size of: ", stringify!(GapEvent))
    );
    assert_eq!(
        ::core::mem::align_of::<GapEvent>(),
        4usize,
        concat!("Alignment of ", stringify!(GapEvent))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GapEvent),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(GapEvent),
            "::",
            stringify!(data)
        )
    );
}
pub type GapEventCallback = ::core::option::Option<
    unsafe extern "C" fn(event: GapEvent, context: *mut core::ffi::c_void) -> bool,
>;
pub const SerialServiceEventType_SerialServiceEventTypeDataReceived: SerialServiceEventType = 0;
pub const SerialServiceEventType_SerialServiceEventTypeDataSent: SerialServiceEventType = 1;
pub const SerialServiceEventType_SerialServiceEventTypesBleResetRequest: SerialServiceEventType = 2;
pub type SerialServiceEventType = core::ffi::c_uchar;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SerialServiceData {
    pub buffer: *mut u8,
    pub size: u16,
}
#[test]
fn bindgen_test_layout_SerialServiceData() {
    const UNINIT: ::core::mem::MaybeUninit<SerialServiceData> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SerialServiceData>(),
        8usize,
        concat!("Size of: ", stringify!(SerialServiceData))
    );
    assert_eq!(
        ::core::mem::align_of::<SerialServiceData>(),
        4usize,
        concat!("Alignment of ", stringify!(SerialServiceData))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).buffer) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SerialServiceData),
            "::",
            stringify!(buffer)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SerialServiceData),
            "::",
            stringify!(size)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SerialServiceEvent {
    pub event: SerialServiceEventType,
    pub data: SerialServiceData,
}
#[test]
fn bindgen_test_layout_SerialServiceEvent() {
    const UNINIT: ::core::mem::MaybeUninit<SerialServiceEvent> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SerialServiceEvent>(),
        12usize,
        concat!("Size of: ", stringify!(SerialServiceEvent))
    );
    assert_eq!(
        ::core::mem::align_of::<SerialServiceEvent>(),
        4usize,
        concat!("Alignment of ", stringify!(SerialServiceEvent))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).event) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SerialServiceEvent),
            "::",
            stringify!(event)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SerialServiceEvent),
            "::",
            stringify!(data)
        )
    );
}
pub type SerialServiceEventCallback = ::core::option::Option<
    unsafe extern "C" fn(event: SerialServiceEvent, context: *mut core::ffi::c_void) -> u16,
>;
pub const BleGlueC2Mode_BleGlueC2ModeUnknown: BleGlueC2Mode = 0;
pub const BleGlueC2Mode_BleGlueC2ModeFUS: BleGlueC2Mode = 1;
pub const BleGlueC2Mode_BleGlueC2ModeStack: BleGlueC2Mode = 2;
pub type BleGlueC2Mode = core::ffi::c_uchar;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct BleGlueC2Info {
    pub mode: BleGlueC2Mode,
    #[doc = " Wireless Info"]
    pub VersionMajor: u8,
    pub VersionMinor: u8,
    pub VersionSub: u8,
    pub VersionBranch: u8,
    pub VersionReleaseType: u8,
    pub MemorySizeSram2B: u8,
    pub MemorySizeSram2A: u8,
    pub MemorySizeSram1: u8,
    pub MemorySizeFlash: u8,
    pub StackType: u8,
    pub StackTypeString: [core::ffi::c_char; 20usize],
    #[doc = " Fus Info"]
    pub FusVersionMajor: u8,
    pub FusVersionMinor: u8,
    pub FusVersionSub: u8,
    pub FusMemorySizeSram2B: u8,
    pub FusMemorySizeSram2A: u8,
    pub FusMemorySizeFlash: u8,
}
#[test]
fn bindgen_test_layout_BleGlueC2Info() {
    const UNINIT: ::core::mem::MaybeUninit<BleGlueC2Info> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<BleGlueC2Info>(),
        37usize,
        concat!("Size of: ", stringify!(BleGlueC2Info))
    );
    assert_eq!(
        ::core::mem::align_of::<BleGlueC2Info>(),
        1usize,
        concat!("Alignment of ", stringify!(BleGlueC2Info))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).mode) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(BleGlueC2Info),
            "::",
            stringify!(mode)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).VersionMajor) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(BleGlueC2Info),
            "::",
            stringify!(VersionMajor)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).VersionMinor) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(BleGlueC2Info),
            "::",
            stringify!(VersionMinor)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).VersionSub) as usize - ptr as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(BleGlueC2Info),
            "::",
            stringify!(VersionSub)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).VersionBranch) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(BleGlueC2Info),
            "::",
            stringify!(VersionBranch)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).VersionReleaseType) as usize - ptr as usize },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(BleGlueC2Info),
            "::",
            stringify!(VersionReleaseType)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).MemorySizeSram2B) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(BleGlueC2Info),
            "::",
            stringify!(MemorySizeSram2B)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).MemorySizeSram2A) as usize - ptr as usize },
        7usize,
        concat!(
            "Offset of field: ",
            stringify!(BleGlueC2Info),
            "::",
            stringify!(MemorySizeSram2A)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).MemorySizeSram1) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(BleGlueC2Info),
            "::",
            stringify!(MemorySizeSram1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).MemorySizeFlash) as usize - ptr as usize },
        9usize,
        concat!(
            "Offset of field: ",
            stringify!(BleGlueC2Info),
            "::",
            stringify!(MemorySizeFlash)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).StackType) as usize - ptr as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(BleGlueC2Info),
            "::",
            stringify!(StackType)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).StackTypeString) as usize - ptr as usize },
        11usize,
        concat!(
            "Offset of field: ",
            stringify!(BleGlueC2Info),
            "::",
            stringify!(StackTypeString)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).FusVersionMajor) as usize - ptr as usize },
        31usize,
        concat!(
            "Offset of field: ",
            stringify!(BleGlueC2Info),
            "::",
            stringify!(FusVersionMajor)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).FusVersionMinor) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(BleGlueC2Info),
            "::",
            stringify!(FusVersionMinor)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).FusVersionSub) as usize - ptr as usize },
        33usize,
        concat!(
            "Offset of field: ",
            stringify!(BleGlueC2Info),
            "::",
            stringify!(FusVersionSub)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).FusMemorySizeSram2B) as usize - ptr as usize },
        34usize,
        concat!(
            "Offset of field: ",
            stringify!(BleGlueC2Info),
            "::",
            stringify!(FusMemorySizeSram2B)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).FusMemorySizeSram2A) as usize - ptr as usize },
        35usize,
        concat!(
            "Offset of field: ",
            stringify!(BleGlueC2Info),
            "::",
            stringify!(FusMemorySizeSram2A)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).FusMemorySizeFlash) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(BleGlueC2Info),
            "::",
            stringify!(FusMemorySizeFlash)
        )
    );
}
pub type BleGlueKeyStorageChangedCallback = ::core::option::Option<
    unsafe extern "C" fn(change_addr_start: *mut u8, size: u16, context: *mut core::ffi::c_void),
>;
extern "C" {
    #[doc = " Initialize start core2 and initialize transport"]
    pub fn ble_glue_init();
}
extern "C" {
    #[doc = " Start Core2 Radio stack\n\n @return     true on success"]
    pub fn ble_glue_start() -> bool;
}
extern "C" {
    #[doc = " Is core2 alive and at least FUS is running\n\n @return     true if core2 is alive"]
    pub fn ble_glue_is_alive() -> bool;
}
extern "C" {
    #[doc = " Waits for C2 to reports its mode to callback\n\n @return     true if it reported before reaching timeout"]
    pub fn ble_glue_wait_for_c2_start(timeout: i32) -> bool;
}
extern "C" {
    pub fn ble_glue_get_c2_info() -> *const BleGlueC2Info;
}
extern "C" {
    #[doc = " Is core2 radio stack present and ready\n\n @return     true if present and ready"]
    pub fn ble_glue_is_radio_stack_ready() -> bool;
}
extern "C" {
    #[doc = " Set callback for NVM in RAM changes\n\n @param[in]  callback  The callback to call on NVM change\n @param      context   The context for callback"]
    pub fn ble_glue_set_key_storage_changed_callback(
        callback: BleGlueKeyStorageChangedCallback,
        context: *mut core::ffi::c_void,
    );
}
extern "C" {
    #[doc = " Stop SHCI thread"]
    pub fn ble_glue_thread_stop();
}
extern "C" {
    pub fn ble_glue_reinit_c2() -> bool;
}
pub const BleGlueCommandResult_BleGlueCommandResultUnknown: BleGlueCommandResult = 0;
pub const BleGlueCommandResult_BleGlueCommandResultOK: BleGlueCommandResult = 1;
pub const BleGlueCommandResult_BleGlueCommandResultError: BleGlueCommandResult = 2;
pub const BleGlueCommandResult_BleGlueCommandResultRestartPending: BleGlueCommandResult = 3;
pub const BleGlueCommandResult_BleGlueCommandResultOperationOngoing: BleGlueCommandResult = 4;
pub type BleGlueCommandResult = core::ffi::c_uchar;
extern "C" {
    #[doc = " Restart MCU to launch radio stack firmware if necessary\n\n @return      true on radio stack start command"]
    pub fn ble_glue_force_c2_mode(mode: BleGlueC2Mode) -> BleGlueCommandResult;
}
extern "C" {
    pub fn ble_app_init() -> bool;
}
extern "C" {
    pub fn ble_app_get_key_storage_buff(addr: *mut *mut u8, size: *mut u16);
}
extern "C" {
    pub fn ble_app_thread_stop();
}
pub const FuriHalBtSerialRpcStatus_FuriHalBtSerialRpcStatusNotActive: FuriHalBtSerialRpcStatus = 0;
pub const FuriHalBtSerialRpcStatus_FuriHalBtSerialRpcStatusActive: FuriHalBtSerialRpcStatus = 1;
pub type FuriHalBtSerialRpcStatus = core::ffi::c_uchar;
#[doc = " Serial service callback type"]
pub type FuriHalBtSerialCallback = SerialServiceEventCallback;
extern "C" {
    #[doc = " Start Serial Profile"]
    pub fn furi_hal_bt_serial_start();
}
extern "C" {
    #[doc = " Stop Serial Profile"]
    pub fn furi_hal_bt_serial_stop();
}
extern "C" {
    #[doc = " Set Serial service events callback\n\n @param buffer_size   Applicaition buffer size\n @param calback       FuriHalBtSerialCallback instance\n @param context       pointer to context"]
    pub fn furi_hal_bt_serial_set_event_callback(
        buff_size: u16,
        callback: FuriHalBtSerialCallback,
        context: *mut core::ffi::c_void,
    );
}
extern "C" {
    #[doc = " Set BLE RPC status\n\n @param status        FuriHalBtSerialRpcStatus instance"]
    pub fn furi_hal_bt_serial_set_rpc_status(status: FuriHalBtSerialRpcStatus);
}
extern "C" {
    #[doc = " Notify that application buffer is empty"]
    pub fn furi_hal_bt_serial_notify_buffer_is_empty();
}
extern "C" {
    #[doc = " Send data through BLE\n\n @param data  data buffer\n @param size  data buffer size\n\n @return      true on success"]
    pub fn furi_hal_bt_serial_tx(data: *mut u8, size: u16) -> bool;
}
pub const FuriHalBtStack_FuriHalBtStackUnknown: FuriHalBtStack = 0;
pub const FuriHalBtStack_FuriHalBtStackLight: FuriHalBtStack = 1;
pub const FuriHalBtStack_FuriHalBtStackFull: FuriHalBtStack = 2;
pub type FuriHalBtStack = core::ffi::c_uchar;
pub const FuriHalBtProfile_FuriHalBtProfileSerial: FuriHalBtProfile = 0;
pub const FuriHalBtProfile_FuriHalBtProfileHidKeyboard: FuriHalBtProfile = 1;
pub const FuriHalBtProfile_FuriHalBtProfileNumber: FuriHalBtProfile = 2;
pub type FuriHalBtProfile = core::ffi::c_uchar;
extern "C" {
    #[doc = " Lock core2 state transition"]
    pub fn furi_hal_bt_lock_core2();
}
extern "C" {
    #[doc = " Lock core2 state transition"]
    pub fn furi_hal_bt_unlock_core2();
}
extern "C" {
    #[doc = " Start radio stack\n\n @return  true on successfull radio stack start"]
    pub fn furi_hal_bt_start_radio_stack() -> bool;
}
extern "C" {
    #[doc = " Get radio stack type\n\n @return  FuriHalBtStack instance"]
    pub fn furi_hal_bt_get_radio_stack() -> FuriHalBtStack;
}
extern "C" {
    #[doc = " Check if radio stack supports BLE GAT/GAP\n\n @return  true if supported"]
    pub fn furi_hal_bt_is_ble_gatt_gap_supported() -> bool;
}
extern "C" {
    #[doc = " Check if radio stack supports testing\n\n @return  true if supported"]
    pub fn furi_hal_bt_is_testing_supported() -> bool;
}
extern "C" {
    #[doc = " Start BLE app\n\n @param profile   FuriHalBtProfile instance\n @param event_cb  GapEventCallback instance\n @param context   pointer to context\n\n @return          true on success"]
    pub fn furi_hal_bt_start_app(
        profile: FuriHalBtProfile,
        event_cb: GapEventCallback,
        context: *mut core::ffi::c_void,
    ) -> bool;
}
extern "C" {
    #[doc = " Reinitialize core2\n\n Also can be used to prepare core2 for stop modes"]
    pub fn furi_hal_bt_reinit();
}
extern "C" {
    #[doc = " Change BLE app\n Restarts 2nd core\n\n @param profile   FuriHalBtProfile instance\n @param event_cb  GapEventCallback instance\n @param context   pointer to context\n\n @return          true on success"]
    pub fn furi_hal_bt_change_app(
        profile: FuriHalBtProfile,
        event_cb: GapEventCallback,
        context: *mut core::ffi::c_void,
    ) -> bool;
}
extern "C" {
    #[doc = " Update battery level\n\n @param battery_level battery level"]
    pub fn furi_hal_bt_update_battery_level(battery_level: u8);
}
extern "C" {
    #[doc = " Update battery power state"]
    pub fn furi_hal_bt_update_power_state();
}
extern "C" {
    #[doc = " Checks if BLE state is active\n\n @return          true if device is connected or advertising, false otherwise"]
    pub fn furi_hal_bt_is_active() -> bool;
}
extern "C" {
    #[doc = " Start advertising"]
    pub fn furi_hal_bt_start_advertising();
}
extern "C" {
    #[doc = " Stop advertising"]
    pub fn furi_hal_bt_stop_advertising();
}
extern "C" {
    #[doc = " Get BT/BLE system component state\n\n @param[in]  buffer  FuriString* buffer to write to"]
    pub fn furi_hal_bt_dump_state(buffer: *mut FuriString);
}
extern "C" {
    #[doc = " Get BT/BLE system component state\n\n @return     true if core2 is alive"]
    pub fn furi_hal_bt_is_alive() -> bool;
}
extern "C" {
    #[doc = " Get key storage buffer address and size\n\n @param      key_buff_addr  pointer to store buffer address\n @param      key_buff_size  pointer to store buffer size"]
    pub fn furi_hal_bt_get_key_storage_buff(key_buff_addr: *mut *mut u8, key_buff_size: *mut u16);
}
extern "C" {
    #[doc = " Get SRAM2 hardware semaphore\n @note Must be called before SRAM2 read/write operations"]
    pub fn furi_hal_bt_nvm_sram_sem_acquire();
}
extern "C" {
    #[doc = " Release SRAM2 hardware semaphore\n @note Must be called after SRAM2 read/write operations"]
    pub fn furi_hal_bt_nvm_sram_sem_release();
}
extern "C" {
    #[doc = " Clear key storage\n\n @return      true on success"]
    pub fn furi_hal_bt_clear_white_list() -> bool;
}
extern "C" {
    #[doc = " Set key storage change callback\n\n @param       callback    BleGlueKeyStorageChangedCallback instance\n @param       context     pointer to context"]
    pub fn furi_hal_bt_set_key_storage_change_callback(
        callback: BleGlueKeyStorageChangedCallback,
        context: *mut core::ffi::c_void,
    );
}
extern "C" {
    #[doc = " Start ble tone tx at given channel and power\n\n @param[in]  channel  The channel\n @param[in]  power    The power"]
    pub fn furi_hal_bt_start_tone_tx(channel: u8, power: u8);
}
extern "C" {
    #[doc = " Stop ble tone tx"]
    pub fn furi_hal_bt_stop_tone_tx();
}
extern "C" {
    #[doc = " Start sending ble packets at a given frequency and datarate\n\n @param[in]  channel   The channel\n @param[in]  pattern   The pattern\n @param[in]  datarate  The datarate"]
    pub fn furi_hal_bt_start_packet_tx(channel: u8, pattern: u8, datarate: u8);
}
extern "C" {
    #[doc = " Stop sending ble packets\n\n @return     sent packet count"]
    pub fn furi_hal_bt_stop_packet_test() -> u16;
}
extern "C" {
    #[doc = " Start receiving packets\n\n @param[in]  channel   RX channel\n @param[in]  datarate  Datarate"]
    pub fn furi_hal_bt_start_packet_rx(channel: u8, datarate: u8);
}
extern "C" {
    #[doc = " Set up the RF to listen to a given RF channel\n\n @param[in]  channel  RX channel"]
    pub fn furi_hal_bt_start_rx(channel: u8);
}
extern "C" {
    #[doc = " Stop RF listenning"]
    pub fn furi_hal_bt_stop_rx();
}
extern "C" {
    #[doc = " Get RSSI\n\n @return     RSSI in dBm"]
    pub fn furi_hal_bt_get_rssi() -> f32;
}
extern "C" {
    #[doc = " Get number of transmitted packets\n\n @return     packet count"]
    pub fn furi_hal_bt_get_transmitted_packets() -> u32;
}
extern "C" {
    #[doc = " Check & switch C2 to given mode\n\n @param[in]  mode  mode to switch into"]
    pub fn furi_hal_bt_ensure_c2_mode(mode: BleGlueC2Mode) -> bool;
}
extern "C" {
    #[doc = " Preset for ST25R916"]
    pub static furi_hal_spi_preset_2edge_low_8m: LL_SPI_InitTypeDef;
}
extern "C" {
    #[doc = " Preset for CC1101"]
    pub static furi_hal_spi_preset_1edge_low_8m: LL_SPI_InitTypeDef;
}
extern "C" {
    #[doc = " Preset for ST7567 (Display)"]
    pub static furi_hal_spi_preset_1edge_low_4m: LL_SPI_InitTypeDef;
}
extern "C" {
    #[doc = " Preset for SdCard in fast mode"]
    pub static furi_hal_spi_preset_1edge_low_16m: LL_SPI_InitTypeDef;
}
extern "C" {
    #[doc = " Preset for SdCard in slow mode"]
    pub static furi_hal_spi_preset_1edge_low_2m: LL_SPI_InitTypeDef;
}
extern "C" {
    #[doc = " Furi Hal Spi Bus R (Radio: CC1101, Nfc, External)"]
    pub static mut furi_hal_spi_bus_r: FuriHalSpiBus;
}
extern "C" {
    #[doc = " Furi Hal Spi Bus D (Display, SdCard)"]
    pub static mut furi_hal_spi_bus_d: FuriHalSpiBus;
}
extern "C" {
    #[doc = " CC1101 on `furi_hal_spi_bus_r`"]
    pub static mut furi_hal_spi_bus_handle_subghz: FuriHalSpiBusHandle;
}
extern "C" {
    #[doc = " ST25R3916 on `furi_hal_spi_bus_r`"]
    pub static mut furi_hal_spi_bus_handle_nfc: FuriHalSpiBusHandle;
}
extern "C" {
    #[doc = " External on `furi_hal_spi_bus_r`\n Preset: `furi_hal_spi_preset_1edge_low_2m`\n\n miso: pa6\n mosi: pa7\n sck: pb3\n cs:  pa4 (software controlled)\n\n @warning not initialized by default, call `furi_hal_spi_bus_handle_init` to initialize\n Bus pins are floating on inactive state, CS high after initialization\n"]
    pub static mut furi_hal_spi_bus_handle_external: FuriHalSpiBusHandle;
}
extern "C" {
    #[doc = " ST7567(Display) on `furi_hal_spi_bus_d`"]
    pub static mut furi_hal_spi_bus_handle_display: FuriHalSpiBusHandle;
}
extern "C" {
    #[doc = " SdCard in fast mode on `furi_hal_spi_bus_d`"]
    pub static mut furi_hal_spi_bus_handle_sd_fast: FuriHalSpiBusHandle;
}
extern "C" {
    #[doc = " SdCard in slow mode on `furi_hal_spi_bus_d`"]
    pub static mut furi_hal_spi_bus_handle_sd_slow: FuriHalSpiBusHandle;
}
extern "C" {
    #[doc = " Initialize SPI Bus\n\n @param      handle  pointer to FuriHalSpiBus instance"]
    pub fn furi_hal_spi_bus_init(bus: *mut FuriHalSpiBus);
}
extern "C" {
    #[doc = " Deinitialize SPI Bus\n\n @param      handle  pointer to FuriHalSpiBus instance"]
    pub fn furi_hal_spi_bus_deinit(bus: *mut FuriHalSpiBus);
}
extern "C" {
    #[doc = " Initialize SPI Bus Handle\n\n @param      handle  pointer to FuriHalSpiBusHandle instance"]
    pub fn furi_hal_spi_bus_handle_init(handle: *mut FuriHalSpiBusHandle);
}
extern "C" {
    #[doc = " Deinitialize SPI Bus Handle\n\n @param      handle  pointer to FuriHalSpiBusHandle instance"]
    pub fn furi_hal_spi_bus_handle_deinit(handle: *mut FuriHalSpiBusHandle);
}
extern "C" {
    #[doc = " Acquire SPI bus\n\n @warning blocking, calls `furi_crash` on programming error, CS transition is up to handler event routine\n\n @param      handle  pointer to FuriHalSpiBusHandle instance"]
    pub fn furi_hal_spi_acquire(handle: *mut FuriHalSpiBusHandle);
}
extern "C" {
    #[doc = " Release SPI bus\n\n @warning calls `furi_crash` on programming error, CS transition is up to handler event routine\n\n @param      handle  pointer to FuriHalSpiBusHandle instance"]
    pub fn furi_hal_spi_release(handle: *mut FuriHalSpiBusHandle);
}
extern "C" {
    #[doc = " SPI Receive\n\n @param      handle   pointer to FuriHalSpiBusHandle instance\n @param      buffer   receive buffer\n @param      size     transaction size (buffer size)\n @param      timeout  operation timeout in ms\n\n @return     true on sucess"]
    pub fn furi_hal_spi_bus_rx(
        handle: *mut FuriHalSpiBusHandle,
        buffer: *mut u8,
        size: usize,
        timeout: u32,
    ) -> bool;
}
extern "C" {
    #[doc = " SPI Transmit\n\n @param      handle   pointer to FuriHalSpiBusHandle instance\n @param      buffer   transmit buffer\n @param      size     transaction size (buffer size)\n @param      timeout  operation timeout in ms\n\n @return     true on success"]
    pub fn furi_hal_spi_bus_tx(
        handle: *mut FuriHalSpiBusHandle,
        buffer: *const u8,
        size: usize,
        timeout: u32,
    ) -> bool;
}
extern "C" {
    #[doc = " SPI Transmit and Receive\n\n @param      handle     pointer to FuriHalSpiBusHandle instance\n @param      tx_buffer  pointer to tx buffer\n @param      rx_buffer  pointer to rx buffer\n @param      size       transaction size (buffer size)\n @param      timeout    operation timeout in ms\n\n @return     true on success"]
    pub fn furi_hal_spi_bus_trx(
        handle: *mut FuriHalSpiBusHandle,
        tx_buffer: *const u8,
        rx_buffer: *mut u8,
        size: usize,
        timeout: u32,
    ) -> bool;
}
extern "C" {
    #[doc = " SPI Transmit and Receive with DMA\n\n @param      handle     pointer to FuriHalSpiBusHandle instance\n @param      tx_buffer  pointer to tx buffer\n @param      rx_buffer  pointer to rx buffer\n @param      size       transaction size (buffer size)\n @param      timeout_ms operation timeout in ms\n\n @return     true on success"]
    pub fn furi_hal_spi_bus_trx_dma(
        handle: *mut FuriHalSpiBusHandle,
        tx_buffer: *mut u8,
        rx_buffer: *mut u8,
        size: usize,
        timeout_ms: u32,
    ) -> bool;
}
extern "C" {
    #[doc = " Turn on/off vibro\n\n @param[in]  value  new state"]
    pub fn furi_hal_vibro_on(value: bool);
}
#[doc = "<\\brief Function has an error, STALLPID will be issued."]
pub const _usbd_respond_usbd_fail: _usbd_respond = 0;
#[doc = "<\\brief Function completes request accepted ZLP or data will be send."]
pub const _usbd_respond_usbd_ack: _usbd_respond = 1;
#[doc = "<\\brief Function is busy. NAK handshake."]
pub const _usbd_respond_usbd_nak: _usbd_respond = 2;
#[doc = "\\brief Reporting status results."]
pub type _usbd_respond = core::ffi::c_uchar;
#[doc = "\\brief Reporting status results."]
pub use self::_usbd_respond as usbd_respond;
#[doc = "\\brief Represents a USB device data."]
pub type usbd_device = _usbd_device;
#[doc = "\\brief Represents generic USB control request."]
#[repr(C)]
#[derive(Debug)]
pub struct usbd_ctlreq {
    #[doc = "<\\brief This bitmapped field identifies the characteristics of\n the specific request."]
    pub bmRequestType: u8,
    #[doc = "<\\brief This field specifies the particular request."]
    pub bRequest: u8,
    #[doc = "<\\brief It is used to pass a parameter to the device, specific to\n the request."]
    pub wValue: u16,
    #[doc = "<\\brief It is used to pass a parameter to the device, specific to\n the request."]
    pub wIndex: u16,
    #[doc = "<\\brief This field specifies the length of the data transferred\n during the second phase of the control transfer."]
    pub wLength: u16,
    #[doc = "<\\brief Data payload."]
    pub data: __IncompleteArrayField<u8>,
}
#[test]
fn bindgen_test_layout_usbd_ctlreq() {
    const UNINIT: ::core::mem::MaybeUninit<usbd_ctlreq> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<usbd_ctlreq>(),
        8usize,
        concat!("Size of: ", stringify!(usbd_ctlreq))
    );
    assert_eq!(
        ::core::mem::align_of::<usbd_ctlreq>(),
        2usize,
        concat!("Alignment of ", stringify!(usbd_ctlreq))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bmRequestType) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(usbd_ctlreq),
            "::",
            stringify!(bmRequestType)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bRequest) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(usbd_ctlreq),
            "::",
            stringify!(bRequest)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).wValue) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(usbd_ctlreq),
            "::",
            stringify!(wValue)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).wIndex) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(usbd_ctlreq),
            "::",
            stringify!(wIndex)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).wLength) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(usbd_ctlreq),
            "::",
            stringify!(wLength)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(usbd_ctlreq),
            "::",
            stringify!(data)
        )
    );
}
#[doc = " USB device status data."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct usbd_status {
    #[doc = "<\\brief Pointer to data buffer used for control requests."]
    pub data_buf: *mut core::ffi::c_void,
    #[doc = "<\\brief Pointer to current data for control request."]
    pub data_ptr: *mut core::ffi::c_void,
    #[doc = "<\\brief Count remained data for control request."]
    pub data_count: u16,
    #[doc = "<\\brief Size of the data buffer for control requests."]
    pub data_maxsize: u16,
    #[doc = "<\\brief Size of the control endpoint."]
    pub ep0size: u8,
    #[doc = "<\\brief Current device configuration number."]
    pub device_cfg: u8,
    #[doc = "<\\brief Current \\ref usbd_machine_state."]
    pub device_state: u8,
    #[doc = "<\\brief Current \\ref usbd_ctl_state."]
    pub control_state: u8,
}
#[test]
fn bindgen_test_layout_usbd_status() {
    const UNINIT: ::core::mem::MaybeUninit<usbd_status> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<usbd_status>(),
        16usize,
        concat!("Size of: ", stringify!(usbd_status))
    );
    assert_eq!(
        ::core::mem::align_of::<usbd_status>(),
        4usize,
        concat!("Alignment of ", stringify!(usbd_status))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).data_buf) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(usbd_status),
            "::",
            stringify!(data_buf)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).data_ptr) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(usbd_status),
            "::",
            stringify!(data_ptr)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).data_count) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(usbd_status),
            "::",
            stringify!(data_count)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).data_maxsize) as usize - ptr as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(usbd_status),
            "::",
            stringify!(data_maxsize)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ep0size) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(usbd_status),
            "::",
            stringify!(ep0size)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).device_cfg) as usize - ptr as usize },
        13usize,
        concat!(
            "Offset of field: ",
            stringify!(usbd_status),
            "::",
            stringify!(device_cfg)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).device_state) as usize - ptr as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(usbd_status),
            "::",
            stringify!(device_state)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).control_state) as usize - ptr as usize },
        15usize,
        concat!(
            "Offset of field: ",
            stringify!(usbd_status),
            "::",
            stringify!(control_state)
        )
    );
}
#[doc = "\\brief Generic USB device event callback for events and endpoints processing\n \\param[in] dev pointer to USB device\n \\param event \\ref USB_EVENTS \"USB event\"\n \\param ep active endpoint number\n \\note endpoints with same indexes i.e. 0x01 and 0x81 shares same callback."]
pub type usbd_evt_callback =
    ::core::option::Option<unsafe extern "C" fn(dev: *mut usbd_device, event: u8, ep: u8)>;
#[doc = "\\brief USB control transfer completed callback function.\n \\param[in] dev pointer to USB device\n \\param[in] req pointer to usb request structure\n \\note usbd_device->complete_callback will be set to NULL after this callback completion."]
pub type usbd_rqc_callback =
    ::core::option::Option<unsafe extern "C" fn(dev: *mut usbd_device, req: *mut usbd_ctlreq)>;
#[doc = "\\brief USB control callback function.\n \\details Uses for the control request processing.\n          Some requests will be handled by core if callback don't process it (returns FALSE).\n            If request was not processed STALL PID will be issued.\n          - GET_CONFIGURATION\n          - SET_CONFIGURATION (passes to \\ref usbd_cfg_callback)\n          - GET_DESCRIPTOR (passes to \\ref usbd_dsc_callback)\n          - GET_STATUS\n          - SET_FEATURE, CLEAR_FEATURE (endpoints only)\n          - SET_ADDRESS\n \\param[in] dev points to USB device\n \\param[in] req points to usb control request\n \\param[out] *callback USB control transfer completion callback, default is NULL (no callback)\n \\return usbd_respond status."]
pub type usbd_ctl_callback = ::core::option::Option<
    unsafe extern "C" fn(
        dev: *mut usbd_device,
        req: *mut usbd_ctlreq,
        callback: *mut usbd_rqc_callback,
    ) -> usbd_respond,
>;
#[doc = "\\brief USB get descriptor callback function\n \\details Called when GET_DESCRIPTOR request issued\n \\param[in] req pointer to usb control request structure\n \\param[in,out] address pointer to the descriptor in memory. Points to req->data by default. You\n can use this buffer.\n \\param[in,out] dsize descriptor size. maximum buffer size by default.\n \\return usbd_ack if you passed the correct descriptor, usbd_fail otherwise."]
pub type usbd_dsc_callback = ::core::option::Option<
    unsafe extern "C" fn(
        req: *mut usbd_ctlreq,
        address: *mut *mut core::ffi::c_void,
        dsize: *mut u16,
    ) -> usbd_respond,
>;
#[doc = "\\brief USB set configuration callback function\n \\details called when SET_CONFIGURATION request issued\n \\param[in] dev pointer to USB device\n \\param[in] cfg configuration number.\n \\note if config is 0 device endpoints should be de-configured\n \\return TRUE if success"]
pub type usbd_cfg_callback =
    ::core::option::Option<unsafe extern "C" fn(dev: *mut usbd_device, cfg: u8) -> usbd_respond>;
#[doc = "\\addtogroup USBD_HW\n @{ */\n/**\\brief Get USB device status and capabilities.\n \\return Hardware status and capabilities \\ref USBD_HW_CAPS"]
pub type usbd_hw_getinfo = ::core::option::Option<unsafe extern "C" fn() -> u32>;
#[doc = "\\brief Enables or disables USB hardware\n \\param enable Enables USB when TRUE disables otherwise."]
pub type usbd_hw_enable = ::core::option::Option<unsafe extern "C" fn(enable: bool)>;
#[doc = " Connects or disconnects USB hardware to/from usb host\n \\param connect Connects USB to host if TRUE, disconnects otherwise\n \\return lanes connection status."]
pub type usbd_hw_connect = ::core::option::Option<unsafe extern "C" fn(connect: bool) -> u8>;
#[doc = "\\brief Sets USB hardware address\n \\param address USB address"]
pub type usbd_hw_setaddr = ::core::option::Option<unsafe extern "C" fn(address: u8)>;
#[doc = "\\brief Configures endpoint\n \\param ep endpoint address. Use USB_EPDIR_ macros to set endpoint direction\n \\param eptype endpoint type. Use USB_EPTYPE_* macros.\n \\param epsize endpoint size in bytes\n \\return TRUE if success"]
pub type usbd_hw_ep_config =
    ::core::option::Option<unsafe extern "C" fn(ep: u8, eptype: u8, epsize: u16) -> bool>;
#[doc = "\\brief De-configures, cleans and disables endpoint\n \\param ep endpoint index\n \\note if you have two one-direction single-buffered endpoints with same index (i.e. 0x02 and 0x82)\n both will be deconfigured."]
pub type usbd_hw_ep_deconfig = ::core::option::Option<unsafe extern "C" fn(ep: u8)>;
#[doc = "\\brief Reads data from OUT or control endpoint\n \\param ep endpoint index, should belong to OUT or CONTROL endpoint.\n \\param buf pointer to read buffer\n \\param blen size of the read buffer in bytes\n \\return size of the actually received data, -1 on error.\n \\note if data does not fit buffer it will be truncated"]
pub type usbd_hw_ep_read = ::core::option::Option<
    unsafe extern "C" fn(ep: u8, buf: *mut core::ffi::c_void, blen: u16) -> i32,
>;
#[doc = "\\brief Writes data to IN or control endpoint\n \\param ep endpoint index, hould belong to IN or CONTROL endpoint\n \\param buf pointer to data buffer\n \\param blen size of data will be written\n \\return number of written bytes"]
pub type usbd_hw_ep_write = ::core::option::Option<
    unsafe extern "C" fn(ep: u8, buf: *const core::ffi::c_void, blen: u16) -> i32,
>;
#[doc = " Stalls and unstalls endpoint\n \\param ep endpoint address\n \\param stall endpoint will be stalled if TRUE and unstalled otherwise.\n \\note Has no effect on inactive endpoints."]
pub type usbd_hw_ep_setstall = ::core::option::Option<unsafe extern "C" fn(ep: u8, stall: bool)>;
#[doc = "\\brief Checks endpoint for stalled state\n \\param ep endpoint address\n \\return TRUE if endpoint is stalled"]
pub type usbd_hw_ep_isstalled = ::core::option::Option<unsafe extern "C" fn(ep: u8) -> bool>;
#[doc = "\\brief Polls USB hardware for the events\n \\param[in] dev pointer to usb device structure\n \\param callback callback to event processing subroutine"]
pub type usbd_hw_poll = ::core::option::Option<
    unsafe extern "C" fn(dev: *mut usbd_device, callback: usbd_evt_callback),
>;
#[doc = "\\brief Gets frame number from usb hardware."]
pub type usbd_hw_get_frameno = ::core::option::Option<unsafe extern "C" fn() -> u16>;
#[doc = "\\brief Makes a string descriptor contains unique serial number from hardware ID's\n \\param[in] buffer pointer to buffer for the descriptor\n \\return of the descriptor in bytes"]
pub type usbd_hw_get_serialno =
    ::core::option::Option<unsafe extern "C" fn(buffer: *mut core::ffi::c_void) -> u16>;
#[doc = "\\brief Represents a hardware USB driver call table."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct usbd_driver {
    #[doc = "<\\copybrief usbd_hw_getinfo"]
    pub getinfo: usbd_hw_getinfo,
    #[doc = "<\\copybrief usbd_hw_enable"]
    pub enable: usbd_hw_enable,
    #[doc = "<\\copybrief usbd_hw_connect"]
    pub connect: usbd_hw_connect,
    #[doc = "<\\copybrief usbd_hw_setaddr"]
    pub setaddr: usbd_hw_setaddr,
    #[doc = "<\\copybrief usbd_hw_ep_config"]
    pub ep_config: usbd_hw_ep_config,
    #[doc = "<\\copybrief usbd_hw_ep_deconfig"]
    pub ep_deconfig: usbd_hw_ep_deconfig,
    #[doc = "<\\copybrief usbd_hw_ep_read"]
    pub ep_read: usbd_hw_ep_read,
    #[doc = "<\\copybrief usbd_hw_ep_write"]
    pub ep_write: usbd_hw_ep_write,
    #[doc = "<\\copybrief usbd_hw_ep_setstall"]
    pub ep_setstall: usbd_hw_ep_setstall,
    #[doc = "<\\copybrief usbd_hw_ep_isstalled"]
    pub ep_isstalled: usbd_hw_ep_isstalled,
    #[doc = "<\\copybrief usbd_hw_poll"]
    pub poll: usbd_hw_poll,
    #[doc = "<\\copybrief usbd_hw_get_frameno"]
    pub frame_no: usbd_hw_get_frameno,
    #[doc = "<\\copybrief usbd_hw_get_serialno"]
    pub get_serialno_desc: usbd_hw_get_serialno,
}
#[test]
fn bindgen_test_layout_usbd_driver() {
    const UNINIT: ::core::mem::MaybeUninit<usbd_driver> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<usbd_driver>(),
        52usize,
        concat!("Size of: ", stringify!(usbd_driver))
    );
    assert_eq!(
        ::core::mem::align_of::<usbd_driver>(),
        4usize,
        concat!("Alignment of ", stringify!(usbd_driver))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).getinfo) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(usbd_driver),
            "::",
            stringify!(getinfo)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).enable) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(usbd_driver),
            "::",
            stringify!(enable)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).connect) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(usbd_driver),
            "::",
            stringify!(connect)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).setaddr) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(usbd_driver),
            "::",
            stringify!(setaddr)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ep_config) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(usbd_driver),
            "::",
            stringify!(ep_config)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ep_deconfig) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(usbd_driver),
            "::",
            stringify!(ep_deconfig)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ep_read) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(usbd_driver),
            "::",
            stringify!(ep_read)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ep_write) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(usbd_driver),
            "::",
            stringify!(ep_write)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ep_setstall) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(usbd_driver),
            "::",
            stringify!(ep_setstall)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ep_isstalled) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(usbd_driver),
            "::",
            stringify!(ep_isstalled)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).poll) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(usbd_driver),
            "::",
            stringify!(poll)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).frame_no) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(usbd_driver),
            "::",
            stringify!(frame_no)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_serialno_desc) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(usbd_driver),
            "::",
            stringify!(get_serialno_desc)
        )
    );
}
#[doc = "\\brief Represents a USB device data."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _usbd_device {
    #[doc = "<\\copybrief usbd_driver"]
    pub driver: *const usbd_driver,
    #[doc = "<\\copybrief usbd_ctl_callback"]
    pub control_callback: usbd_ctl_callback,
    #[doc = "<\\copybrief usbd_rqc_callback"]
    pub complete_callback: usbd_rqc_callback,
    #[doc = "<\\copybrief usbd_cfg_callback"]
    pub config_callback: usbd_cfg_callback,
    #[doc = "<\\copybrief usbd_dsc_callback"]
    pub descriptor_callback: usbd_dsc_callback,
    #[doc = "<\\brief array of the event callbacks."]
    pub events: [usbd_evt_callback; 8usize],
    #[doc = "<\\brief array of the endpoint callbacks."]
    pub endpoint: [usbd_evt_callback; 8usize],
    #[doc = "<\\copybrief usbd_status"]
    pub status: usbd_status,
}
#[test]
fn bindgen_test_layout__usbd_device() {
    const UNINIT: ::core::mem::MaybeUninit<_usbd_device> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_usbd_device>(),
        100usize,
        concat!("Size of: ", stringify!(_usbd_device))
    );
    assert_eq!(
        ::core::mem::align_of::<_usbd_device>(),
        4usize,
        concat!("Alignment of ", stringify!(_usbd_device))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).driver) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_usbd_device),
            "::",
            stringify!(driver)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).control_callback) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_usbd_device),
            "::",
            stringify!(control_callback)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).complete_callback) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_usbd_device),
            "::",
            stringify!(complete_callback)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).config_callback) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_usbd_device),
            "::",
            stringify!(config_callback)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).descriptor_callback) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_usbd_device),
            "::",
            stringify!(descriptor_callback)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).events) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_usbd_device),
            "::",
            stringify!(events)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).endpoint) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(_usbd_device),
            "::",
            stringify!(endpoint)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).status) as usize - ptr as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(_usbd_device),
            "::",
            stringify!(status)
        )
    );
}
#[doc = "\\brief Represents a USB device descriptor\n \\details A device descriptor describes general information about a USB device. It includes\n information that applies globally to the device and all of the device’s configurations. A USB\n device has only one device descriptor. A high-speed capable device that has different device\n information for full-speed and high-speed must also  have a \\ref usb_qualifier_descriptor."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct usb_device_descriptor {
    #[doc = "<\\brief Size of the descriptor, in bytes."]
    pub bLength: u8,
    #[doc = "<\\brief \\ref USB_DTYPE_DEVICE Device descriptor."]
    pub bDescriptorType: u8,
    #[doc = "<\\brief BCD of the supported USB specification."]
    pub bcdUSB: u16,
    #[doc = "<\\brief USB device class."]
    pub bDeviceClass: u8,
    #[doc = "<\\brief USB device subclass."]
    pub bDeviceSubClass: u8,
    #[doc = "<\\brief USB device protocol."]
    pub bDeviceProtocol: u8,
    #[doc = "<\\brief Size of the control endpoint's bank in bytes."]
    pub bMaxPacketSize0: u8,
    #[doc = "<\\brief Vendor ID for the USB product."]
    pub idVendor: u16,
    #[doc = "<\\brief Unique product ID for the USB product."]
    pub idProduct: u16,
    #[doc = "<\\brief Product release (version) number."]
    pub bcdDevice: u16,
    #[doc = "<\\brief String index for the manufacturer's name."]
    pub iManufacturer: u8,
    #[doc = "<\\brief String index for the product name/details."]
    pub iProduct: u8,
    #[doc = "<\\brief String index for the product serial number."]
    pub iSerialNumber: u8,
    #[doc = "<\\brief Total number of configurations supported by the device."]
    pub bNumConfigurations: u8,
}
#[test]
fn bindgen_test_layout_usb_device_descriptor() {
    const UNINIT: ::core::mem::MaybeUninit<usb_device_descriptor> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<usb_device_descriptor>(),
        18usize,
        concat!("Size of: ", stringify!(usb_device_descriptor))
    );
    assert_eq!(
        ::core::mem::align_of::<usb_device_descriptor>(),
        1usize,
        concat!("Alignment of ", stringify!(usb_device_descriptor))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bLength) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_device_descriptor),
            "::",
            stringify!(bLength)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bDescriptorType) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_device_descriptor),
            "::",
            stringify!(bDescriptorType)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bcdUSB) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_device_descriptor),
            "::",
            stringify!(bcdUSB)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bDeviceClass) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_device_descriptor),
            "::",
            stringify!(bDeviceClass)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bDeviceSubClass) as usize - ptr as usize },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_device_descriptor),
            "::",
            stringify!(bDeviceSubClass)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bDeviceProtocol) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_device_descriptor),
            "::",
            stringify!(bDeviceProtocol)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bMaxPacketSize0) as usize - ptr as usize },
        7usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_device_descriptor),
            "::",
            stringify!(bMaxPacketSize0)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).idVendor) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_device_descriptor),
            "::",
            stringify!(idVendor)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).idProduct) as usize - ptr as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_device_descriptor),
            "::",
            stringify!(idProduct)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bcdDevice) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_device_descriptor),
            "::",
            stringify!(bcdDevice)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).iManufacturer) as usize - ptr as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_device_descriptor),
            "::",
            stringify!(iManufacturer)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).iProduct) as usize - ptr as usize },
        15usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_device_descriptor),
            "::",
            stringify!(iProduct)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).iSerialNumber) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_device_descriptor),
            "::",
            stringify!(iSerialNumber)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bNumConfigurations) as usize - ptr as usize },
        17usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_device_descriptor),
            "::",
            stringify!(bNumConfigurations)
        )
    );
}
extern "C" {
    pub static usbd_devfs: usbd_driver;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FuriHalUsbInterface {
    pub init: ::core::option::Option<
        unsafe extern "C" fn(
            dev: *mut usbd_device,
            intf: *mut FuriHalUsbInterface,
            ctx: *mut core::ffi::c_void,
        ),
    >,
    pub deinit: ::core::option::Option<unsafe extern "C" fn(dev: *mut usbd_device)>,
    pub wakeup: ::core::option::Option<unsafe extern "C" fn(dev: *mut usbd_device)>,
    pub suspend: ::core::option::Option<unsafe extern "C" fn(dev: *mut usbd_device)>,
    pub dev_descr: *mut usb_device_descriptor,
    pub str_manuf_descr: *mut core::ffi::c_void,
    pub str_prod_descr: *mut core::ffi::c_void,
    pub str_serial_descr: *mut core::ffi::c_void,
    pub cfg_descr: *mut core::ffi::c_void,
}
#[test]
fn bindgen_test_layout_FuriHalUsbInterface() {
    const UNINIT: ::core::mem::MaybeUninit<FuriHalUsbInterface> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<FuriHalUsbInterface>(),
        36usize,
        concat!("Size of: ", stringify!(FuriHalUsbInterface))
    );
    assert_eq!(
        ::core::mem::align_of::<FuriHalUsbInterface>(),
        4usize,
        concat!("Alignment of ", stringify!(FuriHalUsbInterface))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).init) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FuriHalUsbInterface),
            "::",
            stringify!(init)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).deinit) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(FuriHalUsbInterface),
            "::",
            stringify!(deinit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).wakeup) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(FuriHalUsbInterface),
            "::",
            stringify!(wakeup)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).suspend) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(FuriHalUsbInterface),
            "::",
            stringify!(suspend)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).dev_descr) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(FuriHalUsbInterface),
            "::",
            stringify!(dev_descr)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).str_manuf_descr) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(FuriHalUsbInterface),
            "::",
            stringify!(str_manuf_descr)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).str_prod_descr) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(FuriHalUsbInterface),
            "::",
            stringify!(str_prod_descr)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).str_serial_descr) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(FuriHalUsbInterface),
            "::",
            stringify!(str_serial_descr)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).cfg_descr) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(FuriHalUsbInterface),
            "::",
            stringify!(cfg_descr)
        )
    );
}
extern "C" {
    #[doc = " USB device interface modes"]
    pub static mut usb_cdc_single: FuriHalUsbInterface;
}
extern "C" {
    pub static mut usb_cdc_dual: FuriHalUsbInterface;
}
extern "C" {
    pub static mut usb_hid: FuriHalUsbInterface;
}
extern "C" {
    pub static mut usb_hid_u2f: FuriHalUsbInterface;
}
extern "C" {
    #[doc = " Set USB device configuration\n\n @param      mode new USB device mode\n @param      ctx context passed to device mode init function\n @return     true - mode switch started, false - mode switch is locked"]
    pub fn furi_hal_usb_set_config(
        new_if: *mut FuriHalUsbInterface,
        ctx: *mut core::ffi::c_void,
    ) -> bool;
}
extern "C" {
    #[doc = " Get USB device configuration\n\n @return    current USB device mode"]
    pub fn furi_hal_usb_get_config() -> *mut FuriHalUsbInterface;
}
extern "C" {
    #[doc = " Lock USB device mode switch"]
    pub fn furi_hal_usb_lock();
}
extern "C" {
    #[doc = " Unlock USB device mode switch"]
    pub fn furi_hal_usb_unlock();
}
extern "C" {
    #[doc = " Check if USB device mode switch locked\n\n @return    lock state"]
    pub fn furi_hal_usb_is_locked() -> bool;
}
extern "C" {
    #[doc = " Disable USB device"]
    pub fn furi_hal_usb_disable();
}
extern "C" {
    #[doc = " Enable USB device"]
    pub fn furi_hal_usb_enable();
}
extern "C" {
    #[doc = " Restart USB device"]
    pub fn furi_hal_usb_reinit();
}
pub type HidStateCallback =
    ::core::option::Option<unsafe extern "C" fn(state: bool, context: *mut core::ffi::c_void)>;
extern "C" {
    #[doc = " Get USB HID connection state\n\n @return      true / false"]
    pub fn furi_hal_hid_is_connected() -> bool;
}
extern "C" {
    #[doc = " Get USB HID keyboard leds state\n\n @return      leds state"]
    pub fn furi_hal_hid_get_led_state() -> u8;
}
extern "C" {
    #[doc = " Set USB HID connect/disconnect callback\n\n @param      cb  callback\n @param      ctx  callback context"]
    pub fn furi_hal_hid_set_state_callback(cb: HidStateCallback, ctx: *mut core::ffi::c_void);
}
extern "C" {
    #[doc = " Set the following key to pressed state and send HID report\n\n @param      button  key code"]
    pub fn furi_hal_hid_kb_press(button: u16) -> bool;
}
extern "C" {
    #[doc = " Set the following key to released state and send HID report\n\n @param      button  key code"]
    pub fn furi_hal_hid_kb_release(button: u16) -> bool;
}
extern "C" {
    #[doc = " Clear all pressed keys and send HID report\n"]
    pub fn furi_hal_hid_kb_release_all() -> bool;
}
extern "C" {
    #[doc = " Set mouse movement and send HID report\n\n @param      dx  x coordinate delta\n @param      dy  y coordinate delta"]
    pub fn furi_hal_hid_mouse_move(dx: i8, dy: i8) -> bool;
}
extern "C" {
    #[doc = " Set mouse button to pressed state and send HID report\n\n @param      button  key code"]
    pub fn furi_hal_hid_mouse_press(button: u8) -> bool;
}
extern "C" {
    #[doc = " Set mouse button to released state and send HID report\n\n @param      button  key code"]
    pub fn furi_hal_hid_mouse_release(button: u8) -> bool;
}
extern "C" {
    #[doc = " Set mouse wheel position and send HID report\n\n @param      delta  number of scroll steps"]
    pub fn furi_hal_hid_mouse_scroll(delta: i8) -> bool;
}
extern "C" {
    #[doc = " Set the following consumer key to pressed state and send HID report\n\n @param      button  key code"]
    pub fn furi_hal_hid_consumer_key_press(button: u16) -> bool;
}
extern "C" {
    #[doc = " Set the following consumer key to released state and send HID report\n\n @param      button  key code"]
    pub fn furi_hal_hid_consumer_key_release(button: u16) -> bool;
}
pub const FuriHalUartId_FuriHalUartIdUSART1: FuriHalUartId = 0;
pub const FuriHalUartId_FuriHalUartIdLPUART1: FuriHalUartId = 1;
#[doc = " UART channels"]
pub type FuriHalUartId = core::ffi::c_uchar;
pub const UartIrqEvent_UartIrqEventRXNE: UartIrqEvent = 0;
#[doc = " UART events"]
pub type UartIrqEvent = core::ffi::c_uchar;
extern "C" {
    #[doc = " Init UART\n Configures GPIO to UART function, сonfigures UART hardware, enables UART hardware\n @param channel UART channel\n @param baud baudrate"]
    pub fn furi_hal_uart_init(channel: FuriHalUartId, baud: u32);
}
extern "C" {
    #[doc = " Deinit UART\n Configures GPIO to analog, clears callback and callback context, disables UART hardware\n @param channel UART channel"]
    pub fn furi_hal_uart_deinit(channel: FuriHalUartId);
}
extern "C" {
    #[doc = " Suspend UART operation\n Disables UART hardware, settings and callbacks are preserved\n @param channel UART channel"]
    pub fn furi_hal_uart_suspend(channel: FuriHalUartId);
}
extern "C" {
    #[doc = " Resume UART operation\n Resumes UART hardware from suspended state\n @param channel UART channel"]
    pub fn furi_hal_uart_resume(channel: FuriHalUartId);
}
extern "C" {
    #[doc = " Changes UART baudrate\n @param channel UART channel\n @param baud baudrate"]
    pub fn furi_hal_uart_set_br(channel: FuriHalUartId, baud: u32);
}
extern "C" {
    #[doc = " Transmits data\n @param channel UART channel\n @param buffer data\n @param buffer_size data size (in bytes)"]
    pub fn furi_hal_uart_tx(channel: FuriHalUartId, buffer: *mut u8, buffer_size: usize);
}
extern "C" {
    #[doc = " Sets UART event callback\n @param channel UART channel\n @param callback callback pointer\n @param context callback context"]
    pub fn furi_hal_uart_set_irq_cb(
        channel: FuriHalUartId,
        callback: ::core::option::Option<
            unsafe extern "C" fn(event: UartIrqEvent, data: u8, context: *mut core::ffi::c_void),
        >,
        context: *mut core::ffi::c_void,
    );
}
extern "C" {
    #[doc = " Get device information\n\n @param[in]  callback     callback to provide with new data\n @param[in]  sep          category separator character\n @param[in]  context      context to pass to callback"]
    pub fn furi_hal_info_get(
        callback: PropertyValueCallback,
        sep: core::ffi::c_char,
        context: *mut core::ffi::c_void,
    );
}
extern "C" {
    #[doc = " Get random value\n\n @return     random value"]
    pub fn furi_hal_random_get() -> u32;
}
extern "C" {
    #[doc = " Fill buffer with random data\n\n @param      buf  buffer pointer\n @param      data buffer len"]
    pub fn furi_hal_random_fill_buf(buf: *mut u8, len: u32);
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct LevelDuration {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_LevelDuration() {
    assert_eq!(
        ::core::mem::size_of::<LevelDuration>(),
        4usize,
        concat!("Size of: ", stringify!(LevelDuration))
    );
    assert_eq!(
        ::core::mem::align_of::<LevelDuration>(),
        4usize,
        concat!("Alignment of ", stringify!(LevelDuration))
    );
}
impl LevelDuration {
    #[inline]
    pub fn duration(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 30u8) as u32) }
    }
    #[inline]
    pub fn set_duration(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 30u8, val as u64)
        }
    }
    #[inline]
    pub fn level(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(30usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_level(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(30usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(duration: u32, level: u8) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 30u8, {
            let duration: u32 = unsafe { ::core::mem::transmute(duration) };
            duration as u64
        });
        __bindgen_bitfield_unit.set(30usize, 2u8, {
            let level: u8 = unsafe { ::core::mem::transmute(level) };
            level as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = "< default configuration"]
pub const FuriHalSubGhzPreset_FuriHalSubGhzPresetIDLE: FuriHalSubGhzPreset = 0;
#[doc = "< OOK, bandwidth 270kHz, asynchronous"]
pub const FuriHalSubGhzPreset_FuriHalSubGhzPresetOok270Async: FuriHalSubGhzPreset = 1;
#[doc = "< OOK, bandwidth 650kHz, asynchronous"]
pub const FuriHalSubGhzPreset_FuriHalSubGhzPresetOok650Async: FuriHalSubGhzPreset = 2;
#[doc = "< FM, deviation 2.380371 kHz, asynchronous"]
pub const FuriHalSubGhzPreset_FuriHalSubGhzPreset2FSKDev238Async: FuriHalSubGhzPreset = 3;
#[doc = "< FM, deviation 47.60742 kHz, asynchronous"]
pub const FuriHalSubGhzPreset_FuriHalSubGhzPreset2FSKDev476Async: FuriHalSubGhzPreset = 4;
#[doc = "< MSK, deviation 47.60742 kHz, 99.97Kb/s, asynchronous"]
pub const FuriHalSubGhzPreset_FuriHalSubGhzPresetMSK99_97KbAsync: FuriHalSubGhzPreset = 5;
#[doc = "< GFSK, deviation 19.042969 kHz, 9.996Kb/s, asynchronous"]
pub const FuriHalSubGhzPreset_FuriHalSubGhzPresetGFSK9_99KbAsync: FuriHalSubGhzPreset = 6;
pub const FuriHalSubGhzPreset_FuriHalSubGhzPresetCustom: FuriHalSubGhzPreset = 7;
#[doc = " Radio Presets"]
pub type FuriHalSubGhzPreset = core::ffi::c_uchar;
#[doc = "< Isolate Radio from antenna"]
pub const FuriHalSubGhzPath_FuriHalSubGhzPathIsolate: FuriHalSubGhzPath = 0;
#[doc = "< Center Frequency: 433MHz. Path 1: SW1RF1-SW2RF2, LCLCL"]
pub const FuriHalSubGhzPath_FuriHalSubGhzPath433: FuriHalSubGhzPath = 1;
#[doc = "< Center Frequency: 315MHz. Path 2: SW1RF2-SW2RF1, LCLCLCL"]
pub const FuriHalSubGhzPath_FuriHalSubGhzPath315: FuriHalSubGhzPath = 2;
#[doc = "< Center Frequency: 868MHz. Path 3: SW1RF3-SW2RF3, LCLC"]
pub const FuriHalSubGhzPath_FuriHalSubGhzPath868: FuriHalSubGhzPath = 3;
#[doc = " Switchable Radio Paths"]
pub type FuriHalSubGhzPath = core::ffi::c_uchar;
extern "C" {
    pub fn furi_hal_subghz_set_async_mirror_pin(pin: *const GpioPin);
}
extern "C" {
    #[doc = " Send device to sleep mode"]
    pub fn furi_hal_subghz_sleep();
}
extern "C" {
    #[doc = " Load registers from preset by preset name\n\n @param      preset  to load"]
    pub fn furi_hal_subghz_load_preset(preset: FuriHalSubGhzPreset);
}
extern "C" {
    #[doc = " Load custom registers from preset\n\n @param      preset_data   registers to load"]
    pub fn furi_hal_subghz_load_custom_preset(preset_data: *mut u8);
}
extern "C" {
    #[doc = " Load registers\n\n @param      data  Registers data"]
    pub fn furi_hal_subghz_load_registers(data: *mut u8);
}
extern "C" {
    #[doc = " Load PATABLE\n\n @param      data  8 uint8_t values"]
    pub fn furi_hal_subghz_load_patable(data: *const u8);
}
extern "C" {
    #[doc = " Write packet to FIFO\n\n @param      data  bytes array\n @param      size  size"]
    pub fn furi_hal_subghz_write_packet(data: *const u8, size: u8);
}
extern "C" {
    #[doc = " Check if receive pipe is not empty\n\n @return     true if not empty"]
    pub fn furi_hal_subghz_rx_pipe_not_empty() -> bool;
}
extern "C" {
    #[doc = " Check if received data crc is valid\n\n @return     true if valid"]
    pub fn furi_hal_subghz_is_rx_data_crc_valid() -> bool;
}
extern "C" {
    #[doc = " Read packet from FIFO\n\n @param      data  pointer\n @param      size  size"]
    pub fn furi_hal_subghz_read_packet(data: *mut u8, size: *mut u8);
}
extern "C" {
    #[doc = " Flush rx FIFO buffer"]
    pub fn furi_hal_subghz_flush_rx();
}
extern "C" {
    #[doc = " Flush tx FIFO buffer"]
    pub fn furi_hal_subghz_flush_tx();
}
extern "C" {
    #[doc = " Reset Issue reset command\n @warning    registers content will be lost"]
    pub fn furi_hal_subghz_reset();
}
extern "C" {
    #[doc = " Switch to Idle"]
    pub fn furi_hal_subghz_idle();
}
extern "C" {
    #[doc = " Switch to Receive"]
    pub fn furi_hal_subghz_rx();
}
extern "C" {
    #[doc = " Switch to Transmit\n\n @return     true if the transfer is allowed by belonging to the region"]
    pub fn furi_hal_subghz_tx() -> bool;
}
extern "C" {
    #[doc = " Get RSSI value in dBm\n\n @return     RSSI value"]
    pub fn furi_hal_subghz_get_rssi() -> f32;
}
extern "C" {
    #[doc = " Get LQI\n\n @return     LQI value"]
    pub fn furi_hal_subghz_get_lqi() -> u8;
}
extern "C" {
    #[doc = " Check if frequency is in valid range\n\n @param      value  frequency in Hz\n\n @return     true if frequency is valid, otherwise false"]
    pub fn furi_hal_subghz_is_frequency_valid(value: u32) -> bool;
}
extern "C" {
    #[doc = " Set frequency and path This function automatically selects antenna matching\n network\n\n @param      value  frequency in Hz\n\n @return     real frequency in Hz"]
    pub fn furi_hal_subghz_set_frequency_and_path(value: u32) -> u32;
}
extern "C" {
    #[doc = " Set frequency\n\n @param      value  frequency in Hz\n\n @return     real frequency in Hz"]
    pub fn furi_hal_subghz_set_frequency(value: u32) -> u32;
}
extern "C" {
    #[doc = " Set path\n\n @param      path  path to use"]
    pub fn furi_hal_subghz_set_path(path: FuriHalSubGhzPath);
}
#[doc = " Signal Timings Capture callback"]
pub type FuriHalSubGhzCaptureCallback = ::core::option::Option<
    unsafe extern "C" fn(level: bool, duration: u32, context: *mut core::ffi::c_void),
>;
extern "C" {
    #[doc = " Enable signal timings capture Initializes GPIO and TIM2 for timings capture\n\n @param      callback  FuriHalSubGhzCaptureCallback\n @param      context   callback context"]
    pub fn furi_hal_subghz_start_async_rx(
        callback: FuriHalSubGhzCaptureCallback,
        context: *mut core::ffi::c_void,
    );
}
extern "C" {
    #[doc = " Disable signal timings capture Resets GPIO and TIM2"]
    pub fn furi_hal_subghz_stop_async_rx();
}
#[doc = " Async TX callback type\n @param      context  callback context\n @return     LevelDuration"]
pub type FuriHalSubGhzAsyncTxCallback =
    ::core::option::Option<unsafe extern "C" fn(context: *mut core::ffi::c_void) -> LevelDuration>;
extern "C" {
    #[doc = " Start async TX Initializes GPIO, TIM2 and DMA1 for signal output\n\n @param      callback  FuriHalSubGhzAsyncTxCallback\n @param      context   callback context\n\n @return     true if the transfer is allowed by belonging to the region"]
    pub fn furi_hal_subghz_start_async_tx(
        callback: FuriHalSubGhzAsyncTxCallback,
        context: *mut core::ffi::c_void,
    ) -> bool;
}
extern "C" {
    #[doc = " Wait for async transmission to complete\n\n @return     true if TX complete"]
    pub fn furi_hal_subghz_is_async_tx_complete() -> bool;
}
extern "C" {
    #[doc = " Stop async transmission and cleanup resources Resets GPIO, TIM2, and DMA1"]
    pub fn furi_hal_subghz_stop_async_tx();
}
pub type FuriHalIbuttonEmulateCallback =
    ::core::option::Option<unsafe extern "C" fn(context: *mut core::ffi::c_void)>;
extern "C" {
    #[doc = " Start emulation timer\n @param period timer period\n @param callback timer callback\n @param context callback context"]
    pub fn furi_hal_ibutton_emulate_start(
        period: u32,
        callback: FuriHalIbuttonEmulateCallback,
        context: *mut core::ffi::c_void,
    );
}
extern "C" {
    #[doc = " Update emulation timer period\n @param period new timer period"]
    pub fn furi_hal_ibutton_emulate_set_next(period: u32);
}
extern "C" {
    #[doc = " Stop emulation timer"]
    pub fn furi_hal_ibutton_emulate_stop();
}
extern "C" {
    #[doc = " Set the pin to normal mode (open collector), and sets it to float"]
    pub fn furi_hal_ibutton_pin_configure();
}
extern "C" {
    #[doc = " Sets the pin to analog mode, and sets it to float"]
    pub fn furi_hal_ibutton_pin_reset();
}
extern "C" {
    #[doc = " iButton write pin\n @param state true / false"]
    pub fn furi_hal_ibutton_pin_write(state: bool);
}
extern "C" {
    #[doc = " Config rfid pins to reset state"]
    pub fn furi_hal_rfid_pins_reset();
}
extern "C" {
    #[doc = " Config rfid pins to emulate state"]
    pub fn furi_hal_rfid_pins_emulate();
}
extern "C" {
    #[doc = " Config rfid pins to read state"]
    pub fn furi_hal_rfid_pins_read();
}
extern "C" {
    #[doc = " Release rfid pull pin"]
    pub fn furi_hal_rfid_pin_pull_release();
}
extern "C" {
    #[doc = " Pulldown rfid pull pin"]
    pub fn furi_hal_rfid_pin_pull_pulldown();
}
extern "C" {
    #[doc = " Config rfid timer to read state\n\n @param      freq        timer frequency\n @param      duty_cycle  timer duty cycle, 0.0-1.0"]
    pub fn furi_hal_rfid_tim_read(freq: f32, duty_cycle: f32);
}
extern "C" {
    #[doc = " Start read timer"]
    pub fn furi_hal_rfid_tim_read_start();
}
extern "C" {
    #[doc = " Stop read timer"]
    pub fn furi_hal_rfid_tim_read_stop();
}
extern "C" {
    #[doc = " Config rfid timer to emulate state\n\n @param      freq  timer frequency"]
    pub fn furi_hal_rfid_tim_emulate(freq: f32);
}
pub type FuriHalRfidEmulateCallback =
    ::core::option::Option<unsafe extern "C" fn(context: *mut core::ffi::c_void)>;
extern "C" {
    #[doc = " Start emulation timer"]
    pub fn furi_hal_rfid_tim_emulate_start(
        callback: FuriHalRfidEmulateCallback,
        context: *mut core::ffi::c_void,
    );
}
pub type FuriHalRfidReadCaptureCallback = ::core::option::Option<
    unsafe extern "C" fn(level: bool, duration: u32, context: *mut core::ffi::c_void),
>;
extern "C" {
    pub fn furi_hal_rfid_tim_read_capture_start(
        callback: FuriHalRfidReadCaptureCallback,
        context: *mut core::ffi::c_void,
    );
}
extern "C" {
    pub fn furi_hal_rfid_tim_read_capture_stop();
}
pub type FuriHalRfidDMACallback =
    ::core::option::Option<unsafe extern "C" fn(half: bool, context: *mut core::ffi::c_void)>;
extern "C" {
    pub fn furi_hal_rfid_tim_emulate_dma_start(
        duration: *mut u32,
        pulse: *mut u32,
        length: usize,
        callback: FuriHalRfidDMACallback,
        context: *mut core::ffi::c_void,
    );
}
extern "C" {
    pub fn furi_hal_rfid_tim_emulate_dma_stop();
}
extern "C" {
    #[doc = " Stop emulation timer"]
    pub fn furi_hal_rfid_tim_emulate_stop();
}
extern "C" {
    #[doc = " Config rfid timers to reset state"]
    pub fn furi_hal_rfid_tim_reset();
}
extern "C" {
    #[doc = " Set emulation timer period\n\n @param      period  overall duration"]
    pub fn furi_hal_rfid_set_emulate_period(period: u32);
}
extern "C" {
    #[doc = " Set emulation timer pulse\n\n @param      pulse  duration of high level"]
    pub fn furi_hal_rfid_set_emulate_pulse(pulse: u32);
}
extern "C" {
    #[doc = " Set read timer period\n\n @param      period  overall duration"]
    pub fn furi_hal_rfid_set_read_period(period: u32);
}
extern "C" {
    #[doc = " Set read timer pulse\n\n @param      pulse  duration of high level"]
    pub fn furi_hal_rfid_set_read_pulse(pulse: u32);
}
extern "C" {
    #[doc = " Сhanges the configuration of the RFID timer \"on a fly\"\n\n @param      freq        new frequency\n @param      duty_cycle  new duty cycle"]
    pub fn furi_hal_rfid_change_read_config(freq: f32, duty_cycle: f32);
}
extern "C" {
    #[doc = " Start/Enable comparator"]
    pub fn furi_hal_rfid_comp_start();
}
extern "C" {
    #[doc = " Stop/Disable comparator"]
    pub fn furi_hal_rfid_comp_stop();
}
pub type FuriHalRfidCompCallback =
    ::core::option::Option<unsafe extern "C" fn(level: bool, context: *mut core::ffi::c_void)>;
extern "C" {
    #[doc = " Set comparator callback"]
    pub fn furi_hal_rfid_comp_set_callback(
        callback: FuriHalRfidCompCallback,
        context: *mut core::ffi::c_void,
    );
}
pub type ReturnCode = u16;
extern "C" {
    #[doc = " \\brief  Calculate Timer\n\n This method calculates when the timer will be expired given the amount\n time in milliseconds /a tOut.\n Once the timer has been calculated it will then be used to check when\n it expires.\n\n \\see timersIsExpired\n\n \\param[in]  time : time/duration in Milliseconds for the timer\n\n \\return u32 : The new timer calculated based on the given time\n"]
    pub fn timerCalculateTimer(time: u16) -> u32;
}
extern "C" {
    #[doc = " \\brief  Checks if a Timer is Expired\n\n This method checks if a timer has already expired.\n Based on the given timer previously calculated it checks if this timer\n has already elapsed\n\n \\see timersCalculateTimer\n\n \\param[in]  timer : the timer to check\n\n \\return true  : timer has already expired\n \\return false : timer is still running\n"]
    pub fn timerIsExpired(timer: u32) -> bool;
}
extern "C" {
    pub fn powf(arg1: f32, arg2: f32) -> f32;
}
extern "C" {
    pub fn roundf(arg1: f32) -> f32;
}
extern "C" {
    pub fn scalbnf(arg1: f32, arg2: core::ffi::c_int) -> f32;
}
extern "C" {
    #[doc = " \\brief  RFAL Turn Field On and Start GT\n\n Turns the Field On, performing Initial Collision Avoidance\n\n After Field On, if GT was set before, it starts the GT timer to be\n used on the following communications.\n\n \\return ERR_RF_COLLISION : External field detected\n \\return ERR_NONE         : Field turned On\n\n"]
    pub fn rfalFieldOnAndStartGT() -> ReturnCode;
}
extern "C" {
    #[doc = "  \\brief RFAL Worker\n\n  This runs RFAL layer, which drives the actual Transceive procedure\n  It MUST be executed frequently in order to execute the RFAL internal\n  states and perform the requested operations\n\n"]
    pub fn rfalWorker();
}
extern "C" {
    #[doc = " \\brief Low Power Mode Start\n\n Sets the RF Chip in Low Power Mode.\n In this mode the RF Chip is placed in Low Power Mode, similar to Wake-up\n mode but no operation nor period measurement is performed.\n Mode must be terminated by rfalLowPowerModeStop()\n\n \\return ERR_WRONG_STATE : Not initialized properly\n \\return ERR_PARAM       : Invalid parameter\n \\return ERR_NONE        : Done with no error\n\n"]
    pub fn rfalLowPowerModeStart() -> ReturnCode;
}
extern "C" {
    #[doc = " \\brief Low Power Mode Stop\n\n Stops the Low Power Mode re-enabling the device\n\n \\return ERR_WRONG_STATE : Not initialized properly\n \\return ERR_PARAM       : Invalid parameter\n \\return ERR_NONE        : Done with no error\n\n"]
    pub fn rfalLowPowerModeStop() -> ReturnCode;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DigitalSignal {
    pub start_level: bool,
    pub edge_cnt: u32,
    pub edges_max_cnt: u32,
    pub edge_timings: *mut u32,
    pub reload_reg_buff: *mut u32,
}
#[test]
fn bindgen_test_layout_DigitalSignal() {
    const UNINIT: ::core::mem::MaybeUninit<DigitalSignal> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<DigitalSignal>(),
        20usize,
        concat!("Size of: ", stringify!(DigitalSignal))
    );
    assert_eq!(
        ::core::mem::align_of::<DigitalSignal>(),
        4usize,
        concat!("Alignment of ", stringify!(DigitalSignal))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).start_level) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DigitalSignal),
            "::",
            stringify!(start_level)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).edge_cnt) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(DigitalSignal),
            "::",
            stringify!(edge_cnt)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).edges_max_cnt) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(DigitalSignal),
            "::",
            stringify!(edges_max_cnt)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).edge_timings) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(DigitalSignal),
            "::",
            stringify!(edge_timings)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reload_reg_buff) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(DigitalSignal),
            "::",
            stringify!(reload_reg_buff)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NfcaSignal {
    pub one: *mut DigitalSignal,
    pub zero: *mut DigitalSignal,
    pub tx_signal: *mut DigitalSignal,
}
#[test]
fn bindgen_test_layout_NfcaSignal() {
    const UNINIT: ::core::mem::MaybeUninit<NfcaSignal> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<NfcaSignal>(),
        12usize,
        concat!("Size of: ", stringify!(NfcaSignal))
    );
    assert_eq!(
        ::core::mem::align_of::<NfcaSignal>(),
        4usize,
        concat!("Alignment of ", stringify!(NfcaSignal))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).one) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NfcaSignal),
            "::",
            stringify!(one)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).zero) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(NfcaSignal),
            "::",
            stringify!(zero)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tx_signal) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(NfcaSignal),
            "::",
            stringify!(tx_signal)
        )
    );
}
pub const FuriHalNfcTxRxType_FuriHalNfcTxRxTypeDefault: FuriHalNfcTxRxType = 0;
pub const FuriHalNfcTxRxType_FuriHalNfcTxRxTypeRxNoCrc: FuriHalNfcTxRxType = 1;
pub const FuriHalNfcTxRxType_FuriHalNfcTxRxTypeRxKeepPar: FuriHalNfcTxRxType = 2;
pub const FuriHalNfcTxRxType_FuriHalNfcTxRxTypeRaw: FuriHalNfcTxRxType = 3;
pub const FuriHalNfcTxRxType_FuriHalNfcTxRxTypeRxRaw: FuriHalNfcTxRxType = 4;
pub const FuriHalNfcTxRxType_FuriHalNfcTxRxTransparent: FuriHalNfcTxRxType = 5;
pub type FuriHalNfcTxRxType = core::ffi::c_uchar;
pub type FuriHalNfcEmulateCallback = ::core::option::Option<
    unsafe extern "C" fn(
        buff_rx: *mut u8,
        buff_rx_len: u16,
        buff_tx: *mut u8,
        buff_tx_len: *mut u16,
        flags: *mut u32,
        context: *mut core::ffi::c_void,
    ) -> bool,
>;
pub const FuriHalNfcType_FuriHalNfcTypeA: FuriHalNfcType = 0;
pub const FuriHalNfcType_FuriHalNfcTypeB: FuriHalNfcType = 1;
pub const FuriHalNfcType_FuriHalNfcTypeF: FuriHalNfcType = 2;
pub const FuriHalNfcType_FuriHalNfcTypeV: FuriHalNfcType = 3;
pub type FuriHalNfcType = core::ffi::c_uchar;
pub const FuriHalNfcInterface_FuriHalNfcInterfaceRf: FuriHalNfcInterface = 0;
pub const FuriHalNfcInterface_FuriHalNfcInterfaceIsoDep: FuriHalNfcInterface = 1;
pub const FuriHalNfcInterface_FuriHalNfcInterfaceNfcDep: FuriHalNfcInterface = 2;
pub type FuriHalNfcInterface = core::ffi::c_uchar;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FuriHalNfcDevData {
    pub type_: FuriHalNfcType,
    pub interface: FuriHalNfcInterface,
    pub uid_len: u8,
    pub uid: [u8; 10usize],
    pub cuid: u32,
    pub atqa: [u8; 2usize],
    pub sak: u8,
}
#[test]
fn bindgen_test_layout_FuriHalNfcDevData() {
    const UNINIT: ::core::mem::MaybeUninit<FuriHalNfcDevData> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<FuriHalNfcDevData>(),
        24usize,
        concat!("Size of: ", stringify!(FuriHalNfcDevData))
    );
    assert_eq!(
        ::core::mem::align_of::<FuriHalNfcDevData>(),
        4usize,
        concat!("Alignment of ", stringify!(FuriHalNfcDevData))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FuriHalNfcDevData),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).interface) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(FuriHalNfcDevData),
            "::",
            stringify!(interface)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).uid_len) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(FuriHalNfcDevData),
            "::",
            stringify!(uid_len)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).uid) as usize - ptr as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(FuriHalNfcDevData),
            "::",
            stringify!(uid)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).cuid) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(FuriHalNfcDevData),
            "::",
            stringify!(cuid)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).atqa) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(FuriHalNfcDevData),
            "::",
            stringify!(atqa)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).sak) as usize - ptr as usize },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(FuriHalNfcDevData),
            "::",
            stringify!(sak)
        )
    );
}
pub type FuriHalNfcTxRxSniffCallback = ::core::option::Option<
    unsafe extern "C" fn(
        data: *mut u8,
        bits: u16,
        crc_dropped: bool,
        context: *mut core::ffi::c_void,
    ),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FuriHalNfcTxRxContext {
    pub tx_data: [u8; 512usize],
    pub tx_parity: [u8; 64usize],
    pub tx_bits: u16,
    pub rx_data: [u8; 512usize],
    pub rx_parity: [u8; 64usize],
    pub rx_bits: u16,
    pub tx_rx_type: FuriHalNfcTxRxType,
    pub nfca_signal: *mut NfcaSignal,
    pub sniff_tx: FuriHalNfcTxRxSniffCallback,
    pub sniff_rx: FuriHalNfcTxRxSniffCallback,
    pub sniff_context: *mut core::ffi::c_void,
}
#[test]
fn bindgen_test_layout_FuriHalNfcTxRxContext() {
    const UNINIT: ::core::mem::MaybeUninit<FuriHalNfcTxRxContext> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<FuriHalNfcTxRxContext>(),
        1176usize,
        concat!("Size of: ", stringify!(FuriHalNfcTxRxContext))
    );
    assert_eq!(
        ::core::mem::align_of::<FuriHalNfcTxRxContext>(),
        4usize,
        concat!("Alignment of ", stringify!(FuriHalNfcTxRxContext))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tx_data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FuriHalNfcTxRxContext),
            "::",
            stringify!(tx_data)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tx_parity) as usize - ptr as usize },
        512usize,
        concat!(
            "Offset of field: ",
            stringify!(FuriHalNfcTxRxContext),
            "::",
            stringify!(tx_parity)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tx_bits) as usize - ptr as usize },
        576usize,
        concat!(
            "Offset of field: ",
            stringify!(FuriHalNfcTxRxContext),
            "::",
            stringify!(tx_bits)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rx_data) as usize - ptr as usize },
        578usize,
        concat!(
            "Offset of field: ",
            stringify!(FuriHalNfcTxRxContext),
            "::",
            stringify!(rx_data)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rx_parity) as usize - ptr as usize },
        1090usize,
        concat!(
            "Offset of field: ",
            stringify!(FuriHalNfcTxRxContext),
            "::",
            stringify!(rx_parity)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rx_bits) as usize - ptr as usize },
        1154usize,
        concat!(
            "Offset of field: ",
            stringify!(FuriHalNfcTxRxContext),
            "::",
            stringify!(rx_bits)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tx_rx_type) as usize - ptr as usize },
        1156usize,
        concat!(
            "Offset of field: ",
            stringify!(FuriHalNfcTxRxContext),
            "::",
            stringify!(tx_rx_type)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).nfca_signal) as usize - ptr as usize },
        1160usize,
        concat!(
            "Offset of field: ",
            stringify!(FuriHalNfcTxRxContext),
            "::",
            stringify!(nfca_signal)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).sniff_tx) as usize - ptr as usize },
        1164usize,
        concat!(
            "Offset of field: ",
            stringify!(FuriHalNfcTxRxContext),
            "::",
            stringify!(sniff_tx)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).sniff_rx) as usize - ptr as usize },
        1168usize,
        concat!(
            "Offset of field: ",
            stringify!(FuriHalNfcTxRxContext),
            "::",
            stringify!(sniff_rx)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).sniff_context) as usize - ptr as usize },
        1172usize,
        concat!(
            "Offset of field: ",
            stringify!(FuriHalNfcTxRxContext),
            "::",
            stringify!(sniff_context)
        )
    );
}
extern "C" {
    #[doc = " Check if nfc worker is busy\n\n @return     true if busy"]
    pub fn furi_hal_nfc_is_busy() -> bool;
}
extern "C" {
    #[doc = " Check if nfc is initialized\n\n @return     true if initialized"]
    pub fn furi_hal_nfc_is_init() -> bool;
}
extern "C" {
    #[doc = " NFC field on"]
    pub fn furi_hal_nfc_field_on();
}
extern "C" {
    #[doc = " NFC field off"]
    pub fn furi_hal_nfc_field_off();
}
extern "C" {
    #[doc = " NFC start sleep"]
    pub fn furi_hal_nfc_start_sleep();
}
extern "C" {
    pub fn furi_hal_nfc_stop_cmd();
}
extern "C" {
    #[doc = " NFC stop sleep"]
    pub fn furi_hal_nfc_exit_sleep();
}
extern "C" {
    #[doc = " NFC poll\n\n @param      dev_list    pointer to rfalNfcDevice buffer\n @param      dev_cnt     pointer device count\n @param      timeout     timeout in ms\n @param      deactivate  deactivate flag\n\n @return     true on success"]
    pub fn furi_hal_nfc_detect(nfc_data: *mut FuriHalNfcDevData, timeout: u32) -> bool;
}
extern "C" {
    #[doc = " Activate NFC-A tag\n\n @param      timeout      timeout in ms\n @param      cuid         pointer to 32bit uid\n\n @return     true on succeess"]
    pub fn furi_hal_nfc_activate_nfca(timeout: u32, cuid: *mut u32) -> bool;
}
extern "C" {
    #[doc = " NFC listen\n\n @param      uid                 pointer to uid buffer\n @param      uid_len             uid length\n @param      atqa                pointer to atqa\n @param      sak                 sak\n @param      activate_after_sak  activate after sak flag\n @param      timeout             timeout in ms\n\n @return     true on success"]
    pub fn furi_hal_nfc_listen(
        uid: *mut u8,
        uid_len: u8,
        atqa: *mut u8,
        sak: u8,
        activate_after_sak: bool,
        timeout: u32,
    ) -> bool;
}
extern "C" {
    #[doc = " Start Target Listen mode\n @note RFAL free implementation\n\n @param       nfc_data            FuriHalNfcDevData instance"]
    pub fn furi_hal_nfc_listen_start(nfc_data: *mut FuriHalNfcDevData);
}
extern "C" {
    #[doc = " Read data in Target Listen mode\n @note Must be called only after furi_hal_nfc_listen_start()\n\n @param       tx_rx               FuriHalNfcTxRxContext instance\n @param       timeout_ms          timeout im ms\n\n @return      true on not empty receive"]
    pub fn furi_hal_nfc_listen_rx(tx_rx: *mut FuriHalNfcTxRxContext, timeout_ms: u32) -> bool;
}
extern "C" {
    #[doc = " Set Target in Sleep state"]
    pub fn furi_hal_nfc_listen_sleep();
}
extern "C" {
    #[doc = " Emulate NFC-A Target\n @note RFAL based implementation\n\n @param       uid                 NFC-A UID\n @param       uid_len             NFC-A UID length\n @param       atqa                NFC-A ATQA\n @param       sak                 NFC-A SAK\n @param       callback            FuriHalNfcEmulateCallback instance\n @param       context             pointer to context for callback\n @param       timeout             timeout in ms\n\n @return      true on success"]
    pub fn furi_hal_nfc_emulate_nfca(
        uid: *mut u8,
        uid_len: u8,
        atqa: *mut u8,
        sak: u8,
        callback: FuriHalNfcEmulateCallback,
        context: *mut core::ffi::c_void,
        timeout: u32,
    ) -> bool;
}
extern "C" {
    #[doc = " NFC data exchange\n\n @param       tx_rx_ctx   FuriHalNfcTxRxContext instance\n\n @return      true on success"]
    pub fn furi_hal_nfc_tx_rx(tx_rx: *mut FuriHalNfcTxRxContext, timeout_ms: u16) -> bool;
}
extern "C" {
    #[doc = " NFC data full exhange\n\n @param       tx_rx_ctx   FuriHalNfcTxRxContext instance\n\n @return      true on success"]
    pub fn furi_hal_nfc_tx_rx_full(tx_rx: *mut FuriHalNfcTxRxContext) -> bool;
}
extern "C" {
    #[doc = " NFC deactivate and start sleep"]
    pub fn furi_hal_nfc_sleep();
}
extern "C" {
    pub fn furi_hal_nfc_stop();
}
#[doc = "< no error occurred"]
pub const FuriHalNfcReturn_FuriHalNfcReturnOk: FuriHalNfcReturn = 0;
#[doc = "< not enough memory to perform the requested operation"]
pub const FuriHalNfcReturn_FuriHalNfcReturnNomem: FuriHalNfcReturn = 1;
#[doc = "< device or resource busy"]
pub const FuriHalNfcReturn_FuriHalNfcReturnBusy: FuriHalNfcReturn = 2;
#[doc = "< generic IO error"]
pub const FuriHalNfcReturn_FuriHalNfcReturnIo: FuriHalNfcReturn = 3;
#[doc = "< error due to timeout"]
pub const FuriHalNfcReturn_FuriHalNfcReturnTimeout: FuriHalNfcReturn = 4;
pub const FuriHalNfcReturn_FuriHalNfcReturnRequest: FuriHalNfcReturn = 5;
#[doc = "< No message of desired type"]
pub const FuriHalNfcReturn_FuriHalNfcReturnNomsg: FuriHalNfcReturn = 6;
#[doc = "< Parameter error"]
pub const FuriHalNfcReturn_FuriHalNfcReturnParam: FuriHalNfcReturn = 7;
#[doc = "< System error"]
pub const FuriHalNfcReturn_FuriHalNfcReturnSystem: FuriHalNfcReturn = 8;
#[doc = "< Framing error"]
pub const FuriHalNfcReturn_FuriHalNfcReturnFraming: FuriHalNfcReturn = 9;
#[doc = "< lost one or more received bytes"]
pub const FuriHalNfcReturn_FuriHalNfcReturnOverrun: FuriHalNfcReturn = 10;
#[doc = "< protocol error"]
pub const FuriHalNfcReturn_FuriHalNfcReturnProto: FuriHalNfcReturn = 11;
#[doc = "< Internal Error"]
pub const FuriHalNfcReturn_FuriHalNfcReturnInternal: FuriHalNfcReturn = 12;
#[doc = "< Call again"]
pub const FuriHalNfcReturn_FuriHalNfcReturnAgain: FuriHalNfcReturn = 13;
#[doc = "< memory corruption"]
pub const FuriHalNfcReturn_FuriHalNfcReturnMemCorrupt: FuriHalNfcReturn = 14;
#[doc = "< not implemented"]
pub const FuriHalNfcReturn_FuriHalNfcReturnNotImplemented: FuriHalNfcReturn = 15;
pub const FuriHalNfcReturn_FuriHalNfcReturnPcCorrupt: FuriHalNfcReturn = 16;
#[doc = "< error sending"]
pub const FuriHalNfcReturn_FuriHalNfcReturnSend: FuriHalNfcReturn = 17;
#[doc = "< indicates error detected but to be ignored"]
pub const FuriHalNfcReturn_FuriHalNfcReturnIgnore: FuriHalNfcReturn = 18;
#[doc = "< indicates error in state machine (unexpected cmd)"]
pub const FuriHalNfcReturn_FuriHalNfcReturnSemantic: FuriHalNfcReturn = 19;
#[doc = "< indicates error in state machine (unknown cmd)"]
pub const FuriHalNfcReturn_FuriHalNfcReturnSyntax: FuriHalNfcReturn = 20;
#[doc = "< crc error"]
pub const FuriHalNfcReturn_FuriHalNfcReturnCrc: FuriHalNfcReturn = 21;
#[doc = "< transponder not found"]
pub const FuriHalNfcReturn_FuriHalNfcReturnNotfound: FuriHalNfcReturn = 22;
pub const FuriHalNfcReturn_FuriHalNfcReturnNotunique: FuriHalNfcReturn = 23;
#[doc = "< requested operation not supported"]
pub const FuriHalNfcReturn_FuriHalNfcReturnNotsupp: FuriHalNfcReturn = 24;
#[doc = "< write error"]
pub const FuriHalNfcReturn_FuriHalNfcReturnWrite: FuriHalNfcReturn = 25;
#[doc = "< fifo over or underflow error"]
pub const FuriHalNfcReturn_FuriHalNfcReturnFifo: FuriHalNfcReturn = 26;
#[doc = "< parity error"]
pub const FuriHalNfcReturn_FuriHalNfcReturnPar: FuriHalNfcReturn = 27;
#[doc = "< transfer has already finished"]
pub const FuriHalNfcReturn_FuriHalNfcReturnDone: FuriHalNfcReturn = 28;
pub const FuriHalNfcReturn_FuriHalNfcReturnRfCollision: FuriHalNfcReturn = 29;
#[doc = "< lost one or more received bytes"]
pub const FuriHalNfcReturn_FuriHalNfcReturnHwOverrun: FuriHalNfcReturn = 30;
#[doc = "< device requested release"]
pub const FuriHalNfcReturn_FuriHalNfcReturnReleaseReq: FuriHalNfcReturn = 31;
#[doc = "< device requested sleep"]
pub const FuriHalNfcReturn_FuriHalNfcReturnSleepReq: FuriHalNfcReturn = 32;
#[doc = "< incorrent state for requested operation"]
pub const FuriHalNfcReturn_FuriHalNfcReturnWrongState: FuriHalNfcReturn = 33;
#[doc = "< blocking procedure reached maximum runs"]
pub const FuriHalNfcReturn_FuriHalNfcReturnMaxReruns: FuriHalNfcReturn = 34;
#[doc = "< operation aborted due to disabled configuration"]
pub const FuriHalNfcReturn_FuriHalNfcReturnDisabled: FuriHalNfcReturn = 35;
#[doc = "< expected hw do not match"]
pub const FuriHalNfcReturn_FuriHalNfcReturnHwMismatch: FuriHalNfcReturn = 36;
pub const FuriHalNfcReturn_FuriHalNfcReturnLinkLoss: FuriHalNfcReturn = 37;
#[doc = "< invalid or not initalized device handle"]
pub const FuriHalNfcReturn_FuriHalNfcReturnInvalidHandle: FuriHalNfcReturn = 38;
#[doc = "< Incomplete byte rcvd"]
pub const FuriHalNfcReturn_FuriHalNfcReturnIncompleteByte: FuriHalNfcReturn = 40;
#[doc = "< Incomplete byte rcvd - 1 bit"]
pub const FuriHalNfcReturn_FuriHalNfcReturnIncompleteByte01: FuriHalNfcReturn = 41;
#[doc = "< Incomplete byte rcvd - 2 bit"]
pub const FuriHalNfcReturn_FuriHalNfcReturnIncompleteByte02: FuriHalNfcReturn = 42;
#[doc = "< Incomplete byte rcvd - 3 bit"]
pub const FuriHalNfcReturn_FuriHalNfcReturnIncompleteByte03: FuriHalNfcReturn = 43;
#[doc = "< Incomplete byte rcvd - 4 bit"]
pub const FuriHalNfcReturn_FuriHalNfcReturnIncompleteByte04: FuriHalNfcReturn = 44;
#[doc = "< Incomplete byte rcvd - 5 bit"]
pub const FuriHalNfcReturn_FuriHalNfcReturnIncompleteByte05: FuriHalNfcReturn = 45;
#[doc = "< Incomplete byte rcvd - 6 bit"]
pub const FuriHalNfcReturn_FuriHalNfcReturnIncompleteByte06: FuriHalNfcReturn = 46;
#[doc = "< Incomplete byte rcvd - 7 bit"]
pub const FuriHalNfcReturn_FuriHalNfcReturnIncompleteByte07: FuriHalNfcReturn = 47;
pub type FuriHalNfcReturn = core::ffi::c_uchar;
#[doc = "< No mode selected/defined"]
pub const FuriHalNfcMode_FuriHalNfcModeNone: FuriHalNfcMode = 0;
#[doc = "< Mode to perform as NFCA (ISO14443A) Poller (PCD)"]
pub const FuriHalNfcMode_FuriHalNfcModePollNfca: FuriHalNfcMode = 1;
#[doc = "< Mode to perform as NFCA T1T (Topaz) Poller (PCD)"]
pub const FuriHalNfcMode_FuriHalNfcModePollNfcaT1t: FuriHalNfcMode = 2;
#[doc = "< Mode to perform as NFCB (ISO14443B) Poller (PCD)"]
pub const FuriHalNfcMode_FuriHalNfcModePollNfcb: FuriHalNfcMode = 3;
#[doc = "< Mode to perform as B' Calypso (Innovatron) (PCD)"]
pub const FuriHalNfcMode_FuriHalNfcModePollBPrime: FuriHalNfcMode = 4;
#[doc = "< Mode to perform as CTS Poller (PCD)"]
pub const FuriHalNfcMode_FuriHalNfcModePollBCts: FuriHalNfcMode = 5;
#[doc = "< Mode to perform as NFCF (FeliCa) Poller (PCD)"]
pub const FuriHalNfcMode_FuriHalNfcModePollNfcf: FuriHalNfcMode = 6;
#[doc = "< Mode to perform as NFCV (ISO15963) Poller (PCD)"]
pub const FuriHalNfcMode_FuriHalNfcModePollNfcv: FuriHalNfcMode = 7;
#[doc = "< Mode to perform as PicoPass / iClass Poller (PCD)"]
pub const FuriHalNfcMode_FuriHalNfcModePollPicopass: FuriHalNfcMode = 8;
#[doc = "< Mode to perform as Active P2P (ISO18092) Initiator"]
pub const FuriHalNfcMode_FuriHalNfcModePollActiveP2p: FuriHalNfcMode = 9;
#[doc = "< Mode to perform as NFCA (ISO14443A) Listener (PICC)"]
pub const FuriHalNfcMode_FuriHalNfcModeListenNfca: FuriHalNfcMode = 10;
#[doc = "< Mode to perform as NFCA (ISO14443B) Listener (PICC)"]
pub const FuriHalNfcMode_FuriHalNfcModeListenNfcb: FuriHalNfcMode = 11;
#[doc = "< Mode to perform as NFCA (ISO15963) Listener (PICC)"]
pub const FuriHalNfcMode_FuriHalNfcModeListenNfcf: FuriHalNfcMode = 12;
#[doc = "< Mode to perform as Active P2P (ISO18092) Target"]
pub const FuriHalNfcMode_FuriHalNfcModeListenActiveP2p: FuriHalNfcMode = 13;
pub type FuriHalNfcMode = core::ffi::c_uchar;
#[doc = "< Bit Rate 106 kbit/s (fc/128)"]
pub const FuriHalNfcBitrate_FuriHalNfcBitrate106: FuriHalNfcBitrate = 0;
#[doc = "< Bit Rate 212 kbit/s (fc/64)"]
pub const FuriHalNfcBitrate_FuriHalNfcBitrate212: FuriHalNfcBitrate = 1;
#[doc = "< Bit Rate 424 kbit/s (fc/32)"]
pub const FuriHalNfcBitrate_FuriHalNfcBitrate424: FuriHalNfcBitrate = 2;
#[doc = "< Bit Rate 848 kbit/s (fc/16)"]
pub const FuriHalNfcBitrate_FuriHalNfcBitrate848: FuriHalNfcBitrate = 3;
#[doc = "< Bit Rate 1695 kbit/s (fc/8)"]
pub const FuriHalNfcBitrate_FuriHalNfcBitrate1695: FuriHalNfcBitrate = 4;
#[doc = "< Bit Rate 3390 kbit/s (fc/4)"]
pub const FuriHalNfcBitrate_FuriHalNfcBitrate3390: FuriHalNfcBitrate = 5;
#[doc = "< Bit Rate 6780 kbit/s (fc/2)"]
pub const FuriHalNfcBitrate_FuriHalNfcBitrate6780: FuriHalNfcBitrate = 6;
#[doc = "< Bit Rate 13560 kbit/s (fc)"]
pub const FuriHalNfcBitrate_FuriHalNfcBitrate13560: FuriHalNfcBitrate = 7;
#[doc = "< Bit Rate 52.97 kbit/s (fc/256) Fast Mode VICC->VCD"]
pub const FuriHalNfcBitrate_FuriHalNfcBitrate52p97: FuriHalNfcBitrate = 235;
pub const FuriHalNfcBitrate_FuriHalNfcBitrate26p48: FuriHalNfcBitrate = 236;
#[doc = "< Bit Rate 1,66 kbit/s (fc/8192) NFCV VCD->VICC 1of256"]
pub const FuriHalNfcBitrate_FuriHalNfcBitrate1p66: FuriHalNfcBitrate = 237;
#[doc = "< Value indicating to keep the same previous bit rate"]
pub const FuriHalNfcBitrate_FuriHalNfcBitrateKeep: FuriHalNfcBitrate = 255;
pub type FuriHalNfcBitrate = core::ffi::c_uchar;
extern "C" {
    pub fn furi_hal_nfc_ll_set_mode(
        mode: FuriHalNfcMode,
        txBR: FuriHalNfcBitrate,
        rxBR: FuriHalNfcBitrate,
    ) -> FuriHalNfcReturn;
}
extern "C" {
    pub fn furi_hal_nfc_ll_set_guard_time(cycles: u32);
}
#[doc = "< No special error handling will be performed"]
pub const FuriHalNfcErrorHandling_FuriHalNfcErrorHandlingNone: FuriHalNfcErrorHandling = 0;
#[doc = "< Error handling set to perform as NFC compliant device"]
pub const FuriHalNfcErrorHandling_FuriHalNfcErrorHandlingNfc: FuriHalNfcErrorHandling = 1;
pub const FuriHalNfcErrorHandling_FuriHalNfcErrorHandlingEmvco: FuriHalNfcErrorHandling = 2;
pub type FuriHalNfcErrorHandling = core::ffi::c_uchar;
extern "C" {
    pub fn furi_hal_nfc_ll_set_error_handling(eHandling: FuriHalNfcErrorHandling);
}
extern "C" {
    pub fn furi_hal_nfc_ll_set_fdt_listen(cycles: u32);
}
extern "C" {
    pub fn furi_hal_nfc_ll_set_fdt_poll(FDTPoll: u32);
}
extern "C" {
    pub fn furi_hal_nfc_ll_txrx_on();
}
extern "C" {
    pub fn furi_hal_nfc_ll_txrx_off();
}
extern "C" {
    pub fn furi_hal_nfc_ll_txrx(
        txBuf: *mut u8,
        txBufLen: u16,
        rxBuf: *mut u8,
        rxBufLen: u16,
        actLen: *mut u16,
        flags: u32,
        fwt: u32,
    ) -> FuriHalNfcReturn;
}
extern "C" {
    pub fn furi_hal_nfc_ll_txrx_bits(
        txBuf: *mut u8,
        txBufLen: u16,
        rxBuf: *mut u8,
        rxBufLen: u16,
        actLen: *mut u16,
        flags: u32,
        fwt: u32,
    ) -> FuriHalNfcReturn;
}
extern "C" {
    pub fn furi_hal_nfc_ll_poll();
}
extern "C" {
    #[doc = " Transfer execution to address\n\n @param[in]  address  pointer to new executable"]
    pub fn furi_hal_switch(address: *mut core::ffi::c_void);
}
#[doc = "< Metric measurement units"]
pub const LocaleMeasurementUnits_LocaleMeasurementUnitsMetric: LocaleMeasurementUnits = 0;
#[doc = "< Imperial measurement units"]
pub const LocaleMeasurementUnits_LocaleMeasurementUnitsImperial: LocaleMeasurementUnits = 1;
pub type LocaleMeasurementUnits = core::ffi::c_uchar;
#[doc = "< 24-hour format"]
pub const LocaleTimeFormat_LocaleTimeFormat24h: LocaleTimeFormat = 0;
#[doc = "< 12-hour format"]
pub const LocaleTimeFormat_LocaleTimeFormat12h: LocaleTimeFormat = 1;
pub type LocaleTimeFormat = core::ffi::c_uchar;
#[doc = "< Day/Month/Year"]
pub const LocaleDateFormat_LocaleDateFormatDMY: LocaleDateFormat = 0;
#[doc = "< Month/Day/Year"]
pub const LocaleDateFormat_LocaleDateFormatMDY: LocaleDateFormat = 1;
#[doc = "< Year/Month/Day"]
pub const LocaleDateFormat_LocaleDateFormatYMD: LocaleDateFormat = 2;
pub type LocaleDateFormat = core::ffi::c_uchar;
extern "C" {
    #[doc = " Get Locale measurement units\n\n @return     The locale measurement units."]
    pub fn locale_get_measurement_unit() -> LocaleMeasurementUnits;
}
extern "C" {
    #[doc = " Set locale measurement units\n\n @param[in]  format  The locale measurements units"]
    pub fn locale_set_measurement_unit(format: LocaleMeasurementUnits);
}
extern "C" {
    #[doc = " Convert Fahrenheit to Celsius\n\n @param[in]  temp_f  The Temperature in Fahrenheit\n\n @return     The Temperature in Celsius"]
    pub fn locale_fahrenheit_to_celsius(temp_f: f32) -> f32;
}
extern "C" {
    #[doc = " Convert Celsius to Fahrenheit\n\n @param[in]  temp_c  The Temperature in Celsius\n\n @return     The Temperature in Fahrenheit"]
    pub fn locale_celsius_to_fahrenheit(temp_c: f32) -> f32;
}
extern "C" {
    #[doc = " Get Locale time format\n\n @return     The locale time format."]
    pub fn locale_get_time_format() -> LocaleTimeFormat;
}
extern "C" {
    #[doc = " Set Locale Time Format\n\n @param[in]  format  The Locale Time Format"]
    pub fn locale_set_time_format(format: LocaleTimeFormat);
}
extern "C" {
    #[doc = " Format time to furi string\n\n @param[out] out_str       The FuriString to store formatted time\n @param[in]  datetime      Pointer to the datetime\n @param[in]  format        The Locale Time Format\n @param[in]  show_seconds  The show seconds flag"]
    pub fn locale_format_time(
        out_str: *mut FuriString,
        datetime: *const FuriHalRtcDateTime,
        format: LocaleTimeFormat,
        show_seconds: bool,
    );
}
extern "C" {
    #[doc = " Get Locale DateFormat\n\n @return     The Locale DateFormat."]
    pub fn locale_get_date_format() -> LocaleDateFormat;
}
extern "C" {
    #[doc = " Set Locale DateFormat\n\n @param[in]  format  The Locale DateFormat"]
    pub fn locale_set_date_format(format: LocaleDateFormat);
}
extern "C" {
    #[doc = " Format date to furi string\n\n @param[out] out_str    The FuriString to store formatted date\n @param[in]  datetime   Pointer to the datetime\n @param[in]  format     The format\n @param[in]  separator  The separator"]
    pub fn locale_format_date(
        out_str: *mut FuriString,
        datetime: *const FuriHalRtcDateTime,
        format: LocaleDateFormat,
        separator: *const core::ffi::c_char,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NotificationApp {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NotificationMessageDataSound {
    pub frequency: f32,
    pub volume: f32,
}
#[test]
fn bindgen_test_layout_NotificationMessageDataSound() {
    const UNINIT: ::core::mem::MaybeUninit<NotificationMessageDataSound> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<NotificationMessageDataSound>(),
        8usize,
        concat!("Size of: ", stringify!(NotificationMessageDataSound))
    );
    assert_eq!(
        ::core::mem::align_of::<NotificationMessageDataSound>(),
        4usize,
        concat!("Alignment of ", stringify!(NotificationMessageDataSound))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).frequency) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NotificationMessageDataSound),
            "::",
            stringify!(frequency)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).volume) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(NotificationMessageDataSound),
            "::",
            stringify!(volume)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NotificationMessageDataLed {
    pub value: u8,
}
#[test]
fn bindgen_test_layout_NotificationMessageDataLed() {
    const UNINIT: ::core::mem::MaybeUninit<NotificationMessageDataLed> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<NotificationMessageDataLed>(),
        1usize,
        concat!("Size of: ", stringify!(NotificationMessageDataLed))
    );
    assert_eq!(
        ::core::mem::align_of::<NotificationMessageDataLed>(),
        1usize,
        concat!("Alignment of ", stringify!(NotificationMessageDataLed))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NotificationMessageDataLed),
            "::",
            stringify!(value)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NotificationMessageDataVibro {
    pub on: bool,
}
#[test]
fn bindgen_test_layout_NotificationMessageDataVibro() {
    const UNINIT: ::core::mem::MaybeUninit<NotificationMessageDataVibro> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<NotificationMessageDataVibro>(),
        1usize,
        concat!("Size of: ", stringify!(NotificationMessageDataVibro))
    );
    assert_eq!(
        ::core::mem::align_of::<NotificationMessageDataVibro>(),
        1usize,
        concat!("Alignment of ", stringify!(NotificationMessageDataVibro))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).on) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NotificationMessageDataVibro),
            "::",
            stringify!(on)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NotificationMessageDataDelay {
    pub length: u32,
}
#[test]
fn bindgen_test_layout_NotificationMessageDataDelay() {
    const UNINIT: ::core::mem::MaybeUninit<NotificationMessageDataDelay> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<NotificationMessageDataDelay>(),
        4usize,
        concat!("Size of: ", stringify!(NotificationMessageDataDelay))
    );
    assert_eq!(
        ::core::mem::align_of::<NotificationMessageDataDelay>(),
        4usize,
        concat!("Alignment of ", stringify!(NotificationMessageDataDelay))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NotificationMessageDataDelay),
            "::",
            stringify!(length)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NotificationMessageDataForcedSettings {
    pub speaker_volume: f32,
    pub vibro: bool,
    pub display_brightness: f32,
}
#[test]
fn bindgen_test_layout_NotificationMessageDataForcedSettings() {
    const UNINIT: ::core::mem::MaybeUninit<NotificationMessageDataForcedSettings> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<NotificationMessageDataForcedSettings>(),
        12usize,
        concat!(
            "Size of: ",
            stringify!(NotificationMessageDataForcedSettings)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<NotificationMessageDataForcedSettings>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(NotificationMessageDataForcedSettings)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).speaker_volume) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NotificationMessageDataForcedSettings),
            "::",
            stringify!(speaker_volume)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).vibro) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(NotificationMessageDataForcedSettings),
            "::",
            stringify!(vibro)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).display_brightness) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(NotificationMessageDataForcedSettings),
            "::",
            stringify!(display_brightness)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NotificationMessageDataLedBlink {
    pub on_time: u16,
    pub period: u16,
    pub color: Light,
}
#[test]
fn bindgen_test_layout_NotificationMessageDataLedBlink() {
    const UNINIT: ::core::mem::MaybeUninit<NotificationMessageDataLedBlink> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<NotificationMessageDataLedBlink>(),
        6usize,
        concat!("Size of: ", stringify!(NotificationMessageDataLedBlink))
    );
    assert_eq!(
        ::core::mem::align_of::<NotificationMessageDataLedBlink>(),
        2usize,
        concat!("Alignment of ", stringify!(NotificationMessageDataLedBlink))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).on_time) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NotificationMessageDataLedBlink),
            "::",
            stringify!(on_time)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).period) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(NotificationMessageDataLedBlink),
            "::",
            stringify!(period)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).color) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(NotificationMessageDataLedBlink),
            "::",
            stringify!(color)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union NotificationMessageData {
    pub sound: NotificationMessageDataSound,
    pub led: NotificationMessageDataLed,
    pub led_blink: NotificationMessageDataLedBlink,
    pub vibro: NotificationMessageDataVibro,
    pub delay: NotificationMessageDataDelay,
    pub forced_settings: NotificationMessageDataForcedSettings,
}
#[test]
fn bindgen_test_layout_NotificationMessageData() {
    const UNINIT: ::core::mem::MaybeUninit<NotificationMessageData> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<NotificationMessageData>(),
        12usize,
        concat!("Size of: ", stringify!(NotificationMessageData))
    );
    assert_eq!(
        ::core::mem::align_of::<NotificationMessageData>(),
        4usize,
        concat!("Alignment of ", stringify!(NotificationMessageData))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).sound) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NotificationMessageData),
            "::",
            stringify!(sound)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).led) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NotificationMessageData),
            "::",
            stringify!(led)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).led_blink) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NotificationMessageData),
            "::",
            stringify!(led_blink)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).vibro) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NotificationMessageData),
            "::",
            stringify!(vibro)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).delay) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NotificationMessageData),
            "::",
            stringify!(delay)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).forced_settings) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NotificationMessageData),
            "::",
            stringify!(forced_settings)
        )
    );
}
pub const NotificationMessageType_NotificationMessageTypeVibro: NotificationMessageType = 0;
pub const NotificationMessageType_NotificationMessageTypeSoundOn: NotificationMessageType = 1;
pub const NotificationMessageType_NotificationMessageTypeSoundOff: NotificationMessageType = 2;
pub const NotificationMessageType_NotificationMessageTypeLedRed: NotificationMessageType = 3;
pub const NotificationMessageType_NotificationMessageTypeLedGreen: NotificationMessageType = 4;
pub const NotificationMessageType_NotificationMessageTypeLedBlue: NotificationMessageType = 5;
pub const NotificationMessageType_NotificationMessageTypeLedBlinkStart: NotificationMessageType = 6;
pub const NotificationMessageType_NotificationMessageTypeLedBlinkStop: NotificationMessageType = 7;
pub const NotificationMessageType_NotificationMessageTypeLedBlinkColor: NotificationMessageType = 8;
pub const NotificationMessageType_NotificationMessageTypeDelay: NotificationMessageType = 9;
pub const NotificationMessageType_NotificationMessageTypeLedDisplayBacklight:
    NotificationMessageType = 10;
pub const NotificationMessageType_NotificationMessageTypeLedDisplayBacklightEnforceOn:
    NotificationMessageType = 11;
pub const NotificationMessageType_NotificationMessageTypeLedDisplayBacklightEnforceAuto:
    NotificationMessageType = 12;
pub const NotificationMessageType_NotificationMessageTypeDoNotReset: NotificationMessageType = 13;
pub const NotificationMessageType_NotificationMessageTypeForceSpeakerVolumeSetting:
    NotificationMessageType = 14;
pub const NotificationMessageType_NotificationMessageTypeForceVibroSetting:
    NotificationMessageType = 15;
pub const NotificationMessageType_NotificationMessageTypeForceDisplayBrightnessSetting:
    NotificationMessageType = 16;
pub const NotificationMessageType_NotificationMessageTypeLedBrightnessSettingApply:
    NotificationMessageType = 17;
pub type NotificationMessageType = core::ffi::c_uchar;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct NotificationMessage {
    pub type_: NotificationMessageType,
    pub data: NotificationMessageData,
}
#[test]
fn bindgen_test_layout_NotificationMessage() {
    const UNINIT: ::core::mem::MaybeUninit<NotificationMessage> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<NotificationMessage>(),
        16usize,
        concat!("Size of: ", stringify!(NotificationMessage))
    );
    assert_eq!(
        ::core::mem::align_of::<NotificationMessage>(),
        4usize,
        concat!("Alignment of ", stringify!(NotificationMessage))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NotificationMessage),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(NotificationMessage),
            "::",
            stringify!(data)
        )
    );
}
pub type NotificationSequence = [*const NotificationMessage; 0usize];
extern "C" {
    pub fn notification_message(app: *mut NotificationApp, sequence: *const NotificationSequence);
}
extern "C" {
    pub fn notification_message_block(
        app: *mut NotificationApp,
        sequence: *const NotificationSequence,
    );
}
extern "C" {
    #[doc = " @brief Send internal (apply to permanent layer) notification message. Think twice before use.\n\n @param app notification record content\n @param sequence notification sequence"]
    pub fn notification_internal_message(
        app: *mut NotificationApp,
        sequence: *const NotificationSequence,
    );
}
extern "C" {
    #[doc = " @brief Send internal (apply to permanent layer) notification message and wait for notification end. Think twice before use.\n\n @param app notification record content\n @param sequence notification sequence"]
    pub fn notification_internal_message_block(
        app: *mut NotificationApp,
        sequence: *const NotificationSequence,
    );
}
extern "C" {
    pub static message_click: NotificationMessage;
}
extern "C" {
    pub static message_note_c0: NotificationMessage;
}
extern "C" {
    pub static message_note_cs0: NotificationMessage;
}
extern "C" {
    pub static message_note_d0: NotificationMessage;
}
extern "C" {
    pub static message_note_ds0: NotificationMessage;
}
extern "C" {
    pub static message_note_e0: NotificationMessage;
}
extern "C" {
    pub static message_note_f0: NotificationMessage;
}
extern "C" {
    pub static message_note_fs0: NotificationMessage;
}
extern "C" {
    pub static message_note_g0: NotificationMessage;
}
extern "C" {
    pub static message_note_gs0: NotificationMessage;
}
extern "C" {
    pub static message_note_a0: NotificationMessage;
}
extern "C" {
    pub static message_note_as0: NotificationMessage;
}
extern "C" {
    pub static message_note_b0: NotificationMessage;
}
extern "C" {
    pub static message_note_c1: NotificationMessage;
}
extern "C" {
    pub static message_note_cs1: NotificationMessage;
}
extern "C" {
    pub static message_note_d1: NotificationMessage;
}
extern "C" {
    pub static message_note_ds1: NotificationMessage;
}
extern "C" {
    pub static message_note_e1: NotificationMessage;
}
extern "C" {
    pub static message_note_f1: NotificationMessage;
}
extern "C" {
    pub static message_note_fs1: NotificationMessage;
}
extern "C" {
    pub static message_note_g1: NotificationMessage;
}
extern "C" {
    pub static message_note_gs1: NotificationMessage;
}
extern "C" {
    pub static message_note_a1: NotificationMessage;
}
extern "C" {
    pub static message_note_as1: NotificationMessage;
}
extern "C" {
    pub static message_note_b1: NotificationMessage;
}
extern "C" {
    pub static message_note_c2: NotificationMessage;
}
extern "C" {
    pub static message_note_cs2: NotificationMessage;
}
extern "C" {
    pub static message_note_d2: NotificationMessage;
}
extern "C" {
    pub static message_note_ds2: NotificationMessage;
}
extern "C" {
    pub static message_note_e2: NotificationMessage;
}
extern "C" {
    pub static message_note_f2: NotificationMessage;
}
extern "C" {
    pub static message_note_fs2: NotificationMessage;
}
extern "C" {
    pub static message_note_g2: NotificationMessage;
}
extern "C" {
    pub static message_note_gs2: NotificationMessage;
}
extern "C" {
    pub static message_note_a2: NotificationMessage;
}
extern "C" {
    pub static message_note_as2: NotificationMessage;
}
extern "C" {
    pub static message_note_b2: NotificationMessage;
}
extern "C" {
    pub static message_note_c3: NotificationMessage;
}
extern "C" {
    pub static message_note_cs3: NotificationMessage;
}
extern "C" {
    pub static message_note_d3: NotificationMessage;
}
extern "C" {
    pub static message_note_ds3: NotificationMessage;
}
extern "C" {
    pub static message_note_e3: NotificationMessage;
}
extern "C" {
    pub static message_note_f3: NotificationMessage;
}
extern "C" {
    pub static message_note_fs3: NotificationMessage;
}
extern "C" {
    pub static message_note_g3: NotificationMessage;
}
extern "C" {
    pub static message_note_gs3: NotificationMessage;
}
extern "C" {
    pub static message_note_a3: NotificationMessage;
}
extern "C" {
    pub static message_note_as3: NotificationMessage;
}
extern "C" {
    pub static message_note_b3: NotificationMessage;
}
extern "C" {
    pub static message_note_c4: NotificationMessage;
}
extern "C" {
    pub static message_note_cs4: NotificationMessage;
}
extern "C" {
    pub static message_note_d4: NotificationMessage;
}
extern "C" {
    pub static message_note_ds4: NotificationMessage;
}
extern "C" {
    pub static message_note_e4: NotificationMessage;
}
extern "C" {
    pub static message_note_f4: NotificationMessage;
}
extern "C" {
    pub static message_note_fs4: NotificationMessage;
}
extern "C" {
    pub static message_note_g4: NotificationMessage;
}
extern "C" {
    pub static message_note_gs4: NotificationMessage;
}
extern "C" {
    pub static message_note_a4: NotificationMessage;
}
extern "C" {
    pub static message_note_as4: NotificationMessage;
}
extern "C" {
    pub static message_note_b4: NotificationMessage;
}
extern "C" {
    pub static message_note_c5: NotificationMessage;
}
extern "C" {
    pub static message_note_cs5: NotificationMessage;
}
extern "C" {
    pub static message_note_d5: NotificationMessage;
}
extern "C" {
    pub static message_note_ds5: NotificationMessage;
}
extern "C" {
    pub static message_note_e5: NotificationMessage;
}
extern "C" {
    pub static message_note_f5: NotificationMessage;
}
extern "C" {
    pub static message_note_fs5: NotificationMessage;
}
extern "C" {
    pub static message_note_g5: NotificationMessage;
}
extern "C" {
    pub static message_note_gs5: NotificationMessage;
}
extern "C" {
    pub static message_note_a5: NotificationMessage;
}
extern "C" {
    pub static message_note_as5: NotificationMessage;
}
extern "C" {
    pub static message_note_b5: NotificationMessage;
}
extern "C" {
    pub static message_note_c6: NotificationMessage;
}
extern "C" {
    pub static message_note_cs6: NotificationMessage;
}
extern "C" {
    pub static message_note_d6: NotificationMessage;
}
extern "C" {
    pub static message_note_ds6: NotificationMessage;
}
extern "C" {
    pub static message_note_e6: NotificationMessage;
}
extern "C" {
    pub static message_note_f6: NotificationMessage;
}
extern "C" {
    pub static message_note_fs6: NotificationMessage;
}
extern "C" {
    pub static message_note_g6: NotificationMessage;
}
extern "C" {
    pub static message_note_gs6: NotificationMessage;
}
extern "C" {
    pub static message_note_a6: NotificationMessage;
}
extern "C" {
    pub static message_note_as6: NotificationMessage;
}
extern "C" {
    pub static message_note_b6: NotificationMessage;
}
extern "C" {
    pub static message_note_c7: NotificationMessage;
}
extern "C" {
    pub static message_note_cs7: NotificationMessage;
}
extern "C" {
    pub static message_note_d7: NotificationMessage;
}
extern "C" {
    pub static message_note_ds7: NotificationMessage;
}
extern "C" {
    pub static message_note_e7: NotificationMessage;
}
extern "C" {
    pub static message_note_f7: NotificationMessage;
}
extern "C" {
    pub static message_note_fs7: NotificationMessage;
}
extern "C" {
    pub static message_note_g7: NotificationMessage;
}
extern "C" {
    pub static message_note_gs7: NotificationMessage;
}
extern "C" {
    pub static message_note_a7: NotificationMessage;
}
extern "C" {
    pub static message_note_as7: NotificationMessage;
}
extern "C" {
    pub static message_note_b7: NotificationMessage;
}
extern "C" {
    pub static message_note_c8: NotificationMessage;
}
extern "C" {
    pub static message_note_cs8: NotificationMessage;
}
extern "C" {
    pub static message_note_d8: NotificationMessage;
}
extern "C" {
    pub static message_note_ds8: NotificationMessage;
}
extern "C" {
    pub static message_note_e8: NotificationMessage;
}
extern "C" {
    pub static message_note_f8: NotificationMessage;
}
extern "C" {
    pub static message_note_fs8: NotificationMessage;
}
extern "C" {
    pub static message_note_g8: NotificationMessage;
}
extern "C" {
    pub static message_note_gs8: NotificationMessage;
}
extern "C" {
    pub static message_note_a8: NotificationMessage;
}
extern "C" {
    pub static message_note_as8: NotificationMessage;
}
extern "C" {
    pub static message_note_b8: NotificationMessage;
}
extern "C" {
    #[doc = " Messages"]
    pub static message_display_backlight_on: NotificationMessage;
}
extern "C" {
    pub static message_display_backlight_off: NotificationMessage;
}
extern "C" {
    pub static message_display_backlight_enforce_on: NotificationMessage;
}
extern "C" {
    pub static message_display_backlight_enforce_auto: NotificationMessage;
}
extern "C" {
    pub static message_red_255: NotificationMessage;
}
extern "C" {
    pub static message_green_255: NotificationMessage;
}
extern "C" {
    pub static message_blue_255: NotificationMessage;
}
extern "C" {
    pub static message_red_0: NotificationMessage;
}
extern "C" {
    pub static message_green_0: NotificationMessage;
}
extern "C" {
    pub static message_blue_0: NotificationMessage;
}
extern "C" {
    pub static message_blink_start_10: NotificationMessage;
}
extern "C" {
    pub static message_blink_start_100: NotificationMessage;
}
extern "C" {
    pub static message_blink_stop: NotificationMessage;
}
extern "C" {
    pub static message_blink_set_color_red: NotificationMessage;
}
extern "C" {
    pub static message_blink_set_color_green: NotificationMessage;
}
extern "C" {
    pub static message_blink_set_color_blue: NotificationMessage;
}
extern "C" {
    pub static message_blink_set_color_cyan: NotificationMessage;
}
extern "C" {
    pub static message_blink_set_color_magenta: NotificationMessage;
}
extern "C" {
    pub static message_blink_set_color_yellow: NotificationMessage;
}
extern "C" {
    pub static message_blink_set_color_white: NotificationMessage;
}
extern "C" {
    pub static message_delay_1: NotificationMessage;
}
extern "C" {
    pub static message_delay_10: NotificationMessage;
}
extern "C" {
    pub static message_delay_25: NotificationMessage;
}
extern "C" {
    pub static message_delay_50: NotificationMessage;
}
extern "C" {
    pub static message_delay_100: NotificationMessage;
}
extern "C" {
    pub static message_delay_250: NotificationMessage;
}
extern "C" {
    pub static message_delay_500: NotificationMessage;
}
extern "C" {
    pub static message_delay_1000: NotificationMessage;
}
extern "C" {
    pub static message_sound_off: NotificationMessage;
}
extern "C" {
    pub static message_vibro_on: NotificationMessage;
}
extern "C" {
    pub static message_vibro_off: NotificationMessage;
}
extern "C" {
    pub static message_do_not_reset: NotificationMessage;
}
extern "C" {
    pub static message_force_speaker_volume_setting_1f: NotificationMessage;
}
extern "C" {
    pub static message_force_vibro_setting_on: NotificationMessage;
}
extern "C" {
    pub static message_force_vibro_setting_off: NotificationMessage;
}
extern "C" {
    pub static message_force_display_brightness_setting_1f: NotificationMessage;
}
extern "C" {
    #[doc = " Message sequences"]
    pub static sequence_reset_red: NotificationSequence;
}
extern "C" {
    pub static sequence_reset_green: NotificationSequence;
}
extern "C" {
    pub static sequence_reset_blue: NotificationSequence;
}
extern "C" {
    pub static sequence_reset_rgb: NotificationSequence;
}
extern "C" {
    pub static sequence_reset_display: NotificationSequence;
}
extern "C" {
    pub static sequence_reset_sound: NotificationSequence;
}
extern "C" {
    pub static sequence_reset_vibro: NotificationSequence;
}
extern "C" {
    pub static sequence_set_vibro_on: NotificationSequence;
}
extern "C" {
    #[doc = " Display: backlight wakeup"]
    pub static sequence_display_backlight_on: NotificationSequence;
}
extern "C" {
    #[doc = " Display: backlight force off"]
    pub static sequence_display_backlight_off: NotificationSequence;
}
extern "C" {
    #[doc = " Display: backlight force off after a delay of 1000ms"]
    pub static sequence_display_backlight_off_delay_1000: NotificationSequence;
}
extern "C" {
    #[doc = " Display: backlight always on lock"]
    pub static sequence_display_backlight_enforce_on: NotificationSequence;
}
extern "C" {
    #[doc = " Display: backlight always on unlock"]
    pub static sequence_display_backlight_enforce_auto: NotificationSequence;
}
extern "C" {
    pub static sequence_charging: NotificationSequence;
}
extern "C" {
    pub static sequence_charged: NotificationSequence;
}
extern "C" {
    pub static sequence_not_charging: NotificationSequence;
}
extern "C" {
    pub static sequence_set_only_red_255: NotificationSequence;
}
extern "C" {
    pub static sequence_set_only_green_255: NotificationSequence;
}
extern "C" {
    pub static sequence_set_only_blue_255: NotificationSequence;
}
extern "C" {
    pub static sequence_set_red_255: NotificationSequence;
}
extern "C" {
    pub static sequence_set_green_255: NotificationSequence;
}
extern "C" {
    pub static sequence_set_blue_255: NotificationSequence;
}
extern "C" {
    pub static sequence_solid_yellow: NotificationSequence;
}
extern "C" {
    pub static sequence_blink_blue_10: NotificationSequence;
}
extern "C" {
    pub static sequence_blink_red_10: NotificationSequence;
}
extern "C" {
    pub static sequence_blink_green_10: NotificationSequence;
}
extern "C" {
    pub static sequence_blink_yellow_10: NotificationSequence;
}
extern "C" {
    pub static sequence_blink_cyan_10: NotificationSequence;
}
extern "C" {
    pub static sequence_blink_magenta_10: NotificationSequence;
}
extern "C" {
    pub static sequence_blink_red_100: NotificationSequence;
}
extern "C" {
    pub static sequence_blink_green_100: NotificationSequence;
}
extern "C" {
    pub static sequence_blink_blue_100: NotificationSequence;
}
extern "C" {
    pub static sequence_blink_yellow_100: NotificationSequence;
}
extern "C" {
    pub static sequence_blink_cyan_100: NotificationSequence;
}
extern "C" {
    pub static sequence_blink_magenta_100: NotificationSequence;
}
extern "C" {
    pub static sequence_blink_white_100: NotificationSequence;
}
extern "C" {
    pub static sequence_blink_start_blue: NotificationSequence;
}
extern "C" {
    pub static sequence_blink_start_red: NotificationSequence;
}
extern "C" {
    pub static sequence_blink_start_green: NotificationSequence;
}
extern "C" {
    pub static sequence_blink_start_yellow: NotificationSequence;
}
extern "C" {
    pub static sequence_blink_start_cyan: NotificationSequence;
}
extern "C" {
    pub static sequence_blink_start_magenta: NotificationSequence;
}
extern "C" {
    pub static sequence_blink_stop: NotificationSequence;
}
extern "C" {
    pub static sequence_single_vibro: NotificationSequence;
}
extern "C" {
    pub static sequence_double_vibro: NotificationSequence;
}
extern "C" {
    pub static sequence_success: NotificationSequence;
}
extern "C" {
    pub static sequence_error: NotificationSequence;
}
extern "C" {
    pub static sequence_audiovisual_alert: NotificationSequence;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Power {
    _unused: [u8; 0],
}
pub const PowerBootMode_PowerBootModeNormal: PowerBootMode = 0;
pub const PowerBootMode_PowerBootModeDfu: PowerBootMode = 1;
pub const PowerBootMode_PowerBootModeUpdateStart: PowerBootMode = 2;
pub type PowerBootMode = core::ffi::c_uchar;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PowerInfo {
    pub gauge_is_ok: bool,
    pub is_charging: bool,
    pub current_charger: f32,
    pub current_gauge: f32,
    pub voltage_battery_charging: f32,
    pub voltage_charger: f32,
    pub voltage_gauge: f32,
    pub voltage_vbus: f32,
    pub capacity_remaining: u32,
    pub capacity_full: u32,
    pub temperature_charger: f32,
    pub temperature_gauge: f32,
    pub charge: u8,
    pub health: u8,
}
#[test]
fn bindgen_test_layout_PowerInfo() {
    const UNINIT: ::core::mem::MaybeUninit<PowerInfo> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<PowerInfo>(),
        48usize,
        concat!("Size of: ", stringify!(PowerInfo))
    );
    assert_eq!(
        ::core::mem::align_of::<PowerInfo>(),
        4usize,
        concat!("Alignment of ", stringify!(PowerInfo))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).gauge_is_ok) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PowerInfo),
            "::",
            stringify!(gauge_is_ok)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).is_charging) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(PowerInfo),
            "::",
            stringify!(is_charging)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).current_charger) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(PowerInfo),
            "::",
            stringify!(current_charger)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).current_gauge) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(PowerInfo),
            "::",
            stringify!(current_gauge)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).voltage_battery_charging) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(PowerInfo),
            "::",
            stringify!(voltage_battery_charging)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).voltage_charger) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(PowerInfo),
            "::",
            stringify!(voltage_charger)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).voltage_gauge) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(PowerInfo),
            "::",
            stringify!(voltage_gauge)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).voltage_vbus) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(PowerInfo),
            "::",
            stringify!(voltage_vbus)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).capacity_remaining) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(PowerInfo),
            "::",
            stringify!(capacity_remaining)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).capacity_full) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(PowerInfo),
            "::",
            stringify!(capacity_full)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).temperature_charger) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(PowerInfo),
            "::",
            stringify!(temperature_charger)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).temperature_gauge) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(PowerInfo),
            "::",
            stringify!(temperature_gauge)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).charge) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(PowerInfo),
            "::",
            stringify!(charge)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).health) as usize - ptr as usize },
        45usize,
        concat!(
            "Offset of field: ",
            stringify!(PowerInfo),
            "::",
            stringify!(health)
        )
    );
}
extern "C" {
    #[doc = " Power off device"]
    pub fn power_off(power: *mut Power);
}
extern "C" {
    #[doc = " Reboot device\n\n @param mode      PowerBootMode"]
    pub fn power_reboot(mode: PowerBootMode);
}
extern "C" {
    #[doc = " Get power info\n\n @param power     Power instance\n @param info      PowerInfo instance"]
    pub fn power_get_info(power: *mut Power, info: *mut PowerInfo);
}
extern "C" {
    #[doc = " Get power event pubsub handler\n\n @param power     Power instance\n\n @return          FuriPubSub instance"]
    pub fn power_get_pubsub(power: *mut Power) -> *mut FuriPubSub;
}
extern "C" {
    #[doc = " Check battery health\n\n @return          true if battery is healthy"]
    pub fn power_is_battery_healthy(power: *mut Power) -> bool;
}
extern "C" {
    #[doc = " Enable or disable battery low level notification message\n\n @param power     Power instance\n @param enable    true - enable, false - disable"]
    pub fn power_enable_low_battery_level_notification(power: *mut Power, enable: bool);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Rpc {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RpcSession {
    _unused: [u8; 0],
}
#[doc = " Callback to send to client any data (e.g. response to command)"]
pub type RpcSendBytesCallback = ::core::option::Option<
    unsafe extern "C" fn(context: *mut core::ffi::c_void, bytes: *mut u8, bytes_len: usize),
>;
#[doc = " Callback to notify client that buffer is empty"]
pub type RpcBufferIsEmptyCallback =
    ::core::option::Option<unsafe extern "C" fn(context: *mut core::ffi::c_void)>;
#[doc = " Callback to notify transport layer that close_session command\n is received. Any other actions lays on transport layer.\n No destruction or session close performed."]
pub type RpcSessionClosedCallback =
    ::core::option::Option<unsafe extern "C" fn(context: *mut core::ffi::c_void)>;
#[doc = " Callback to notify transport layer that session was closed\n and all operations were finished"]
pub type RpcSessionTerminatedCallback =
    ::core::option::Option<unsafe extern "C" fn(context: *mut core::ffi::c_void)>;
extern "C" {
    #[doc = " Open RPC session\n\n USAGE:\n 1) rpc_session_open();\n 2) rpc_session_set_context();\n 3) rpc_session_set_send_bytes_callback();\n 4) rpc_session_set_close_callback();\n 5) while(1) {\n      rpc_session_feed();\n    }\n 6) rpc_session_close();\n\n\n @param   rpc     instance\n @return          pointer to RpcSession descriptor, or\n                  NULL if RPC is busy and can't open session now"]
    pub fn rpc_session_open(rpc: *mut Rpc) -> *mut RpcSession;
}
extern "C" {
    #[doc = " Close RPC session\n It is guaranteed that no callbacks will be called\n as soon as session is closed. So no need in setting\n callbacks to NULL after session close.\n\n @param   session     pointer to RpcSession descriptor"]
    pub fn rpc_session_close(session: *mut RpcSession);
}
extern "C" {
    #[doc = " Set session context for callbacks to pass\n\n @param   session     pointer to RpcSession descriptor\n @param   context     context to pass to callbacks"]
    pub fn rpc_session_set_context(session: *mut RpcSession, context: *mut core::ffi::c_void);
}
extern "C" {
    #[doc = " Set callback to send bytes to client\n  WARN: It's forbidden to call RPC API within RpcSendBytesCallback\n\n @param   session     pointer to RpcSession descriptor\n @param   callback    callback to send bytes to client (can be NULL)"]
    pub fn rpc_session_set_send_bytes_callback(
        session: *mut RpcSession,
        callback: RpcSendBytesCallback,
    );
}
extern "C" {
    #[doc = " Set callback to notify that buffer is empty\n\n @param   session     pointer to RpcSession descriptor\n @param   callback    callback to notify client that buffer is empty (can be NULL)"]
    pub fn rpc_session_set_buffer_is_empty_callback(
        session: *mut RpcSession,
        callback: RpcBufferIsEmptyCallback,
    );
}
extern "C" {
    #[doc = " Set callback to be called when RPC command to close session is received\n  WARN: It's forbidden to call RPC API within RpcSessionClosedCallback\n\n @param   session     pointer to RpcSession descriptor\n @param   callback    callback to inform about RPC close session command (can be NULL)"]
    pub fn rpc_session_set_close_callback(
        session: *mut RpcSession,
        callback: RpcSessionClosedCallback,
    );
}
extern "C" {
    #[doc = " Set callback to be called when RPC session is closed\n\n @param   session     pointer to RpcSession descriptor\n @param   callback    callback to inform about RPC session state"]
    pub fn rpc_session_set_terminated_callback(
        session: *mut RpcSession,
        callback: RpcSessionTerminatedCallback,
    );
}
extern "C" {
    #[doc = " Give bytes to RPC service to decode them and perform command\n\n @param   session     pointer to RpcSession descriptor\n @param   buffer      buffer to provide to RPC service\n @param   size        size of buffer\n @param   timeout     max timeout to wait till all buffer will be consumed\n\n @return              actually consumed bytes"]
    pub fn rpc_session_feed(
        session: *mut RpcSession,
        buffer: *mut u8,
        size: usize,
        timeout: TickType_t,
    ) -> usize;
}
extern "C" {
    #[doc = " Get available size of RPC buffer\n\n @param   session     pointer to RpcSession descriptor\n\n @return              bytes available in buffer"]
    pub fn rpc_session_get_available_size(session: *mut RpcSession) -> usize;
}
pub const RpcAppSystemEvent_RpcAppEventSessionClose: RpcAppSystemEvent = 0;
pub const RpcAppSystemEvent_RpcAppEventAppExit: RpcAppSystemEvent = 1;
pub const RpcAppSystemEvent_RpcAppEventLoadFile: RpcAppSystemEvent = 2;
pub const RpcAppSystemEvent_RpcAppEventButtonPress: RpcAppSystemEvent = 3;
pub const RpcAppSystemEvent_RpcAppEventButtonRelease: RpcAppSystemEvent = 4;
pub type RpcAppSystemEvent = core::ffi::c_uchar;
pub type RpcAppSystemCallback = ::core::option::Option<
    unsafe extern "C" fn(event: RpcAppSystemEvent, context: *mut core::ffi::c_void),
>;
pub type RpcAppSystemDataExchangeCallback = ::core::option::Option<
    unsafe extern "C" fn(data: *const u8, data_size: usize, context: *mut core::ffi::c_void),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RpcAppSystem {
    _unused: [u8; 0],
}
extern "C" {
    pub fn rpc_system_app_set_callback(
        rpc_app: *mut RpcAppSystem,
        callback: RpcAppSystemCallback,
        ctx: *mut core::ffi::c_void,
    );
}
extern "C" {
    pub fn rpc_system_app_send_started(rpc_app: *mut RpcAppSystem);
}
extern "C" {
    pub fn rpc_system_app_send_exited(rpc_app: *mut RpcAppSystem);
}
extern "C" {
    pub fn rpc_system_app_get_data(rpc_app: *mut RpcAppSystem) -> *const core::ffi::c_char;
}
extern "C" {
    pub fn rpc_system_app_confirm(
        rpc_app: *mut RpcAppSystem,
        event: RpcAppSystemEvent,
        result: bool,
    );
}
extern "C" {
    pub fn rpc_system_app_set_error_code(rpc_app: *mut RpcAppSystem, error_code: u32);
}
extern "C" {
    pub fn rpc_system_app_set_error_text(
        rpc_app: *mut RpcAppSystem,
        error_text: *const core::ffi::c_char,
    );
}
extern "C" {
    pub fn rpc_system_app_error_reset(rpc_app: *mut RpcAppSystem);
}
extern "C" {
    pub fn rpc_system_app_set_data_exchange_callback(
        rpc_app: *mut RpcAppSystem,
        callback: RpcAppSystemDataExchangeCallback,
        ctx: *mut core::ffi::c_void,
    );
}
extern "C" {
    pub fn rpc_system_app_exchange_data(
        rpc_app: *mut RpcAppSystem,
        data: *const u8,
        data_size: usize,
    );
}
#[doc = "< Read access"]
pub const FS_AccessMode_FSAM_READ: FS_AccessMode = 1;
#[doc = "< Write access"]
pub const FS_AccessMode_FSAM_WRITE: FS_AccessMode = 2;
#[doc = "< Read and write access"]
pub const FS_AccessMode_FSAM_READ_WRITE: FS_AccessMode = 3;
#[doc = " Access mode flags"]
pub type FS_AccessMode = core::ffi::c_uchar;
#[doc = "< Open file, fail if file doesn't exist"]
pub const FS_OpenMode_FSOM_OPEN_EXISTING: FS_OpenMode = 1;
#[doc = "< Open file. Create new file if not exist"]
pub const FS_OpenMode_FSOM_OPEN_ALWAYS: FS_OpenMode = 2;
#[doc = "< Open file. Create new file if not exist. Set R/W pointer to EOF"]
pub const FS_OpenMode_FSOM_OPEN_APPEND: FS_OpenMode = 4;
#[doc = "< Creates a new file. Fails if the file is exist"]
pub const FS_OpenMode_FSOM_CREATE_NEW: FS_OpenMode = 8;
#[doc = "< Creates a new file. If file exist, truncate to zero size"]
pub const FS_OpenMode_FSOM_CREATE_ALWAYS: FS_OpenMode = 16;
#[doc = " Open mode flags"]
pub type FS_OpenMode = core::ffi::c_uchar;
#[doc = "< No error"]
pub const FS_Error_FSE_OK: FS_Error = 0;
#[doc = "< FS not ready"]
pub const FS_Error_FSE_NOT_READY: FS_Error = 1;
#[doc = "< File/Dir already exist"]
pub const FS_Error_FSE_EXIST: FS_Error = 2;
#[doc = "< File/Dir does not exist"]
pub const FS_Error_FSE_NOT_EXIST: FS_Error = 3;
#[doc = "< Invalid API parameter"]
pub const FS_Error_FSE_INVALID_PARAMETER: FS_Error = 4;
#[doc = "< Access denied"]
pub const FS_Error_FSE_DENIED: FS_Error = 5;
#[doc = "< Invalid name/path"]
pub const FS_Error_FSE_INVALID_NAME: FS_Error = 6;
#[doc = "< Internal error"]
pub const FS_Error_FSE_INTERNAL: FS_Error = 7;
#[doc = "< Function not implemented"]
pub const FS_Error_FSE_NOT_IMPLEMENTED: FS_Error = 8;
#[doc = "< File/Dir already opened"]
pub const FS_Error_FSE_ALREADY_OPEN: FS_Error = 9;
#[doc = " API errors enumeration"]
pub type FS_Error = core::ffi::c_uchar;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct File {
    _unused: [u8; 0],
}
#[doc = "  Structure that hold file info"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FileInfo {
    #[doc = "< flags from FS_Flags enum"]
    pub flags: u8,
    #[doc = "< file size"]
    pub size: u64,
}
#[test]
fn bindgen_test_layout_FileInfo() {
    const UNINIT: ::core::mem::MaybeUninit<FileInfo> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<FileInfo>(),
        16usize,
        concat!("Size of: ", stringify!(FileInfo))
    );
    assert_eq!(
        ::core::mem::align_of::<FileInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(FileInfo))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FileInfo),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(FileInfo),
            "::",
            stringify!(size)
        )
    );
}
extern "C" {
    #[doc = " Gets the error text from FS_Error\n @param error_id error id\n @return const char* error text"]
    pub fn filesystem_api_error_get_desc(error_id: FS_Error) -> *const core::ffi::c_char;
}
pub const SDFsType_FST_UNKNOWN: SDFsType = 0;
pub const SDFsType_FST_FAT12: SDFsType = 1;
pub const SDFsType_FST_FAT16: SDFsType = 2;
pub const SDFsType_FST_FAT32: SDFsType = 3;
pub const SDFsType_FST_EXFAT: SDFsType = 4;
pub type SDFsType = core::ffi::c_uchar;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SDInfo {
    pub fs_type: SDFsType,
    pub kb_total: u32,
    pub kb_free: u32,
    pub cluster_size: u16,
    pub sector_size: u16,
    pub label: [core::ffi::c_char; 34usize],
    pub manufacturer_id: u8,
    pub oem_id: [core::ffi::c_char; 3usize],
    pub product_name: [core::ffi::c_char; 6usize],
    pub product_revision_major: u8,
    pub product_revision_minor: u8,
    pub product_serial_number: u32,
    pub manufacturing_month: u8,
    pub manufacturing_year: u16,
    pub error: FS_Error,
}
#[test]
fn bindgen_test_layout_SDInfo() {
    const UNINIT: ::core::mem::MaybeUninit<SDInfo> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SDInfo>(),
        76usize,
        concat!("Size of: ", stringify!(SDInfo))
    );
    assert_eq!(
        ::core::mem::align_of::<SDInfo>(),
        4usize,
        concat!("Alignment of ", stringify!(SDInfo))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fs_type) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDInfo),
            "::",
            stringify!(fs_type)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).kb_total) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SDInfo),
            "::",
            stringify!(kb_total)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).kb_free) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SDInfo),
            "::",
            stringify!(kb_free)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).cluster_size) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(SDInfo),
            "::",
            stringify!(cluster_size)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).sector_size) as usize - ptr as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(SDInfo),
            "::",
            stringify!(sector_size)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).label) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SDInfo),
            "::",
            stringify!(label)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).manufacturer_id) as usize - ptr as usize },
        50usize,
        concat!(
            "Offset of field: ",
            stringify!(SDInfo),
            "::",
            stringify!(manufacturer_id)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).oem_id) as usize - ptr as usize },
        51usize,
        concat!(
            "Offset of field: ",
            stringify!(SDInfo),
            "::",
            stringify!(oem_id)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).product_name) as usize - ptr as usize },
        54usize,
        concat!(
            "Offset of field: ",
            stringify!(SDInfo),
            "::",
            stringify!(product_name)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).product_revision_major) as usize - ptr as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(SDInfo),
            "::",
            stringify!(product_revision_major)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).product_revision_minor) as usize - ptr as usize },
        61usize,
        concat!(
            "Offset of field: ",
            stringify!(SDInfo),
            "::",
            stringify!(product_revision_minor)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).product_serial_number) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(SDInfo),
            "::",
            stringify!(product_serial_number)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).manufacturing_month) as usize - ptr as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(SDInfo),
            "::",
            stringify!(manufacturing_month)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).manufacturing_year) as usize - ptr as usize },
        70usize,
        concat!(
            "Offset of field: ",
            stringify!(SDInfo),
            "::",
            stringify!(manufacturing_year)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).error) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(SDInfo),
            "::",
            stringify!(error)
        )
    );
}
extern "C" {
    pub fn sd_api_get_fs_type_text(fs_type: SDFsType) -> *const core::ffi::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Storage {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " Allocates and initializes a file descriptor\n @return File*"]
    pub fn storage_file_alloc(storage: *mut Storage) -> *mut File;
}
extern "C" {
    #[doc = " Frees the file descriptor. Closes the file if it was open."]
    pub fn storage_file_free(file: *mut File);
}
extern "C" {
    #[doc = " Get storage pubsub.\n Storage will send StorageEvent messages.\n @param storage\n @return FuriPubSub*"]
    pub fn storage_get_pubsub(storage: *mut Storage) -> *mut FuriPubSub;
}
extern "C" {
    #[doc = " Opens an existing file or create a new one.\n @param file pointer to file object.\n @param path path to file\n @param access_mode access mode from FS_AccessMode\n @param open_mode open mode from FS_OpenMode\n @return success flag. You need to close the file even if the open operation failed."]
    pub fn storage_file_open(
        file: *mut File,
        path: *const core::ffi::c_char,
        access_mode: FS_AccessMode,
        open_mode: FS_OpenMode,
    ) -> bool;
}
extern "C" {
    #[doc = " Close the file.\n @param file pointer to a file object, the file object will be freed.\n @return success flag"]
    pub fn storage_file_close(file: *mut File) -> bool;
}
extern "C" {
    #[doc = " Tells if the file is open\n @param file pointer to a file object\n @return bool true if file is open"]
    pub fn storage_file_is_open(file: *mut File) -> bool;
}
extern "C" {
    #[doc = " Tells if the file is a directory\n @param file pointer to a file object\n @return bool true if file is a directory"]
    pub fn storage_file_is_dir(file: *mut File) -> bool;
}
extern "C" {
    #[doc = " Reads bytes from a file into a buffer\n @param file pointer to file object.\n @param buff pointer to a buffer, for reading\n @param bytes_to_read how many bytes to read. Must be less than or equal to the size of the buffer.\n @return uint16_t how many bytes were actually read"]
    pub fn storage_file_read(
        file: *mut File,
        buff: *mut core::ffi::c_void,
        bytes_to_read: u16,
    ) -> u16;
}
extern "C" {
    #[doc = " Writes bytes from a buffer to a file\n @param file pointer to file object.\n @param buff pointer to buffer, for writing\n @param bytes_to_write how many bytes to write. Must be less than or equal to the size of the buffer.\n @return uint16_t how many bytes were actually written"]
    pub fn storage_file_write(
        file: *mut File,
        buff: *const core::ffi::c_void,
        bytes_to_write: u16,
    ) -> u16;
}
extern "C" {
    #[doc = " Moves the r/w pointer\n @param file pointer to file object.\n @param offset offset to move the r/w pointer\n @param from_start set an offset from the start or from the current position\n @return success flag"]
    pub fn storage_file_seek(file: *mut File, offset: u32, from_start: bool) -> bool;
}
extern "C" {
    #[doc = " Gets the position of the r/w pointer\n @param file pointer to file object.\n @return uint64_t position of the r/w pointer"]
    pub fn storage_file_tell(file: *mut File) -> u64;
}
extern "C" {
    #[doc = " Truncates the file size to the current position of the r/w pointer\n @param file pointer to file object.\n @return bool success flag"]
    pub fn storage_file_truncate(file: *mut File) -> bool;
}
extern "C" {
    #[doc = " Gets the size of the file\n @param file pointer to file object.\n @return uint64_t size of the file"]
    pub fn storage_file_size(file: *mut File) -> u64;
}
extern "C" {
    #[doc = " Checks that the r/w pointer is at the end of the file\n @param file pointer to file object.\n @return bool success flag"]
    pub fn storage_file_eof(file: *mut File) -> bool;
}
extern "C" {
    #[doc = " @brief Check that file exists\n\n @param storage\n @param path\n @return true if file exists"]
    pub fn storage_file_exists(storage: *mut Storage, path: *const core::ffi::c_char) -> bool;
}
extern "C" {
    #[doc = " Opens a directory to get objects from it\n @param app pointer to the api\n @param file pointer to file object.\n @param path path to directory\n @return bool success flag. You need to close the directory even if the open operation failed."]
    pub fn storage_dir_open(file: *mut File, path: *const core::ffi::c_char) -> bool;
}
extern "C" {
    #[doc = " Close the directory. Also free file handle structure and point it to the NULL.\n @param file pointer to a file object.\n @return bool success flag"]
    pub fn storage_dir_close(file: *mut File) -> bool;
}
extern "C" {
    #[doc = " Reads the next object in the directory\n @param file pointer to file object.\n @param fileinfo pointer to the read FileInfo, may be NULL\n @param name pointer to name buffer, may be NULL\n @param name_length name buffer length\n @return success flag (if the next object does not exist, it also returns false and sets the file error id to FSE_NOT_EXIST)"]
    pub fn storage_dir_read(
        file: *mut File,
        fileinfo: *mut FileInfo,
        name: *mut core::ffi::c_char,
        name_length: u16,
    ) -> bool;
}
extern "C" {
    #[doc = " Retrieves unix timestamp of last access\n\n @param      storage    The storage instance\n @param      path       path to file/directory\n @param      timestamp  the timestamp pointer\n\n @return     FS_Error operation result"]
    pub fn storage_common_timestamp(
        storage: *mut Storage,
        path: *const core::ffi::c_char,
        timestamp: *mut u32,
    ) -> FS_Error;
}
extern "C" {
    #[doc = " Retrieves information about a file/directory\n @param app pointer to the api\n @param path path to file/directory\n @param fileinfo pointer to the read FileInfo, may be NULL\n @return FS_Error operation result"]
    pub fn storage_common_stat(
        storage: *mut Storage,
        path: *const core::ffi::c_char,
        fileinfo: *mut FileInfo,
    ) -> FS_Error;
}
extern "C" {
    #[doc = " Removes a file/directory from the repository, the directory must be empty and the file/directory must not be open\n @param app pointer to the api\n @param path\n @return FS_Error operation result"]
    pub fn storage_common_remove(storage: *mut Storage, path: *const core::ffi::c_char)
        -> FS_Error;
}
extern "C" {
    #[doc = " Renames file/directory, file/directory must not be open\n @param app pointer to the api\n @param old_path old path\n @param new_path new path\n @return FS_Error operation result"]
    pub fn storage_common_rename(
        storage: *mut Storage,
        old_path: *const core::ffi::c_char,
        new_path: *const core::ffi::c_char,
    ) -> FS_Error;
}
extern "C" {
    #[doc = " Copy file, file must not be open\n @param app pointer to the api\n @param old_path old path\n @param new_path new path\n @return FS_Error operation result"]
    pub fn storage_common_copy(
        storage: *mut Storage,
        old_path: *const core::ffi::c_char,
        new_path: *const core::ffi::c_char,
    ) -> FS_Error;
}
extern "C" {
    #[doc = " Copy one folder contents into another with rename of all conflicting files\n @param app pointer to the api\n @param old_path old path\n @param new_path new path\n @return FS_Error operation result"]
    pub fn storage_common_merge(
        storage: *mut Storage,
        old_path: *const core::ffi::c_char,
        new_path: *const core::ffi::c_char,
    ) -> FS_Error;
}
extern "C" {
    #[doc = " Creates a directory\n @param app pointer to the api\n @param path directory path\n @return FS_Error operation result"]
    pub fn storage_common_mkdir(storage: *mut Storage, path: *const core::ffi::c_char) -> FS_Error;
}
extern "C" {
    #[doc = " Gets general information about the storage\n @param app pointer to the api\n @param fs_path the path to the storage of interest\n @param total_space pointer to total space record, will be filled\n @param free_space pointer to free space record, will be filled\n @return FS_Error operation result"]
    pub fn storage_common_fs_info(
        storage: *mut Storage,
        fs_path: *const core::ffi::c_char,
        total_space: *mut u64,
        free_space: *mut u64,
    ) -> FS_Error;
}
extern "C" {
    #[doc = " Retrieves the error text from the error id\n @param error_id error id\n @return const char* error text"]
    pub fn storage_error_get_desc(error_id: FS_Error) -> *const core::ffi::c_char;
}
extern "C" {
    #[doc = " Retrieves the error id from the file object\n @param file pointer to file object. Pointer must not point to NULL. YOU CANNOT RETRIEVE THE ERROR ID IF THE FILE HAS BEEN CLOSED\n @return FS_Error error id"]
    pub fn storage_file_get_error(file: *mut File) -> FS_Error;
}
extern "C" {
    #[doc = " Retrieves the error text from the file object\n @param file pointer to file object. Pointer must not point to NULL. YOU CANNOT RETRIEVE THE ERROR TEXT IF THE FILE HAS BEEN CLOSED\n @return const char* error text"]
    pub fn storage_file_get_error_desc(file: *mut File) -> *const core::ffi::c_char;
}
extern "C" {
    #[doc = " Formats SD Card\n @param api pointer to the api\n @return FS_Error operation result"]
    pub fn storage_sd_format(api: *mut Storage) -> FS_Error;
}
extern "C" {
    #[doc = " Will unmount the SD card\n @param api pointer to the api\n @return FS_Error operation result"]
    pub fn storage_sd_unmount(api: *mut Storage) -> FS_Error;
}
extern "C" {
    #[doc = " Retrieves SD card information\n @param api pointer to the api\n @param info pointer to the info\n @return FS_Error operation result"]
    pub fn storage_sd_info(api: *mut Storage, info: *mut SDInfo) -> FS_Error;
}
extern "C" {
    #[doc = " Retrieves SD card status\n @param api pointer to the api\n @return FS_Error operation result"]
    pub fn storage_sd_status(api: *mut Storage) -> FS_Error;
}
#[doc = " Internal LFS Functions"]
pub type Storage_name_converter =
    ::core::option::Option<unsafe extern "C" fn(arg1: *mut FuriString)>;
extern "C" {
    #[doc = " Backs up internal storage to a tar archive\n @param api pointer to the api\n @param dstmane destination archive path\n @return FS_Error operation result"]
    pub fn storage_int_backup(api: *mut Storage, dstname: *const core::ffi::c_char) -> FS_Error;
}
extern "C" {
    #[doc = " Restores internal storage from a tar archive\n @param api pointer to the api\n @param dstmane archive path\n @param converter pointer to filename conversion function, may be NULL\n @return FS_Error operation result"]
    pub fn storage_int_restore(
        api: *mut Storage,
        dstname: *const core::ffi::c_char,
        converter: Storage_name_converter,
    ) -> FS_Error;
}
extern "C" {
    #[doc = " Removes a file/directory, the directory must be empty and the file/directory must not be open\n @param storage pointer to the api\n @param path\n @return true on success or if file/dir is not exist"]
    pub fn storage_simply_remove(storage: *mut Storage, path: *const core::ffi::c_char) -> bool;
}
extern "C" {
    #[doc = " Recursively removes a file/directory, the directory can be not empty\n @param storage pointer to the api\n @param path\n @return true on success or if file/dir is not exist"]
    pub fn storage_simply_remove_recursive(
        storage: *mut Storage,
        path: *const core::ffi::c_char,
    ) -> bool;
}
extern "C" {
    #[doc = " Creates a directory\n @param storage\n @param path\n @return true on success or if directory is already exist"]
    pub fn storage_simply_mkdir(storage: *mut Storage, path: *const core::ffi::c_char) -> bool;
}
extern "C" {
    #[doc = " @brief Get next free filename.\n\n @param storage\n @param dirname\n @param filename\n @param fileextension\n @param nextfilename return name\n @param max_len  max len name"]
    pub fn storage_get_next_filename(
        storage: *mut Storage,
        dirname: *const core::ffi::c_char,
        filename: *const core::ffi::c_char,
        fileextension: *const core::ffi::c_char,
        nextfilename: *mut FuriString,
        max_len: u8,
    );
}
#[doc = " @brief  LPTIM Init structure definition"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LL_LPTIM_InitTypeDef {
    #[doc = "< Specifies the source of the clock used by the LPTIM instance.\nThis parameter can be a value of @ref LPTIM_LL_EC_CLK_SOURCE.\n\nThis feature can be modified afterwards using unitary\nfunction @ref LL_LPTIM_SetClockSource()."]
    pub ClockSource: u32,
    #[doc = "< Specifies the prescaler division ratio.\nThis parameter can be a value of @ref LPTIM_LL_EC_PRESCALER.\n\nThis feature can be modified afterwards using using unitary\nfunction @ref LL_LPTIM_SetPrescaler()."]
    pub Prescaler: u32,
    #[doc = "< Specifies the waveform shape.\nThis parameter can be a value of @ref LPTIM_LL_EC_OUTPUT_WAVEFORM.\n\nThis feature can be modified afterwards using unitary\nfunction @ref LL_LPTIM_ConfigOutput()."]
    pub Waveform: u32,
    #[doc = "< Specifies waveform polarity.\nThis parameter can be a value of @ref LPTIM_LL_EC_OUTPUT_POLARITY.\n\nThis feature can be modified afterwards using unitary\nfunction @ref LL_LPTIM_ConfigOutput()."]
    pub Polarity: u32,
}
#[test]
fn bindgen_test_layout_LL_LPTIM_InitTypeDef() {
    const UNINIT: ::core::mem::MaybeUninit<LL_LPTIM_InitTypeDef> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<LL_LPTIM_InitTypeDef>(),
        16usize,
        concat!("Size of: ", stringify!(LL_LPTIM_InitTypeDef))
    );
    assert_eq!(
        ::core::mem::align_of::<LL_LPTIM_InitTypeDef>(),
        4usize,
        concat!("Alignment of ", stringify!(LL_LPTIM_InitTypeDef))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ClockSource) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(LL_LPTIM_InitTypeDef),
            "::",
            stringify!(ClockSource)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Prescaler) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(LL_LPTIM_InitTypeDef),
            "::",
            stringify!(Prescaler)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Waveform) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(LL_LPTIM_InitTypeDef),
            "::",
            stringify!(Waveform)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Polarity) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(LL_LPTIM_InitTypeDef),
            "::",
            stringify!(Polarity)
        )
    );
}
extern "C" {
    #[doc = " @defgroup LPTIM_LL_EF_Init Initialisation and deinitialisation functions\n @{"]
    pub fn LL_LPTIM_DeInit(LPTIMx: *mut LPTIM_TypeDef) -> ErrorStatus;
}
extern "C" {
    pub fn LL_LPTIM_Init(
        LPTIMx: *mut LPTIM_TypeDef,
        LPTIM_InitStruct: *mut LL_LPTIM_InitTypeDef,
    ) -> ErrorStatus;
}
pub const FuriHalPwmOutputId_FuriHalPwmOutputIdTim1PA7: FuriHalPwmOutputId = 0;
pub const FuriHalPwmOutputId_FuriHalPwmOutputIdLptim2PA4: FuriHalPwmOutputId = 1;
pub type FuriHalPwmOutputId = core::ffi::c_uchar;
extern "C" {
    #[doc = " Enable PWM channel and set parameters\n\n @param[in]  channel  PWM channel (FuriHalPwmOutputId)\n @param[in]  freq  Frequency in Hz\n @param[in]  duty  Duty cycle value in %"]
    pub fn furi_hal_pwm_start(channel: FuriHalPwmOutputId, freq: u32, duty: u8);
}
extern "C" {
    #[doc = " Disable PWM channel\n\n @param[in]  channel  PWM channel (FuriHalPwmOutputId)"]
    pub fn furi_hal_pwm_stop(channel: FuriHalPwmOutputId);
}
extern "C" {
    #[doc = " Set PWM channel parameters\n\n @param[in]  channel  PWM channel (FuriHalPwmOutputId)\n @param[in]  freq  Frequency in Hz\n @param[in]  duty  Duty cycle value in %"]
    pub fn furi_hal_pwm_set_params(channel: FuriHalPwmOutputId, freq: u32, duty: u8);
}
pub const CC1101State_CC1101StateIDLE: CC1101State = 0;
#[doc = " IDLE state"]
pub const CC1101State_CC1101StateRX: CC1101State = 1;
#[doc = " Receive mode"]
pub const CC1101State_CC1101StateTX: CC1101State = 2;
#[doc = " Transmit mode"]
pub const CC1101State_CC1101StateFSTXON: CC1101State = 3;
#[doc = " Fast TX ready"]
pub const CC1101State_CC1101StateCALIBRATE: CC1101State = 4;
#[doc = " Frequency synthesizer calibration is running"]
pub const CC1101State_CC1101StateSETTLING: CC1101State = 5;
#[doc = " PLL is settling"]
pub const CC1101State_CC1101StateRXFIFO_OVERFLOW: CC1101State = 6;
#[doc = " RX FIFO has overflowed. Read out any useful data, then flush the FIFO with SFRX"]
pub const CC1101State_CC1101StateTXFIFO_UNDERFLOW: CC1101State = 7;
pub type CC1101State = core::ffi::c_uchar;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct CC1101Status {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
#[test]
fn bindgen_test_layout_CC1101Status() {
    assert_eq!(
        ::core::mem::size_of::<CC1101Status>(),
        1usize,
        concat!("Size of: ", stringify!(CC1101Status))
    );
    assert_eq!(
        ::core::mem::align_of::<CC1101Status>(),
        1usize,
        concat!("Alignment of ", stringify!(CC1101Status))
    );
}
impl CC1101Status {
    #[inline]
    pub fn FIFO_BYTES_AVAILABLE(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_FIFO_BYTES_AVAILABLE(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn STATE(&self) -> CC1101State {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 3u8) as u8) }
    }
    #[inline]
    pub fn set_STATE(&mut self, val: CC1101State) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn CHIP_RDYn(&self) -> bool {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_CHIP_RDYn(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        FIFO_BYTES_AVAILABLE: u8,
        STATE: CC1101State,
        CHIP_RDYn: bool,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let FIFO_BYTES_AVAILABLE: u8 = unsafe { ::core::mem::transmute(FIFO_BYTES_AVAILABLE) };
            FIFO_BYTES_AVAILABLE as u64
        });
        __bindgen_bitfield_unit.set(4usize, 3u8, {
            let STATE: u8 = unsafe { ::core::mem::transmute(STATE) };
            STATE as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let CHIP_RDYn: u8 = unsafe { ::core::mem::transmute(CHIP_RDYn) };
            CHIP_RDYn as u64
        });
        __bindgen_bitfield_unit
    }
}
extern "C" {
    #[doc = " Strobe command to the device\n\n @param      handle  - pointer to FuriHalSpiHandle\n @param      strobe  - command to execute\n\n @return     device status"]
    pub fn cc1101_strobe(handle: *mut FuriHalSpiBusHandle, strobe: u8) -> CC1101Status;
}
extern "C" {
    #[doc = " Write device register\n\n @param      handle  - pointer to FuriHalSpiHandle\n @param      reg     - register\n @param      data    - data to write\n\n @return     device status"]
    pub fn cc1101_write_reg(handle: *mut FuriHalSpiBusHandle, reg: u8, data: u8) -> CC1101Status;
}
extern "C" {
    #[doc = " Read device register\n\n @param      handle  - pointer to FuriHalSpiHandle\n @param      reg     - register\n @param[out] data    - pointer to data\n\n @return     device status"]
    pub fn cc1101_read_reg(
        handle: *mut FuriHalSpiBusHandle,
        reg: u8,
        data: *mut u8,
    ) -> CC1101Status;
}
extern "C" {
    #[doc = " Reset\n\n @param      handle  - pointer to FuriHalSpiHandle"]
    pub fn cc1101_reset(handle: *mut FuriHalSpiBusHandle);
}
extern "C" {
    #[doc = " Get status\n\n @param      handle  - pointer to FuriHalSpiHandle\n\n @return     CC1101Status structure"]
    pub fn cc1101_get_status(handle: *mut FuriHalSpiBusHandle) -> CC1101Status;
}
extern "C" {
    #[doc = " Enable shutdown mode\n\n @param      handle  - pointer to FuriHalSpiHandle"]
    pub fn cc1101_shutdown(handle: *mut FuriHalSpiBusHandle);
}
extern "C" {
    #[doc = " Get raw RSSI value\n\n @param      handle  - pointer to FuriHalSpiHandle\n\n @return     rssi value"]
    pub fn cc1101_get_rssi(handle: *mut FuriHalSpiBusHandle) -> u8;
}
extern "C" {
    #[doc = " Calibrate oscillator\n\n @param      handle  - pointer to FuriHalSpiHandle"]
    pub fn cc1101_calibrate(handle: *mut FuriHalSpiBusHandle);
}
extern "C" {
    #[doc = " Switch to idle\n\n @param      handle  - pointer to FuriHalSpiHandle"]
    pub fn cc1101_switch_to_idle(handle: *mut FuriHalSpiBusHandle);
}
extern "C" {
    #[doc = " Switch to RX\n\n @param      handle  - pointer to FuriHalSpiHandle"]
    pub fn cc1101_switch_to_rx(handle: *mut FuriHalSpiBusHandle);
}
extern "C" {
    #[doc = " Switch to TX\n\n @param      handle  - pointer to FuriHalSpiHandle"]
    pub fn cc1101_switch_to_tx(handle: *mut FuriHalSpiBusHandle);
}
extern "C" {
    #[doc = " Flush RX FIFO\n\n @param      handle  - pointer to FuriHalSpiHandle"]
    pub fn cc1101_flush_rx(handle: *mut FuriHalSpiBusHandle);
}
extern "C" {
    #[doc = " Flush TX FIFO\n\n @param      handle  - pointer to FuriHalSpiHandle"]
    pub fn cc1101_flush_tx(handle: *mut FuriHalSpiBusHandle);
}
extern "C" {
    #[doc = " Set Frequency\n\n @param      handle  - pointer to FuriHalSpiHandle\n @param      value   - frequency in herz\n\n @return     real frequency that were synthesized"]
    pub fn cc1101_set_frequency(handle: *mut FuriHalSpiBusHandle, value: u32) -> u32;
}
extern "C" {
    #[doc = " Set Power Amplifier level table, ramp\n\n @param      handle  - pointer to FuriHalSpiHandle\n @param      value   - array of power level values"]
    pub fn cc1101_set_pa_table(handle: *mut FuriHalSpiBusHandle, value: *const u8);
}
extern "C" {
    #[doc = " Write FIFO\n\n @param      handle  - pointer to FuriHalSpiHandle\n @param      data    pointer to byte array\n @param      size    write bytes count\n\n @return     size, written bytes count"]
    pub fn cc1101_write_fifo(handle: *mut FuriHalSpiBusHandle, data: *const u8, size: u8) -> u8;
}
extern "C" {
    #[doc = " Read FIFO\n\n @param      handle  - pointer to FuriHalSpiHandle\n @param      data    pointer to byte array\n @param      size    bytes to read from fifo\n\n @return     size, read bytes count"]
    pub fn cc1101_read_fifo(handle: *mut FuriHalSpiBusHandle, data: *mut u8, size: *mut u8) -> u8;
}
#[doc = "\\brief Line Coding Structure"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct usb_cdc_line_coding {
    #[doc = "<\\brief Data terminal rate, in bits per second."]
    pub dwDTERate: u32,
    #[doc = "<\\brief Stop bits."]
    pub bCharFormat: u8,
    #[doc = "<\\brief Parity."]
    pub bParityType: u8,
    #[doc = "<\\brief Data bits (5,6,7,8 or 16)."]
    pub bDataBits: u8,
}
#[test]
fn bindgen_test_layout_usb_cdc_line_coding() {
    const UNINIT: ::core::mem::MaybeUninit<usb_cdc_line_coding> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<usb_cdc_line_coding>(),
        7usize,
        concat!("Size of: ", stringify!(usb_cdc_line_coding))
    );
    assert_eq!(
        ::core::mem::align_of::<usb_cdc_line_coding>(),
        1usize,
        concat!("Alignment of ", stringify!(usb_cdc_line_coding))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).dwDTERate) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_cdc_line_coding),
            "::",
            stringify!(dwDTERate)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bCharFormat) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_cdc_line_coding),
            "::",
            stringify!(bCharFormat)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bParityType) as usize - ptr as usize },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_cdc_line_coding),
            "::",
            stringify!(bParityType)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bDataBits) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_cdc_line_coding),
            "::",
            stringify!(bDataBits)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CdcCallbacks {
    pub tx_ep_callback:
        ::core::option::Option<unsafe extern "C" fn(context: *mut core::ffi::c_void)>,
    pub rx_ep_callback:
        ::core::option::Option<unsafe extern "C" fn(context: *mut core::ffi::c_void)>,
    pub state_callback:
        ::core::option::Option<unsafe extern "C" fn(context: *mut core::ffi::c_void, state: u8)>,
    pub ctrl_line_callback:
        ::core::option::Option<unsafe extern "C" fn(context: *mut core::ffi::c_void, state: u8)>,
    pub config_callback: ::core::option::Option<
        unsafe extern "C" fn(context: *mut core::ffi::c_void, config: *mut usb_cdc_line_coding),
    >,
}
#[test]
fn bindgen_test_layout_CdcCallbacks() {
    const UNINIT: ::core::mem::MaybeUninit<CdcCallbacks> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<CdcCallbacks>(),
        20usize,
        concat!("Size of: ", stringify!(CdcCallbacks))
    );
    assert_eq!(
        ::core::mem::align_of::<CdcCallbacks>(),
        4usize,
        concat!("Alignment of ", stringify!(CdcCallbacks))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tx_ep_callback) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CdcCallbacks),
            "::",
            stringify!(tx_ep_callback)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rx_ep_callback) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(CdcCallbacks),
            "::",
            stringify!(rx_ep_callback)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).state_callback) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CdcCallbacks),
            "::",
            stringify!(state_callback)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ctrl_line_callback) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(CdcCallbacks),
            "::",
            stringify!(ctrl_line_callback)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).config_callback) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CdcCallbacks),
            "::",
            stringify!(config_callback)
        )
    );
}
extern "C" {
    pub fn furi_hal_cdc_set_callbacks(
        if_num: u8,
        cb: *mut CdcCallbacks,
        context: *mut core::ffi::c_void,
    );
}
extern "C" {
    pub fn furi_hal_cdc_get_port_settings(if_num: u8) -> *mut usb_cdc_line_coding;
}
extern "C" {
    pub fn furi_hal_cdc_get_ctrl_line_state(if_num: u8) -> u8;
}
extern "C" {
    pub fn furi_hal_cdc_send(if_num: u8, buf: *mut u8, len: u16);
}
extern "C" {
    pub fn furi_hal_cdc_receive(if_num: u8, buf: *mut u8, max_len: u16) -> i32;
}
extern "C" {
    pub fn __errno() -> *mut core::ffi::c_int;
}
extern "C" {
    pub fn __clear_cache(arg1: *mut core::ffi::c_void, arg2: *mut core::ffi::c_void);
}
extern "C" {
    #[doc = " Start Hid Keyboard Profile"]
    pub fn furi_hal_bt_hid_start();
}
extern "C" {
    #[doc = " Stop Hid Keyboard Profile"]
    pub fn furi_hal_bt_hid_stop();
}
extern "C" {
    #[doc = " Press keyboard button\n\n @param button    button code from HID specification\n\n @return          true on success"]
    pub fn furi_hal_bt_hid_kb_press(button: u16) -> bool;
}
extern "C" {
    #[doc = " Release keyboard button\n\n @param button    button code from HID specification\n\n @return          true on success"]
    pub fn furi_hal_bt_hid_kb_release(button: u16) -> bool;
}
extern "C" {
    #[doc = " Release all keyboard buttons\n\n @return          true on success"]
    pub fn furi_hal_bt_hid_kb_release_all() -> bool;
}
extern "C" {
    #[doc = " Set mouse movement and send HID report\n\n @param      dx  x coordinate delta\n @param      dy  y coordinate delta"]
    pub fn furi_hal_bt_hid_mouse_move(dx: i8, dy: i8) -> bool;
}
extern "C" {
    #[doc = " Set mouse button to pressed state and send HID report\n\n @param      button  key code"]
    pub fn furi_hal_bt_hid_mouse_press(button: u8) -> bool;
}
extern "C" {
    #[doc = " Set mouse button to released state and send HID report\n\n @param      button  key code"]
    pub fn furi_hal_bt_hid_mouse_release(button: u8) -> bool;
}
extern "C" {
    #[doc = " Set mouse button to released state and send HID report\n\n @param      button  key code"]
    pub fn furi_hal_bt_hid_mouse_release_all() -> bool;
}
extern "C" {
    #[doc = " Set mouse wheel position and send HID report\n\n @param      delta  number of scroll steps"]
    pub fn furi_hal_bt_hid_mouse_scroll(delta: i8) -> bool;
}
extern "C" {
    #[doc = " Set the following consumer key to pressed state and send HID report\n\n @param      button  key code"]
    pub fn furi_hal_bt_hid_consumer_key_press(button: u16) -> bool;
}
extern "C" {
    #[doc = " Set the following consumer key to released state and send HID report\n\n @param      button  key code"]
    pub fn furi_hal_bt_hid_consumer_key_release(button: u16) -> bool;
}
extern "C" {
    #[doc = " Set consumer key to released state and send HID report\n\n @param      button  key code"]
    pub fn furi_hal_bt_hid_consumer_key_release_all() -> bool;
}
#[doc = "< New data obtained"]
pub const FuriHalInfraredTxGetDataState_FuriHalInfraredTxGetDataStateOk:
    FuriHalInfraredTxGetDataState = 0;
#[doc = "< New data obtained, and this is end of package"]
pub const FuriHalInfraredTxGetDataState_FuriHalInfraredTxGetDataStateDone:
    FuriHalInfraredTxGetDataState = 1;
#[doc = "< New data obtained, and this is end of package and no more data available"]
pub const FuriHalInfraredTxGetDataState_FuriHalInfraredTxGetDataStateLastDone:
    FuriHalInfraredTxGetDataState = 2;
pub type FuriHalInfraredTxGetDataState = core::ffi::c_uchar;
#[doc = " Callback type for providing data to INFRARED DMA TX system. It is called every tim"]
pub type FuriHalInfraredTxGetDataISRCallback = ::core::option::Option<
    unsafe extern "C" fn(
        context: *mut core::ffi::c_void,
        duration: *mut u32,
        level: *mut bool,
    ) -> FuriHalInfraredTxGetDataState,
>;
#[doc = " Callback type called every time signal is sent by DMA to Timer.\n\n Actually, it means there are 2 timings left to send for this signal, which is\n almost end. Don't use this callback to stop transmission, as far as there are\n next signal is charged for transmission by DMA."]
pub type FuriHalInfraredTxSignalSentISRCallback =
    ::core::option::Option<unsafe extern "C" fn(context: *mut core::ffi::c_void)>;
#[doc = " Signature of callback function for receiving continuous INFRARED rx signal.\n\n @param      ctx[in]       context to pass to callback\n @param      level[in]     level of input INFRARED rx signal\n @param      duration[in]  duration of continuous rx signal level in us"]
pub type FuriHalInfraredRxCaptureCallback = ::core::option::Option<
    unsafe extern "C" fn(ctx: *mut core::ffi::c_void, level: bool, duration: u32),
>;
#[doc = " Signature of callback function for reaching silence timeout on INFRARED port.\n\n @param      ctx[in]  context to pass to callback"]
pub type FuriHalInfraredRxTimeoutCallback =
    ::core::option::Option<unsafe extern "C" fn(ctx: *mut core::ffi::c_void)>;
extern "C" {
    #[doc = " Initialize INFRARED RX timer to receive interrupts.\n\n It provides interrupts for every RX-signal edge changing with its duration."]
    pub fn furi_hal_infrared_async_rx_start();
}
extern "C" {
    #[doc = " Deinitialize INFRARED RX interrupt."]
    pub fn furi_hal_infrared_async_rx_stop();
}
extern "C" {
    #[doc = " Setup hal for receiving silence timeout.\n\n Should be used with 'furi_hal_infrared_timeout_irq_set_callback()'.\n\n @param[in]  timeout_us  time to wait for silence on INFRARED port before\n                         generating IRQ."]
    pub fn furi_hal_infrared_async_rx_set_timeout(timeout_us: u32);
}
extern "C" {
    #[doc = " Setup callback for previously initialized INFRARED RX interrupt.\n\n @param[in]  callback  callback to call when RX signal edge changing occurs\n @param[in]  ctx       context for callback"]
    pub fn furi_hal_infrared_async_rx_set_capture_isr_callback(
        callback: FuriHalInfraredRxCaptureCallback,
        ctx: *mut core::ffi::c_void,
    );
}
extern "C" {
    #[doc = " Setup callback for reaching silence timeout on INFRARED port.\n\n Should setup hal with 'furi_hal_infrared_setup_rx_timeout_irq()' first.\n\n @param[in]  callback  callback for silence timeout\n @param[in]  ctx       context to pass to callback"]
    pub fn furi_hal_infrared_async_rx_set_timeout_isr_callback(
        callback: FuriHalInfraredRxTimeoutCallback,
        ctx: *mut core::ffi::c_void,
    );
}
extern "C" {
    #[doc = " Check if INFRARED is in use now.\n\n @return     true if INFRARED is busy, false otherwise."]
    pub fn furi_hal_infrared_is_busy() -> bool;
}
extern "C" {
    #[doc = " Set callback providing new data.\n\n This function has to be called before furi_hal_infrared_async_tx_start().\n\n @param[in]  callback  function to provide new data\n @param[in]  context   context for callback"]
    pub fn furi_hal_infrared_async_tx_set_data_isr_callback(
        callback: FuriHalInfraredTxGetDataISRCallback,
        context: *mut core::ffi::c_void,
    );
}
extern "C" {
    #[doc = " Start IR asynchronous transmission.\n\n It can be stopped by 2 reasons:\n 1. implicit call for furi_hal_infrared_async_tx_stop()\n 2. callback can provide FuriHalInfraredTxGetDataStateLastDone response which\n    means no more data available for transmission.\n\n Any func (furi_hal_infrared_async_tx_stop() or\n furi_hal_infrared_async_tx_wait_termination()) has to be called to wait end of\n transmission and free resources.\n\n @param[in]  freq        frequency for PWM\n @param[in]  duty_cycle  duty cycle for PWM"]
    pub fn furi_hal_infrared_async_tx_start(freq: u32, duty_cycle: f32);
}
extern "C" {
    #[doc = " Stop IR asynchronous transmission and free resources.\n\n Transmission will stop as soon as transmission reaches end of package\n (FuriHalInfraredTxGetDataStateDone or FuriHalInfraredTxGetDataStateLastDone)."]
    pub fn furi_hal_infrared_async_tx_stop();
}
extern "C" {
    #[doc = " Wait for end of IR asynchronous transmission and free resources.\n\n Transmission will stop as soon as transmission reaches end of transmission\n (FuriHalInfraredTxGetDataStateLastDone)."]
    pub fn furi_hal_infrared_async_tx_wait_termination();
}
extern "C" {
    #[doc = " Set callback for end of signal transmission\n\n @param[in]  callback  function to call when signal is sent\n @param[in]  context   context for callback"]
    pub fn furi_hal_infrared_async_tx_set_signal_sent_isr_callback(
        callback: FuriHalInfraredTxSignalSentISRCallback,
        context: *mut core::ffi::c_void,
    );
}
extern "C" {
    #[doc = " @brief Init memory pool manager"]
    pub fn furi_hal_memory_init();
}
extern "C" {
    #[doc = " @brief Allocate memory from separate memory pool. That memory can't be freed.\n\n @param size\n @return void*"]
    pub fn furi_hal_memory_alloc(size: usize) -> *mut core::ffi::c_void;
}
extern "C" {
    #[doc = " @brief Get free memory pool size\n\n @return size_t"]
    pub fn furi_hal_memory_get_free() -> usize;
}
extern "C" {
    #[doc = " @brief Get max free block size from memory pool\n\n @return size_t"]
    pub fn furi_hal_memory_max_pool_block() -> usize;
}
pub const FuriHalMpuRegion_FuriHalMpuRegionNULL: FuriHalMpuRegion = 0;
pub const FuriHalMpuRegion_FuriHalMpuRegionStack: FuriHalMpuRegion = 1;
pub const FuriHalMpuRegion_FuriHalMpuRegion2: FuriHalMpuRegion = 2;
pub const FuriHalMpuRegion_FuriHalMpuRegion3: FuriHalMpuRegion = 3;
pub const FuriHalMpuRegion_FuriHalMpuRegion4: FuriHalMpuRegion = 4;
pub const FuriHalMpuRegion_FuriHalMpuRegion5: FuriHalMpuRegion = 5;
pub const FuriHalMpuRegion_FuriHalMpuRegion6: FuriHalMpuRegion = 6;
pub const FuriHalMpuRegion_FuriHalMpuRegion7: FuriHalMpuRegion = 7;
pub type FuriHalMpuRegion = core::ffi::c_uchar;
pub const FuriHalMPURegionSize_FuriHalMPURegionSize32B: FuriHalMPURegionSize = 4;
pub const FuriHalMPURegionSize_FuriHalMPURegionSize64B: FuriHalMPURegionSize = 5;
pub const FuriHalMPURegionSize_FuriHalMPURegionSize128B: FuriHalMPURegionSize = 6;
pub const FuriHalMPURegionSize_FuriHalMPURegionSize256B: FuriHalMPURegionSize = 7;
pub const FuriHalMPURegionSize_FuriHalMPURegionSize512B: FuriHalMPURegionSize = 8;
pub const FuriHalMPURegionSize_FuriHalMPURegionSize1KB: FuriHalMPURegionSize = 9;
pub const FuriHalMPURegionSize_FuriHalMPURegionSize2KB: FuriHalMPURegionSize = 10;
pub const FuriHalMPURegionSize_FuriHalMPURegionSize4KB: FuriHalMPURegionSize = 11;
pub const FuriHalMPURegionSize_FuriHalMPURegionSize8KB: FuriHalMPURegionSize = 12;
pub const FuriHalMPURegionSize_FuriHalMPURegionSize16KB: FuriHalMPURegionSize = 13;
pub const FuriHalMPURegionSize_FuriHalMPURegionSize32KB: FuriHalMPURegionSize = 14;
pub const FuriHalMPURegionSize_FuriHalMPURegionSize64KB: FuriHalMPURegionSize = 15;
pub const FuriHalMPURegionSize_FuriHalMPURegionSize128KB: FuriHalMPURegionSize = 16;
pub const FuriHalMPURegionSize_FuriHalMPURegionSize256KB: FuriHalMPURegionSize = 17;
pub const FuriHalMPURegionSize_FuriHalMPURegionSize512KB: FuriHalMPURegionSize = 18;
pub const FuriHalMPURegionSize_FuriHalMPURegionSize1MB: FuriHalMPURegionSize = 19;
pub const FuriHalMPURegionSize_FuriHalMPURegionSize2MB: FuriHalMPURegionSize = 20;
pub const FuriHalMPURegionSize_FuriHalMPURegionSize4MB: FuriHalMPURegionSize = 21;
pub const FuriHalMPURegionSize_FuriHalMPURegionSize8MB: FuriHalMPURegionSize = 22;
pub const FuriHalMPURegionSize_FuriHalMPURegionSize16MB: FuriHalMPURegionSize = 23;
pub const FuriHalMPURegionSize_FuriHalMPURegionSize32MB: FuriHalMPURegionSize = 24;
pub const FuriHalMPURegionSize_FuriHalMPURegionSize64MB: FuriHalMPURegionSize = 25;
pub const FuriHalMPURegionSize_FuriHalMPURegionSize128MB: FuriHalMPURegionSize = 26;
pub const FuriHalMPURegionSize_FuriHalMPURegionSize256MB: FuriHalMPURegionSize = 27;
pub const FuriHalMPURegionSize_FuriHalMPURegionSize512MB: FuriHalMPURegionSize = 28;
pub const FuriHalMPURegionSize_FuriHalMPURegionSize1GB: FuriHalMPURegionSize = 29;
pub const FuriHalMPURegionSize_FuriHalMPURegionSize2GB: FuriHalMPURegionSize = 30;
pub const FuriHalMPURegionSize_FuriHalMPURegionSize4GB: FuriHalMPURegionSize = 31;
pub type FuriHalMPURegionSize = core::ffi::c_uchar;
extern "C" {
    #[doc = " @brief Enable memory protection unit"]
    pub fn furi_hal_mpu_enable();
}
extern "C" {
    #[doc = " @brief Disable memory protection unit"]
    pub fn furi_hal_mpu_disable();
}
extern "C" {
    pub fn furi_hal_mpu_protect_no_access(
        region: FuriHalMpuRegion,
        address: u32,
        size: FuriHalMPURegionSize,
    );
}
extern "C" {
    pub fn furi_hal_mpu_protect_read_only(
        region: FuriHalMpuRegion,
        address: u32,
        size: FuriHalMPURegionSize,
    );
}
extern "C" {
    pub fn furi_hal_mpu_protect_disable(region: FuriHalMpuRegion);
}
pub const HidU2fEvent_HidU2fDisconnected: HidU2fEvent = 0;
pub const HidU2fEvent_HidU2fConnected: HidU2fEvent = 1;
pub const HidU2fEvent_HidU2fRequest: HidU2fEvent = 2;
pub type HidU2fEvent = core::ffi::c_uchar;
pub type HidU2fCallback =
    ::core::option::Option<unsafe extern "C" fn(ev: HidU2fEvent, context: *mut core::ffi::c_void)>;
extern "C" {
    #[doc = " Get HID U2F connection state\n\n @return      true / false"]
    pub fn furi_hal_hid_u2f_is_connected() -> bool;
}
extern "C" {
    #[doc = " Set HID U2F event callback\n\n @param      cb  callback\n @param      ctx  callback context"]
    pub fn furi_hal_hid_u2f_set_callback(cb: HidU2fCallback, ctx: *mut core::ffi::c_void);
}
extern "C" {
    #[doc = " Get received U2F HID packet\n"]
    pub fn furi_hal_hid_u2f_get_request(data: *mut u8) -> u32;
}
extern "C" {
    #[doc = " Send U2F HID response packet\n\n @param      data  response data\n @param      len  packet length"]
    pub fn furi_hal_hid_u2f_send_response(data: *mut u8, len: u8);
}
#[doc = " @brief  Structure definition of some features of COMP instance."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LL_COMP_InitTypeDef {
    #[doc = "< Set comparator operating mode to adjust power and speed.\nThis parameter can be a value of @ref COMP_LL_EC_POWERMODE\n\nThis feature can be modified afterwards using unitary function @ref LL_COMP_SetPowerMode()."]
    pub PowerMode: u32,
    #[doc = "< Set comparator input plus (non-inverting input).\nThis parameter can be a value of @ref COMP_LL_EC_INPUT_PLUS\n\nThis feature can be modified afterwards using unitary function @ref LL_COMP_SetInputPlus()."]
    pub InputPlus: u32,
    #[doc = "< Set comparator input minus (inverting input).\nThis parameter can be a value of @ref COMP_LL_EC_INPUT_MINUS\n\nThis feature can be modified afterwards using unitary function @ref LL_COMP_SetInputMinus()."]
    pub InputMinus: u32,
    #[doc = "< Set comparator hysteresis mode of the input minus.\nThis parameter can be a value of @ref COMP_LL_EC_INPUT_HYSTERESIS\n\nThis feature can be modified afterwards using unitary function @ref LL_COMP_SetInputHysteresis()."]
    pub InputHysteresis: u32,
    #[doc = "< Set comparator output polarity.\nThis parameter can be a value of @ref COMP_LL_EC_OUTPUT_POLARITY\n\nThis feature can be modified afterwards using unitary function @ref LL_COMP_SetOutputPolarity()."]
    pub OutputPolarity: u32,
    #[doc = "< Set comparator blanking source.\nThis parameter can be a value of @ref COMP_LL_EC_OUTPUT_BLANKING_SOURCE\n\nThis feature can be modified afterwards using unitary function @ref LL_COMP_SetOutputBlankingSource()."]
    pub OutputBlankingSource: u32,
}
#[test]
fn bindgen_test_layout_LL_COMP_InitTypeDef() {
    const UNINIT: ::core::mem::MaybeUninit<LL_COMP_InitTypeDef> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<LL_COMP_InitTypeDef>(),
        24usize,
        concat!("Size of: ", stringify!(LL_COMP_InitTypeDef))
    );
    assert_eq!(
        ::core::mem::align_of::<LL_COMP_InitTypeDef>(),
        4usize,
        concat!("Alignment of ", stringify!(LL_COMP_InitTypeDef))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).PowerMode) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(LL_COMP_InitTypeDef),
            "::",
            stringify!(PowerMode)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).InputPlus) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(LL_COMP_InitTypeDef),
            "::",
            stringify!(InputPlus)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).InputMinus) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(LL_COMP_InitTypeDef),
            "::",
            stringify!(InputMinus)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).InputHysteresis) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(LL_COMP_InitTypeDef),
            "::",
            stringify!(InputHysteresis)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).OutputPolarity) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(LL_COMP_InitTypeDef),
            "::",
            stringify!(OutputPolarity)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).OutputBlankingSource) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(LL_COMP_InitTypeDef),
            "::",
            stringify!(OutputBlankingSource)
        )
    );
}
extern "C" {
    pub fn LL_COMP_Init(
        COMPx: *mut COMP_TypeDef,
        COMP_InitStruct: *mut LL_COMP_InitTypeDef,
    ) -> ErrorStatus;
}
#[doc = " @defgroup DMA_LL_ES_INIT DMA Exported Init structure\n @{"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LL_DMA_InitTypeDef {
    #[doc = "< Specifies the peripheral base address for DMA transfer\nor as Source base address in case of memory to memory transfer direction.\n\nThis parameter must be a value between Min_Data = 0 and Max_Data = 0xFFFFFFFF."]
    pub PeriphOrM2MSrcAddress: u32,
    #[doc = "< Specifies the memory base address for DMA transfer\nor as Destination base address in case of memory to memory transfer direction.\n\nThis parameter must be a value between Min_Data = 0 and Max_Data = 0xFFFFFFFF."]
    pub MemoryOrM2MDstAddress: u32,
    #[doc = "< Specifies if the data will be transferred from memory to peripheral,\nfrom memory to memory or from peripheral to memory.\nThis parameter can be a value of @ref DMA_LL_EC_DIRECTION\n\nThis feature can be modified afterwards using unitary function @ref LL_DMA_SetDataTransferDirection()."]
    pub Direction: u32,
    #[doc = "< Specifies the normal or circular operation mode.\nThis parameter can be a value of @ref DMA_LL_EC_MODE\n@note: The circular buffer mode cannot be used if the memory to memory\ndata transfer direction is configured on the selected Channel\n\nThis feature can be modified afterwards using unitary function @ref LL_DMA_SetMode()."]
    pub Mode: u32,
    #[doc = "< Specifies whether the Peripheral address or Source address in case of memory to memory transfer direction\nis incremented or not.\nThis parameter can be a value of @ref DMA_LL_EC_PERIPH\n\nThis feature can be modified afterwards using unitary function @ref LL_DMA_SetPeriphIncMode()."]
    pub PeriphOrM2MSrcIncMode: u32,
    #[doc = "< Specifies whether the Memory address or Destination address in case of memory to memory transfer direction\nis incremented or not.\nThis parameter can be a value of @ref DMA_LL_EC_MEMORY\n\nThis feature can be modified afterwards using unitary function @ref LL_DMA_SetMemoryIncMode()."]
    pub MemoryOrM2MDstIncMode: u32,
    #[doc = "< Specifies the Peripheral data size alignment or Source data size alignment (byte, half word, word)\nin case of memory to memory transfer direction.\nThis parameter can be a value of @ref DMA_LL_EC_PDATAALIGN\n\nThis feature can be modified afterwards using unitary function @ref LL_DMA_SetPeriphSize()."]
    pub PeriphOrM2MSrcDataSize: u32,
    #[doc = "< Specifies the Memory data size alignment or Destination data size alignment (byte, half word, word)\nin case of memory to memory transfer direction.\nThis parameter can be a value of @ref DMA_LL_EC_MDATAALIGN\n\nThis feature can be modified afterwards using unitary function @ref LL_DMA_SetMemorySize()."]
    pub MemoryOrM2MDstDataSize: u32,
    #[doc = "< Specifies the number of data to transfer, in data unit.\nThe data unit is equal to the source buffer configuration set in PeripheralSize\nor MemorySize parameters depending in the transfer direction.\nThis parameter must be a value between Min_Data = 0 and Max_Data = 0x0000FFFF\n\nThis feature can be modified afterwards using unitary function @ref LL_DMA_SetDataLength()."]
    pub NbData: u32,
    #[doc = "< Specifies the peripheral request.\nThis parameter can be a value of @ref DMAMUX_LL_EC_REQUEST\n\nThis feature can be modified afterwards using unitary function @ref LL_DMA_SetPeriphRequest()."]
    pub PeriphRequest: u32,
    #[doc = "< Specifies the channel priority level.\nThis parameter can be a value of @ref DMA_LL_EC_PRIORITY\n\nThis feature can be modified afterwards using unitary function @ref LL_DMA_SetChannelPriorityLevel()."]
    pub Priority: u32,
}
#[test]
fn bindgen_test_layout_LL_DMA_InitTypeDef() {
    const UNINIT: ::core::mem::MaybeUninit<LL_DMA_InitTypeDef> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<LL_DMA_InitTypeDef>(),
        44usize,
        concat!("Size of: ", stringify!(LL_DMA_InitTypeDef))
    );
    assert_eq!(
        ::core::mem::align_of::<LL_DMA_InitTypeDef>(),
        4usize,
        concat!("Alignment of ", stringify!(LL_DMA_InitTypeDef))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).PeriphOrM2MSrcAddress) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(LL_DMA_InitTypeDef),
            "::",
            stringify!(PeriphOrM2MSrcAddress)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).MemoryOrM2MDstAddress) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(LL_DMA_InitTypeDef),
            "::",
            stringify!(MemoryOrM2MDstAddress)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Direction) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(LL_DMA_InitTypeDef),
            "::",
            stringify!(Direction)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Mode) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(LL_DMA_InitTypeDef),
            "::",
            stringify!(Mode)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).PeriphOrM2MSrcIncMode) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(LL_DMA_InitTypeDef),
            "::",
            stringify!(PeriphOrM2MSrcIncMode)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).MemoryOrM2MDstIncMode) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(LL_DMA_InitTypeDef),
            "::",
            stringify!(MemoryOrM2MDstIncMode)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).PeriphOrM2MSrcDataSize) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(LL_DMA_InitTypeDef),
            "::",
            stringify!(PeriphOrM2MSrcDataSize)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).MemoryOrM2MDstDataSize) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(LL_DMA_InitTypeDef),
            "::",
            stringify!(MemoryOrM2MDstDataSize)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).NbData) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(LL_DMA_InitTypeDef),
            "::",
            stringify!(NbData)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).PeriphRequest) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(LL_DMA_InitTypeDef),
            "::",
            stringify!(PeriphRequest)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Priority) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(LL_DMA_InitTypeDef),
            "::",
            stringify!(Priority)
        )
    );
}
extern "C" {
    #[doc = " @defgroup DMA_LL_EF_Init Initialization and de-initialization functions\n @{"]
    pub fn LL_DMA_Init(
        DMAx: *mut DMA_TypeDef,
        Channel: u32,
        DMA_InitStruct: *mut LL_DMA_InitTypeDef,
    ) -> ErrorStatus;
}
extern "C" {
    pub fn LL_DMA_DeInit(DMAx: *mut DMA_TypeDef, Channel: u32) -> ErrorStatus;
}
#[doc = " @brief LL LPUART Init Structure definition"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LL_LPUART_InitTypeDef {
    #[doc = "< Specifies the Prescaler to compute the communication baud rate.\nThis parameter can be a value of @ref LPUART_LL_EC_PRESCALER.\n\nThis feature can be modified afterwards using unitary\nfunction @ref LL_LPUART_SetPrescaler()."]
    pub PrescalerValue: u32,
    #[doc = "< This field defines expected LPUART communication baud rate.\n\nThis feature can be modified afterwards using unitary\nfunction @ref LL_LPUART_SetBaudRate()."]
    pub BaudRate: u32,
    #[doc = "< Specifies the number of data bits transmitted or received in a frame.\nThis parameter can be a value of @ref LPUART_LL_EC_DATAWIDTH.\n\nThis feature can be modified afterwards using unitary\nfunction @ref LL_LPUART_SetDataWidth()."]
    pub DataWidth: u32,
    #[doc = "< Specifies the number of stop bits transmitted.\nThis parameter can be a value of @ref LPUART_LL_EC_STOPBITS.\n\nThis feature can be modified afterwards using unitary\nfunction @ref LL_LPUART_SetStopBitsLength()."]
    pub StopBits: u32,
    #[doc = "< Specifies the parity mode.\nThis parameter can be a value of @ref LPUART_LL_EC_PARITY.\n\nThis feature can be modified afterwards using unitary\nfunction @ref LL_LPUART_SetParity()."]
    pub Parity: u32,
    #[doc = "< Specifies whether the Receive and/or Transmit mode is enabled or disabled.\nThis parameter can be a value of @ref LPUART_LL_EC_DIRECTION.\n\nThis feature can be modified afterwards using unitary\nfunction @ref LL_LPUART_SetTransferDirection()."]
    pub TransferDirection: u32,
    #[doc = "< Specifies whether the hardware flow control mode is enabled or disabled.\nThis parameter can be a value of @ref LPUART_LL_EC_HWCONTROL.\n\nThis feature can be modified afterwards using unitary\nfunction @ref LL_LPUART_SetHWFlowCtrl()."]
    pub HardwareFlowControl: u32,
}
#[test]
fn bindgen_test_layout_LL_LPUART_InitTypeDef() {
    const UNINIT: ::core::mem::MaybeUninit<LL_LPUART_InitTypeDef> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<LL_LPUART_InitTypeDef>(),
        28usize,
        concat!("Size of: ", stringify!(LL_LPUART_InitTypeDef))
    );
    assert_eq!(
        ::core::mem::align_of::<LL_LPUART_InitTypeDef>(),
        4usize,
        concat!("Alignment of ", stringify!(LL_LPUART_InitTypeDef))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).PrescalerValue) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(LL_LPUART_InitTypeDef),
            "::",
            stringify!(PrescalerValue)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).BaudRate) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(LL_LPUART_InitTypeDef),
            "::",
            stringify!(BaudRate)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).DataWidth) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(LL_LPUART_InitTypeDef),
            "::",
            stringify!(DataWidth)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).StopBits) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(LL_LPUART_InitTypeDef),
            "::",
            stringify!(StopBits)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Parity) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(LL_LPUART_InitTypeDef),
            "::",
            stringify!(Parity)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).TransferDirection) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(LL_LPUART_InitTypeDef),
            "::",
            stringify!(TransferDirection)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).HardwareFlowControl) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(LL_LPUART_InitTypeDef),
            "::",
            stringify!(HardwareFlowControl)
        )
    );
}
extern "C" {
    pub fn LL_LPUART_Init(
        LPUARTx: *mut USART_TypeDef,
        LPUART_InitStruct: *mut LL_LPUART_InitTypeDef,
    ) -> ErrorStatus;
}
#[doc = " @brief  RTC Init structures definition"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LL_RTC_InitTypeDef {
    #[doc = "< Specifies the RTC Hours Format.\nThis parameter can be a value of @ref RTC_LL_EC_HOURFORMAT\n\nThis feature can be modified afterwards using unitary function\n@ref LL_RTC_SetHourFormat()."]
    pub HourFormat: u32,
    #[doc = "< Specifies the RTC Asynchronous Predivider value.\nThis parameter must be a number between Min_Data = 0x00 and Max_Data = 0x7F\n\nThis feature can be modified afterwards using unitary function\n@ref LL_RTC_SetAsynchPrescaler()."]
    pub AsynchPrescaler: u32,
    #[doc = "< Specifies the RTC Synchronous Predivider value.\nThis parameter must be a number between Min_Data = 0x00 and Max_Data = 0x7FFF\n\nThis feature can be modified afterwards using unitary function\n@ref LL_RTC_SetSynchPrescaler()."]
    pub SynchPrescaler: u32,
}
#[test]
fn bindgen_test_layout_LL_RTC_InitTypeDef() {
    const UNINIT: ::core::mem::MaybeUninit<LL_RTC_InitTypeDef> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<LL_RTC_InitTypeDef>(),
        12usize,
        concat!("Size of: ", stringify!(LL_RTC_InitTypeDef))
    );
    assert_eq!(
        ::core::mem::align_of::<LL_RTC_InitTypeDef>(),
        4usize,
        concat!("Alignment of ", stringify!(LL_RTC_InitTypeDef))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).HourFormat) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(LL_RTC_InitTypeDef),
            "::",
            stringify!(HourFormat)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).AsynchPrescaler) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(LL_RTC_InitTypeDef),
            "::",
            stringify!(AsynchPrescaler)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).SynchPrescaler) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(LL_RTC_InitTypeDef),
            "::",
            stringify!(SynchPrescaler)
        )
    );
}
extern "C" {
    pub fn LL_RTC_Init(
        RTCx: *mut RTC_TypeDef,
        RTC_InitStruct: *mut LL_RTC_InitTypeDef,
    ) -> ErrorStatus;
}
extern "C" {
    pub fn LL_RTC_EnterInitMode(RTCx: *mut RTC_TypeDef) -> ErrorStatus;
}
#[doc = " @brief LL USART Init Structure definition"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LL_USART_InitTypeDef {
    #[doc = "< Specifies the Prescaler to compute the communication baud rate.\nThis parameter can be a value of @ref USART_LL_EC_PRESCALER.\n\nThis feature can be modified afterwards using unitary\nfunction @ref LL_USART_SetPrescaler()."]
    pub PrescalerValue: u32,
    #[doc = "< This field defines expected Usart communication baud rate.\n\nThis feature can be modified afterwards using unitary\nfunction @ref LL_USART_SetBaudRate()."]
    pub BaudRate: u32,
    #[doc = "< Specifies the number of data bits transmitted or received in a frame.\nThis parameter can be a value of @ref USART_LL_EC_DATAWIDTH.\n\nThis feature can be modified afterwards using unitary\nfunction @ref LL_USART_SetDataWidth()."]
    pub DataWidth: u32,
    #[doc = "< Specifies the number of stop bits transmitted.\nThis parameter can be a value of @ref USART_LL_EC_STOPBITS.\n\nThis feature can be modified afterwards using unitary\nfunction @ref LL_USART_SetStopBitsLength()."]
    pub StopBits: u32,
    #[doc = "< Specifies the parity mode.\nThis parameter can be a value of @ref USART_LL_EC_PARITY.\n\nThis feature can be modified afterwards using unitary\nfunction @ref LL_USART_SetParity()."]
    pub Parity: u32,
    #[doc = "< Specifies whether the Receive and/or Transmit mode is enabled or disabled.\nThis parameter can be a value of @ref USART_LL_EC_DIRECTION.\n\nThis feature can be modified afterwards using unitary\nfunction @ref LL_USART_SetTransferDirection()."]
    pub TransferDirection: u32,
    #[doc = "< Specifies whether the hardware flow control mode is enabled or disabled.\nThis parameter can be a value of @ref USART_LL_EC_HWCONTROL.\n\nThis feature can be modified afterwards using unitary\nfunction @ref LL_USART_SetHWFlowCtrl()."]
    pub HardwareFlowControl: u32,
    #[doc = "< Specifies whether USART oversampling mode is 16 or 8.\nThis parameter can be a value of @ref USART_LL_EC_OVERSAMPLING.\n\nThis feature can be modified afterwards using unitary\nfunction @ref LL_USART_SetOverSampling()."]
    pub OverSampling: u32,
}
#[test]
fn bindgen_test_layout_LL_USART_InitTypeDef() {
    const UNINIT: ::core::mem::MaybeUninit<LL_USART_InitTypeDef> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<LL_USART_InitTypeDef>(),
        32usize,
        concat!("Size of: ", stringify!(LL_USART_InitTypeDef))
    );
    assert_eq!(
        ::core::mem::align_of::<LL_USART_InitTypeDef>(),
        4usize,
        concat!("Alignment of ", stringify!(LL_USART_InitTypeDef))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).PrescalerValue) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(LL_USART_InitTypeDef),
            "::",
            stringify!(PrescalerValue)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).BaudRate) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(LL_USART_InitTypeDef),
            "::",
            stringify!(BaudRate)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).DataWidth) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(LL_USART_InitTypeDef),
            "::",
            stringify!(DataWidth)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).StopBits) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(LL_USART_InitTypeDef),
            "::",
            stringify!(StopBits)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Parity) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(LL_USART_InitTypeDef),
            "::",
            stringify!(Parity)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).TransferDirection) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(LL_USART_InitTypeDef),
            "::",
            stringify!(TransferDirection)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).HardwareFlowControl) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(LL_USART_InitTypeDef),
            "::",
            stringify!(HardwareFlowControl)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).OverSampling) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(LL_USART_InitTypeDef),
            "::",
            stringify!(OverSampling)
        )
    );
}
extern "C" {
    pub fn LL_USART_Init(
        USARTx: *mut USART_TypeDef,
        USART_InitStruct: *mut LL_USART_InitTypeDef,
    ) -> ErrorStatus;
}
extern "C" {
    #[doc = " @defgroup UTILS_EF_SYSTEM SYSTEM\n @{"]
    pub fn LL_SetSystemCoreClock(HCLKFrequency: u32);
}
pub type Elf32_Addr = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ElfApiInterface {
    pub api_version_major: u16,
    pub api_version_minor: u16,
    pub resolver_callback: ::core::option::Option<
        unsafe extern "C" fn(name: *const core::ffi::c_char, address: *mut Elf32_Addr) -> bool,
    >,
}
#[test]
fn bindgen_test_layout_ElfApiInterface() {
    const UNINIT: ::core::mem::MaybeUninit<ElfApiInterface> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<ElfApiInterface>(),
        8usize,
        concat!("Size of: ", stringify!(ElfApiInterface))
    );
    assert_eq!(
        ::core::mem::align_of::<ElfApiInterface>(),
        4usize,
        concat!("Alignment of ", stringify!(ElfApiInterface))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).api_version_major) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ElfApiInterface),
            "::",
            stringify!(api_version_major)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).api_version_minor) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(ElfApiInterface),
            "::",
            stringify!(api_version_minor)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).resolver_callback) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ElfApiInterface),
            "::",
            stringify!(resolver_callback)
        )
    );
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct FlipperApplicationManifestBase {
    pub manifest_magic: u32,
    pub manifest_version: u32,
    pub api_version: FlipperApplicationManifestBase__bindgen_ty_1,
    pub hardware_target_id: u16,
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub union FlipperApplicationManifestBase__bindgen_ty_1 {
    pub __bindgen_anon_1: FlipperApplicationManifestBase__bindgen_ty_1__bindgen_ty_1,
    pub version: u32,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct FlipperApplicationManifestBase__bindgen_ty_1__bindgen_ty_1 {
    pub minor: u16,
    pub major: u16,
}
#[test]
fn bindgen_test_layout_FlipperApplicationManifestBase__bindgen_ty_1__bindgen_ty_1() {
    const UNINIT: ::core::mem::MaybeUninit<
        FlipperApplicationManifestBase__bindgen_ty_1__bindgen_ty_1,
    > = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<FlipperApplicationManifestBase__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(FlipperApplicationManifestBase__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<FlipperApplicationManifestBase__bindgen_ty_1__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(FlipperApplicationManifestBase__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).minor) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FlipperApplicationManifestBase__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(minor)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).major) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(FlipperApplicationManifestBase__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(major)
        )
    );
}
#[test]
fn bindgen_test_layout_FlipperApplicationManifestBase__bindgen_ty_1() {
    const UNINIT: ::core::mem::MaybeUninit<FlipperApplicationManifestBase__bindgen_ty_1> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<FlipperApplicationManifestBase__bindgen_ty_1>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(FlipperApplicationManifestBase__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<FlipperApplicationManifestBase__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(FlipperApplicationManifestBase__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FlipperApplicationManifestBase__bindgen_ty_1),
            "::",
            stringify!(version)
        )
    );
}
#[test]
fn bindgen_test_layout_FlipperApplicationManifestBase() {
    const UNINIT: ::core::mem::MaybeUninit<FlipperApplicationManifestBase> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<FlipperApplicationManifestBase>(),
        14usize,
        concat!("Size of: ", stringify!(FlipperApplicationManifestBase))
    );
    assert_eq!(
        ::core::mem::align_of::<FlipperApplicationManifestBase>(),
        1usize,
        concat!("Alignment of ", stringify!(FlipperApplicationManifestBase))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).manifest_magic) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FlipperApplicationManifestBase),
            "::",
            stringify!(manifest_magic)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).manifest_version) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(FlipperApplicationManifestBase),
            "::",
            stringify!(manifest_version)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).api_version) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(FlipperApplicationManifestBase),
            "::",
            stringify!(api_version)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).hardware_target_id) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(FlipperApplicationManifestBase),
            "::",
            stringify!(hardware_target_id)
        )
    );
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct FlipperApplicationManifestV1 {
    pub base: FlipperApplicationManifestBase,
    pub stack_size: u16,
    pub app_version: u32,
    pub name: [core::ffi::c_char; 32usize],
    pub has_icon: core::ffi::c_char,
    pub icon: [core::ffi::c_char; 32usize],
}
#[test]
fn bindgen_test_layout_FlipperApplicationManifestV1() {
    const UNINIT: ::core::mem::MaybeUninit<FlipperApplicationManifestV1> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<FlipperApplicationManifestV1>(),
        85usize,
        concat!("Size of: ", stringify!(FlipperApplicationManifestV1))
    );
    assert_eq!(
        ::core::mem::align_of::<FlipperApplicationManifestV1>(),
        1usize,
        concat!("Alignment of ", stringify!(FlipperApplicationManifestV1))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).base) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FlipperApplicationManifestV1),
            "::",
            stringify!(base)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).stack_size) as usize - ptr as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(FlipperApplicationManifestV1),
            "::",
            stringify!(stack_size)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).app_version) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(FlipperApplicationManifestV1),
            "::",
            stringify!(app_version)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(FlipperApplicationManifestV1),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).has_icon) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(FlipperApplicationManifestV1),
            "::",
            stringify!(has_icon)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).icon) as usize - ptr as usize },
        53usize,
        concat!(
            "Offset of field: ",
            stringify!(FlipperApplicationManifestV1),
            "::",
            stringify!(icon)
        )
    );
}
pub type FlipperApplicationManifest = FlipperApplicationManifestV1;
extern "C" {
    #[doc = " @brief Check if manifest is valid\n\n @param manifest\n @return bool"]
    pub fn flipper_application_manifest_is_valid(
        manifest: *const FlipperApplicationManifest,
    ) -> bool;
}
extern "C" {
    #[doc = " @brief Check if manifest is compatible with current ELF API interface\n\n @param manifest\n @param api_interface\n @return bool"]
    pub fn flipper_application_manifest_is_compatible(
        manifest: *const FlipperApplicationManifest,
        api_interface: *const ElfApiInterface,
    ) -> bool;
}
extern "C" {
    #[doc = " @brief Check if application is compatible with current hardware\n\n @param manifest\n @return bool"]
    pub fn flipper_application_manifest_is_target_compatible(
        manifest: *const FlipperApplicationManifest,
    ) -> bool;
}
pub const FlipperApplicationPreloadStatus_FlipperApplicationPreloadStatusSuccess:
    FlipperApplicationPreloadStatus = 0;
pub const FlipperApplicationPreloadStatus_FlipperApplicationPreloadStatusUnspecifiedError:
    FlipperApplicationPreloadStatus = 1;
pub const FlipperApplicationPreloadStatus_FlipperApplicationPreloadStatusInvalidFile:
    FlipperApplicationPreloadStatus = 2;
pub const FlipperApplicationPreloadStatus_FlipperApplicationPreloadStatusInvalidManifest:
    FlipperApplicationPreloadStatus = 3;
pub const FlipperApplicationPreloadStatus_FlipperApplicationPreloadStatusApiMismatch:
    FlipperApplicationPreloadStatus = 4;
pub const FlipperApplicationPreloadStatus_FlipperApplicationPreloadStatusTargetMismatch:
    FlipperApplicationPreloadStatus = 5;
pub type FlipperApplicationPreloadStatus = core::ffi::c_uchar;
pub const FlipperApplicationLoadStatus_FlipperApplicationLoadStatusSuccess:
    FlipperApplicationLoadStatus = 0;
pub const FlipperApplicationLoadStatus_FlipperApplicationLoadStatusUnspecifiedError:
    FlipperApplicationLoadStatus = 1;
pub const FlipperApplicationLoadStatus_FlipperApplicationLoadStatusNoFreeMemory:
    FlipperApplicationLoadStatus = 2;
pub const FlipperApplicationLoadStatus_FlipperApplicationLoadStatusMissingImports:
    FlipperApplicationLoadStatus = 3;
pub type FlipperApplicationLoadStatus = core::ffi::c_uchar;
extern "C" {
    #[doc = " @brief Get text description of load status\n @param status Status code\n @return String pointer to description"]
    pub fn flipper_application_load_status_to_string(
        status: FlipperApplicationLoadStatus,
    ) -> *const core::ffi::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FlipperApplication {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " @brief Initialize FlipperApplication object\n @param storage Storage instance\n @param api_interface ELF API interface to use for pre-loading and symbol resolving\n @return Application instance"]
    pub fn flipper_application_alloc(
        storage: *mut Storage,
        api_interface: *const ElfApiInterface,
    ) -> *mut FlipperApplication;
}
extern "C" {
    #[doc = " @brief Destroy FlipperApplication object\n @param app Application pointer"]
    pub fn flipper_application_free(app: *mut FlipperApplication);
}
extern "C" {
    #[doc = " @brief Validate elf file and load application metadata\n @param app Application pointer\n @return Preload result code"]
    pub fn flipper_application_preload(
        app: *mut FlipperApplication,
        path: *const core::ffi::c_char,
    ) -> FlipperApplicationPreloadStatus;
}
extern "C" {
    #[doc = " @brief Validate elf file and load application manifest\n @param app Application pointer\n @return Preload result code"]
    pub fn flipper_application_preload_manifest(
        app: *mut FlipperApplication,
        path: *const core::ffi::c_char,
    ) -> FlipperApplicationPreloadStatus;
}
extern "C" {
    #[doc = " @brief Get pointer to application manifest for preloaded application\n @param app Application pointer\n @return Pointer to application manifest"]
    pub fn flipper_application_get_manifest(
        app: *mut FlipperApplication,
    ) -> *const FlipperApplicationManifest;
}
extern "C" {
    #[doc = " @brief Load sections and process relocations for already pre-loaded application\n @param app Application pointer\n @return Load result code"]
    pub fn flipper_application_map_to_memory(
        app: *mut FlipperApplication,
    ) -> FlipperApplicationLoadStatus;
}
extern "C" {
    #[doc = " @brief Create application thread at entry point address, using app name and\n stack size from metadata. Returned thread isn't started yet.\n Can be only called once for application instance.\n @param app Applicaiton pointer\n @param args Object to pass to app's entry point\n @return Created thread"]
    pub fn flipper_application_spawn(
        app: *mut FlipperApplication,
        args: *mut core::ffi::c_void,
    ) -> *mut FuriThread;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FlipperFormat {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " Allocate FlipperFormat as string.\n @return FlipperFormat* pointer to a FlipperFormat instance"]
    pub fn flipper_format_string_alloc() -> *mut FlipperFormat;
}
extern "C" {
    #[doc = " Allocate FlipperFormat as file.\n @return FlipperFormat* pointer to a FlipperFormat instance"]
    pub fn flipper_format_file_alloc(storage: *mut Storage) -> *mut FlipperFormat;
}
extern "C" {
    #[doc = " Allocate FlipperFormat as file, buffered mode.\n @return FlipperFormat* pointer to a FlipperFormat instance"]
    pub fn flipper_format_buffered_file_alloc(storage: *mut Storage) -> *mut FlipperFormat;
}
extern "C" {
    #[doc = " Open existing file.\n Use only if FlipperFormat allocated as a file.\n @param flipper_format Pointer to a FlipperFormat instance\n @param path File path\n @return True on success"]
    pub fn flipper_format_file_open_existing(
        flipper_format: *mut FlipperFormat,
        path: *const core::ffi::c_char,
    ) -> bool;
}
extern "C" {
    #[doc = " Open existing file, buffered mode.\n Use only if FlipperFormat allocated as a file.\n @param flipper_format Pointer to a FlipperFormat instance\n @param path File path\n @return True on success"]
    pub fn flipper_format_buffered_file_open_existing(
        flipper_format: *mut FlipperFormat,
        path: *const core::ffi::c_char,
    ) -> bool;
}
extern "C" {
    #[doc = " Open existing file for writing and add values to the end of file.\n Use only if FlipperFormat allocated as a file.\n @param flipper_format Pointer to a FlipperFormat instance\n @param path File path\n @return True on success"]
    pub fn flipper_format_file_open_append(
        flipper_format: *mut FlipperFormat,
        path: *const core::ffi::c_char,
    ) -> bool;
}
extern "C" {
    #[doc = " Open file. Creates a new file, or deletes the contents of the file if it already exists.\n Use only if FlipperFormat allocated as a file.\n @param flipper_format Pointer to a FlipperFormat instance\n @param path File path\n @return True on success"]
    pub fn flipper_format_file_open_always(
        flipper_format: *mut FlipperFormat,
        path: *const core::ffi::c_char,
    ) -> bool;
}
extern "C" {
    #[doc = " Open file. Creates a new file, fails if file already exists.\n Use only if FlipperFormat allocated as a file.\n @param flipper_format Pointer to a FlipperFormat instance\n @param path File path\n @return True on success"]
    pub fn flipper_format_file_open_new(
        flipper_format: *mut FlipperFormat,
        path: *const core::ffi::c_char,
    ) -> bool;
}
extern "C" {
    #[doc = " Closes the file, use only if FlipperFormat allocated as a file.\n @param flipper_format\n @return true\n @return false"]
    pub fn flipper_format_file_close(flipper_format: *mut FlipperFormat) -> bool;
}
extern "C" {
    #[doc = " Closes the file, use only if FlipperFormat allocated as a buffered file.\n @param flipper_format\n @return true\n @return false"]
    pub fn flipper_format_buffered_file_close(flipper_format: *mut FlipperFormat) -> bool;
}
extern "C" {
    #[doc = " Free FlipperFormat.\n @param flipper_format Pointer to a FlipperFormat instance"]
    pub fn flipper_format_free(flipper_format: *mut FlipperFormat);
}
extern "C" {
    #[doc = " Set FlipperFormat mode.\n @param flipper_format Pointer to a FlipperFormat instance\n @param strict_mode True obligates not to skip valid fields. False by default."]
    pub fn flipper_format_set_strict_mode(flipper_format: *mut FlipperFormat, strict_mode: bool);
}
extern "C" {
    #[doc = " Rewind the RW pointer.\n @param flipper_format Pointer to a FlipperFormat instance\n @return True on success"]
    pub fn flipper_format_rewind(flipper_format: *mut FlipperFormat) -> bool;
}
extern "C" {
    #[doc = " Move the RW pointer at the end. Can be useful if you want to add some data after reading.\n @param flipper_format Pointer to a FlipperFormat instance\n @return True on success"]
    pub fn flipper_format_seek_to_end(flipper_format: *mut FlipperFormat) -> bool;
}
extern "C" {
    #[doc = " Check if the key exists.\n @param flipper_format Pointer to a FlipperFormat instance\n @param key Key\n @return true key exists\n @return false key is not exists"]
    pub fn flipper_format_key_exist(
        flipper_format: *mut FlipperFormat,
        key: *const core::ffi::c_char,
    ) -> bool;
}
extern "C" {
    #[doc = " Read the header (file type and version).\n @param flipper_format Pointer to a FlipperFormat instance\n @param filetype File type string\n @param version Version Value\n @return True on success"]
    pub fn flipper_format_read_header(
        flipper_format: *mut FlipperFormat,
        filetype: *mut FuriString,
        version: *mut u32,
    ) -> bool;
}
extern "C" {
    #[doc = " Write the header (file type and version).\n @param flipper_format Pointer to a FlipperFormat instance\n @param filetype File type string\n @param version Version Value\n @return True on success"]
    pub fn flipper_format_write_header(
        flipper_format: *mut FlipperFormat,
        filetype: *mut FuriString,
        version: u32,
    ) -> bool;
}
extern "C" {
    #[doc = " Write the header (file type and version). Plain C string version.\n @param flipper_format Pointer to a FlipperFormat instance\n @param filetype File type string\n @param version Version Value\n @return True on success"]
    pub fn flipper_format_write_header_cstr(
        flipper_format: *mut FlipperFormat,
        filetype: *const core::ffi::c_char,
        version: u32,
    ) -> bool;
}
extern "C" {
    #[doc = " Get the count of values by key\n @param flipper_format Pointer to a FlipperFormat instance\n @param key\n @param count\n @return bool"]
    pub fn flipper_format_get_value_count(
        flipper_format: *mut FlipperFormat,
        key: *const core::ffi::c_char,
        count: *mut u32,
    ) -> bool;
}
extern "C" {
    #[doc = " Read a string by key\n @param flipper_format Pointer to a FlipperFormat instance\n @param key Key\n @param data Value\n @return True on success"]
    pub fn flipper_format_read_string(
        flipper_format: *mut FlipperFormat,
        key: *const core::ffi::c_char,
        data: *mut FuriString,
    ) -> bool;
}
extern "C" {
    #[doc = " Write key and string\n @param flipper_format Pointer to a FlipperFormat instance\n @param key Key\n @param data Value\n @return True on success"]
    pub fn flipper_format_write_string(
        flipper_format: *mut FlipperFormat,
        key: *const core::ffi::c_char,
        data: *mut FuriString,
    ) -> bool;
}
extern "C" {
    #[doc = " Write key and string. Plain C string version.\n @param flipper_format Pointer to a FlipperFormat instance\n @param key Key\n @param data Value\n @return True on success"]
    pub fn flipper_format_write_string_cstr(
        flipper_format: *mut FlipperFormat,
        key: *const core::ffi::c_char,
        data: *const core::ffi::c_char,
    ) -> bool;
}
extern "C" {
    #[doc = " Read array of uint64 in hex format by key\n @param flipper_format Pointer to a FlipperFormat instance\n @param key Key\n @param data Value\n @param data_size Values count\n @return True on success"]
    pub fn flipper_format_read_hex_uint64(
        flipper_format: *mut FlipperFormat,
        key: *const core::ffi::c_char,
        data: *mut u64,
        data_size: u16,
    ) -> bool;
}
extern "C" {
    #[doc = " Write key and array of uint64 in hex format\n @param flipper_format Pointer to a FlipperFormat instance\n @param key Key\n @param data Value\n @param data_size Values count\n @return True on success"]
    pub fn flipper_format_write_hex_uint64(
        flipper_format: *mut FlipperFormat,
        key: *const core::ffi::c_char,
        data: *const u64,
        data_size: u16,
    ) -> bool;
}
extern "C" {
    #[doc = " Read array of uint32 by key\n @param flipper_format Pointer to a FlipperFormat instance\n @param key Key\n @param data Value\n @param data_size Values count\n @return True on success"]
    pub fn flipper_format_read_uint32(
        flipper_format: *mut FlipperFormat,
        key: *const core::ffi::c_char,
        data: *mut u32,
        data_size: u16,
    ) -> bool;
}
extern "C" {
    #[doc = " Write key and array of uint32\n @param flipper_format Pointer to a FlipperFormat instance\n @param key Key\n @param data Value\n @param data_size Values count\n @return True on success"]
    pub fn flipper_format_write_uint32(
        flipper_format: *mut FlipperFormat,
        key: *const core::ffi::c_char,
        data: *const u32,
        data_size: u16,
    ) -> bool;
}
extern "C" {
    #[doc = " Read array of int32 by key\n @param flipper_format Pointer to a FlipperFormat instance\n @param key Key\n @param data Value\n @param data_size Values count\n @return True on success"]
    pub fn flipper_format_read_int32(
        flipper_format: *mut FlipperFormat,
        key: *const core::ffi::c_char,
        data: *mut i32,
        data_size: u16,
    ) -> bool;
}
extern "C" {
    #[doc = " Write key and array of int32\n @param flipper_format Pointer to a FlipperFormat instance\n @param key Key\n @param data Value\n @param data_size Values count\n @return True on success"]
    pub fn flipper_format_write_int32(
        flipper_format: *mut FlipperFormat,
        key: *const core::ffi::c_char,
        data: *const i32,
        data_size: u16,
    ) -> bool;
}
extern "C" {
    #[doc = " Read array of bool by key\n @param flipper_format Pointer to a FlipperFormat instance\n @param key Key\n @param data Value\n @param data_size Values count\n @return True on success"]
    pub fn flipper_format_read_bool(
        flipper_format: *mut FlipperFormat,
        key: *const core::ffi::c_char,
        data: *mut bool,
        data_size: u16,
    ) -> bool;
}
extern "C" {
    #[doc = " Write key and array of bool\n @param flipper_format Pointer to a FlipperFormat instance\n @param key Key\n @param data Value\n @param data_size Values count\n @return True on success"]
    pub fn flipper_format_write_bool(
        flipper_format: *mut FlipperFormat,
        key: *const core::ffi::c_char,
        data: *const bool,
        data_size: u16,
    ) -> bool;
}
extern "C" {
    #[doc = " Read array of float by key\n @param flipper_format Pointer to a FlipperFormat instance\n @param key Key\n @param data Value\n @param data_size Values count\n @return True on success"]
    pub fn flipper_format_read_float(
        flipper_format: *mut FlipperFormat,
        key: *const core::ffi::c_char,
        data: *mut f32,
        data_size: u16,
    ) -> bool;
}
extern "C" {
    #[doc = " Write key and array of float\n @param flipper_format Pointer to a FlipperFormat instance\n @param key Key\n @param data Value\n @param data_size Values count\n @return True on success"]
    pub fn flipper_format_write_float(
        flipper_format: *mut FlipperFormat,
        key: *const core::ffi::c_char,
        data: *const f32,
        data_size: u16,
    ) -> bool;
}
extern "C" {
    #[doc = " Read array of hex-formatted bytes by key\n @param flipper_format Pointer to a FlipperFormat instance\n @param key Key\n @param data Value\n @param data_size Values count\n @return True on success"]
    pub fn flipper_format_read_hex(
        flipper_format: *mut FlipperFormat,
        key: *const core::ffi::c_char,
        data: *mut u8,
        data_size: u16,
    ) -> bool;
}
extern "C" {
    #[doc = " Write key and array of hex-formatted bytes\n @param flipper_format Pointer to a FlipperFormat instance\n @param key Key\n @param data Value\n @param data_size Values count\n @return True on success"]
    pub fn flipper_format_write_hex(
        flipper_format: *mut FlipperFormat,
        key: *const core::ffi::c_char,
        data: *const u8,
        data_size: u16,
    ) -> bool;
}
extern "C" {
    #[doc = " Write comment\n @param flipper_format Pointer to a FlipperFormat instance\n @param data Comment text\n @return True on success"]
    pub fn flipper_format_write_comment(
        flipper_format: *mut FlipperFormat,
        data: *mut FuriString,
    ) -> bool;
}
extern "C" {
    #[doc = " Write comment. Plain C string version.\n @param flipper_format Pointer to a FlipperFormat instance\n @param data Comment text\n @return True on success"]
    pub fn flipper_format_write_comment_cstr(
        flipper_format: *mut FlipperFormat,
        data: *const core::ffi::c_char,
    ) -> bool;
}
extern "C" {
    #[doc = " Removes the first matching key and its value. Sets the RW pointer to a position of deleted data.\n @param flipper_format Pointer to a FlipperFormat instance\n @param key Key\n @return True on success"]
    pub fn flipper_format_delete_key(
        flipper_format: *mut FlipperFormat,
        key: *const core::ffi::c_char,
    ) -> bool;
}
extern "C" {
    #[doc = " Updates the value of the first matching key to a string value. Sets the RW pointer to a position at the end of inserted data.\n @param flipper_format Pointer to a FlipperFormat instance\n @param key Key\n @param data Value\n @return True on success"]
    pub fn flipper_format_update_string(
        flipper_format: *mut FlipperFormat,
        key: *const core::ffi::c_char,
        data: *mut FuriString,
    ) -> bool;
}
extern "C" {
    #[doc = " Updates the value of the first matching key to a string value. Plain C version. Sets the RW pointer to a position at the end of inserted data.\n @param flipper_format Pointer to a FlipperFormat instance\n @param key Key\n @param data Value\n @return True on success"]
    pub fn flipper_format_update_string_cstr(
        flipper_format: *mut FlipperFormat,
        key: *const core::ffi::c_char,
        data: *const core::ffi::c_char,
    ) -> bool;
}
extern "C" {
    #[doc = " Updates the value of the first matching key to a uint32 array value. Sets the RW pointer to a position at the end of inserted data.\n @param flipper_format Pointer to a FlipperFormat instance\n @param key Key\n @param data Value\n @return True on success"]
    pub fn flipper_format_update_uint32(
        flipper_format: *mut FlipperFormat,
        key: *const core::ffi::c_char,
        data: *const u32,
        data_size: u16,
    ) -> bool;
}
extern "C" {
    #[doc = " Updates the value of the first matching key to a int32 array value. Sets the RW pointer to a position at the end of inserted data.\n @param flipper_format Pointer to a FlipperFormat instance\n @param key Key\n @param data Value\n @return True on success"]
    pub fn flipper_format_update_int32(
        flipper_format: *mut FlipperFormat,
        key: *const core::ffi::c_char,
        data: *const i32,
        data_size: u16,
    ) -> bool;
}
extern "C" {
    #[doc = " Updates the value of the first matching key to a bool array value. Sets the RW pointer to a position at the end of inserted data.\n @param flipper_format Pointer to a FlipperFormat instance\n @param key Key\n @param data Value\n @return True on success"]
    pub fn flipper_format_update_bool(
        flipper_format: *mut FlipperFormat,
        key: *const core::ffi::c_char,
        data: *const bool,
        data_size: u16,
    ) -> bool;
}
extern "C" {
    #[doc = " Updates the value of the first matching key to a float array value. Sets the RW pointer to a position at the end of inserted data.\n @param flipper_format Pointer to a FlipperFormat instance\n @param key Key\n @param data Value\n @return True on success"]
    pub fn flipper_format_update_float(
        flipper_format: *mut FlipperFormat,
        key: *const core::ffi::c_char,
        data: *const f32,
        data_size: u16,
    ) -> bool;
}
extern "C" {
    #[doc = " Updates the value of the first matching key to an array of hex-formatted bytes. Sets the RW pointer to a position at the end of inserted data.\n @param flipper_format Pointer to a FlipperFormat instance\n @param key Key\n @param data Value\n @return True on success"]
    pub fn flipper_format_update_hex(
        flipper_format: *mut FlipperFormat,
        key: *const core::ffi::c_char,
        data: *const u8,
        data_size: u16,
    ) -> bool;
}
extern "C" {
    #[doc = " Updates the value of the first matching key to a string value, or adds the key and value if the key did not exist.\n Sets the RW pointer to a position at the end of inserted data.\n @param flipper_format Pointer to a FlipperFormat instance\n @param key Key\n @param data Value\n @return True on success"]
    pub fn flipper_format_insert_or_update_string(
        flipper_format: *mut FlipperFormat,
        key: *const core::ffi::c_char,
        data: *mut FuriString,
    ) -> bool;
}
extern "C" {
    #[doc = " Updates the value of the first matching key to a string value, or adds the key and value if the key did not exist.\n Plain C version.\n Sets the RW pointer to a position at the end of inserted data.\n @param flipper_format Pointer to a FlipperFormat instance\n @param key Key\n @param data Value\n @return True on success"]
    pub fn flipper_format_insert_or_update_string_cstr(
        flipper_format: *mut FlipperFormat,
        key: *const core::ffi::c_char,
        data: *const core::ffi::c_char,
    ) -> bool;
}
extern "C" {
    #[doc = " Updates the value of the first matching key to a uint32 array value, or adds the key and value if the key did not exist.\n  Sets the RW pointer to a position at the end of inserted data.\n @param flipper_format Pointer to a FlipperFormat instance\n @param key Key\n @param data Value\n @return True on success"]
    pub fn flipper_format_insert_or_update_uint32(
        flipper_format: *mut FlipperFormat,
        key: *const core::ffi::c_char,
        data: *const u32,
        data_size: u16,
    ) -> bool;
}
extern "C" {
    #[doc = " Updates the value of the first matching key to a int32 array value, or adds the key and value if the key did not exist.\n Sets the RW pointer to a position at the end of inserted data.\n @param flipper_format Pointer to a FlipperFormat instance\n @param key Key\n @param data Value\n @return True on success"]
    pub fn flipper_format_insert_or_update_int32(
        flipper_format: *mut FlipperFormat,
        key: *const core::ffi::c_char,
        data: *const i32,
        data_size: u16,
    ) -> bool;
}
extern "C" {
    #[doc = " Updates the value of the first matching key to a bool array value, or adds the key and value if the key did not exist.\n Sets the RW pointer to a position at the end of inserted data.\n @param flipper_format Pointer to a FlipperFormat instance\n @param key Key\n @param data Value\n @return True on success"]
    pub fn flipper_format_insert_or_update_bool(
        flipper_format: *mut FlipperFormat,
        key: *const core::ffi::c_char,
        data: *const bool,
        data_size: u16,
    ) -> bool;
}
extern "C" {
    #[doc = " Updates the value of the first matching key to a float array value, or adds the key and value if the key did not exist.\n Sets the RW pointer to a position at the end of inserted data.\n @param flipper_format Pointer to a FlipperFormat instance\n @param key Key\n @param data Value\n @return True on success"]
    pub fn flipper_format_insert_or_update_float(
        flipper_format: *mut FlipperFormat,
        key: *const core::ffi::c_char,
        data: *const f32,
        data_size: u16,
    ) -> bool;
}
extern "C" {
    #[doc = " Updates the value of the first matching key to an array of hex-formatted bytes, or adds the key and value if the key did not exist.\nSets the RW pointer to a position at the end of inserted data.\n @param flipper_format Pointer to a FlipperFormat instance\n @param key Key\n @param data Value\n @return True on success"]
    pub fn flipper_format_insert_or_update_hex(
        flipper_format: *mut FlipperFormat,
        key: *const core::ffi::c_char,
        data: *const u8,
        data_size: u16,
    ) -> bool;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Stream {
    _unused: [u8; 0],
}
pub const StreamOffset_StreamOffsetFromCurrent: StreamOffset = 0;
pub const StreamOffset_StreamOffsetFromStart: StreamOffset = 1;
pub const StreamOffset_StreamOffsetFromEnd: StreamOffset = 2;
pub type StreamOffset = core::ffi::c_uchar;
pub const StreamDirection_StreamDirectionForward: StreamDirection = 0;
pub const StreamDirection_StreamDirectionBackward: StreamDirection = 1;
pub type StreamDirection = core::ffi::c_uchar;
pub type StreamWriteCB = ::core::option::Option<
    unsafe extern "C" fn(stream: *mut Stream, context: *const core::ffi::c_void) -> bool,
>;
extern "C" {
    #[doc = " Free Stream\n @param stream Stream instance"]
    pub fn stream_free(stream: *mut Stream);
}
extern "C" {
    #[doc = " Clean (empty) Stream\n @param stream Stream instance"]
    pub fn stream_clean(stream: *mut Stream);
}
extern "C" {
    #[doc = " Indicates that the RW pointer is at the end of the stream\n @param stream Stream instance\n @return true if RW pointer is at the end of the stream\n @return false if RW pointer is not at the end of the stream"]
    pub fn stream_eof(stream: *mut Stream) -> bool;
}
extern "C" {
    #[doc = " Moves the RW pointer.\n @param stream Stream instance\n @param offset how much to move the pointer\n @param offset_type starting from what\n @return true\n @return false"]
    pub fn stream_seek(stream: *mut Stream, offset: i32, offset_type: StreamOffset) -> bool;
}
extern "C" {
    #[doc = " Seek to next occurrence of the character\n\n @param      stream     Pointer to the stream instance\n @param[in]  c          The Character\n @param[in]  direction  The Direction\n\n @return     true on success"]
    pub fn stream_seek_to_char(
        stream: *mut Stream,
        c: core::ffi::c_char,
        direction: StreamDirection,
    ) -> bool;
}
extern "C" {
    #[doc = " Gets the value of the RW pointer\n @param stream Stream instance\n @return size_t value of the RW pointer"]
    pub fn stream_tell(stream: *mut Stream) -> usize;
}
extern "C" {
    #[doc = " Gets the size of the stream\n @param stream Stream instance\n @return size_t size of the stream"]
    pub fn stream_size(stream: *mut Stream) -> usize;
}
extern "C" {
    #[doc = " Write N bytes to the stream\n @param stream Stream instance\n @param data data to write\n @param size size of data to be written\n @return size_t how many bytes was written"]
    pub fn stream_write(stream: *mut Stream, data: *const u8, size: usize) -> usize;
}
extern "C" {
    #[doc = " Read N bytes from stream\n @param stream Stream instance\n @param data data to be read\n @param count size of data to be read\n @return size_t how many bytes was read"]
    pub fn stream_read(stream: *mut Stream, data: *mut u8, count: usize) -> usize;
}
extern "C" {
    #[doc = " Delete N chars from the stream and write data by calling write_callback(context)\n @param stream Stream instance\n @param delete_size size of data to be deleted\n @param write_callback write callback\n @param context write callback context\n @return true if the operation was successful\n @return false on error"]
    pub fn stream_delete_and_insert(
        stream: *mut Stream,
        delete_size: usize,
        write_callback: StreamWriteCB,
        context: *const core::ffi::c_void,
    ) -> bool;
}
extern "C" {
    #[doc = " Read line from a stream (supports LF and CRLF line endings)\n @param stream\n @param str_result\n @return true if line length is not zero\n @return false otherwise"]
    pub fn stream_read_line(stream: *mut Stream, str_result: *mut FuriString) -> bool;
}
extern "C" {
    #[doc = " Moves the RW pointer to the start\n @param stream Stream instance"]
    pub fn stream_rewind(stream: *mut Stream) -> bool;
}
extern "C" {
    #[doc = " Write char to the stream\n @param stream Stream instance\n @param c char value\n @return size_t how many bytes was written"]
    pub fn stream_write_char(stream: *mut Stream, c: core::ffi::c_char) -> usize;
}
extern "C" {
    #[doc = " Write string to the stream\n @param stream Stream instance\n @param string string value\n @return size_t how many bytes was written"]
    pub fn stream_write_string(stream: *mut Stream, string: *mut FuriString) -> usize;
}
extern "C" {
    #[doc = " Write const char* to the stream\n @param stream Stream instance\n @param string c-string value\n @return size_t how many bytes was written"]
    pub fn stream_write_cstring(stream: *mut Stream, string: *const core::ffi::c_char) -> usize;
}
extern "C" {
    #[doc = " Write formatted string to the stream\n @param stream Stream instance\n @param format\n @param ...\n @return size_t how many bytes was written"]
    pub fn stream_write_format(stream: *mut Stream, format: *const core::ffi::c_char, ...)
        -> usize;
}
extern "C" {
    #[doc = " Write formatted string to the stream, va_list version\n @param stream Stream instance\n @param format\n @param args\n @return size_t how many bytes was written"]
    pub fn stream_write_vaformat(
        stream: *mut Stream,
        format: *const core::ffi::c_char,
        args: va_list,
    ) -> usize;
}
extern "C" {
    #[doc = " Insert N chars to the stream, starting at the current pointer.\n Data will be inserted, not overwritten, so the stream will be increased in size.\n @param stream Stream instance\n @param data data to be inserted\n @param size size of data to be inserted\n @return true if the operation was successful\n @return false on error"]
    pub fn stream_insert(stream: *mut Stream, data: *const u8, size: usize) -> bool;
}
extern "C" {
    #[doc = " Insert char to the stream\n @param stream Stream instance\n @param c char value\n @return true if the operation was successful\n @return false on error"]
    pub fn stream_insert_char(stream: *mut Stream, c: core::ffi::c_char) -> bool;
}
extern "C" {
    #[doc = " Insert string to the stream\n @param stream Stream instance\n @param string string value\n @return true if the operation was successful\n @return false on error"]
    pub fn stream_insert_string(stream: *mut Stream, string: *mut FuriString) -> bool;
}
extern "C" {
    #[doc = " Insert const char* to the stream\n @param stream Stream instance\n @param string c-string value\n @return true if the operation was successful\n @return false on error"]
    pub fn stream_insert_cstring(stream: *mut Stream, string: *const core::ffi::c_char) -> bool;
}
extern "C" {
    #[doc = " Insert formatted string to the stream\n @param stream Stream instance\n @param format\n @param ...\n @return true if the operation was successful\n @return false on error"]
    pub fn stream_insert_format(stream: *mut Stream, format: *const core::ffi::c_char, ...)
        -> bool;
}
extern "C" {
    #[doc = " Insert formatted string to the stream, va_list version\n @param stream Stream instance\n @param format\n @param args\n @return true if the operation was successful\n @return false on error"]
    pub fn stream_insert_vaformat(
        stream: *mut Stream,
        format: *const core::ffi::c_char,
        args: va_list,
    ) -> bool;
}
extern "C" {
    #[doc = " Delete N chars from the stream and insert char to the stream\n @param stream Stream instance\n @param delete_size size of data to be deleted\n @param c char value\n @return true if the operation was successful\n @return false on error"]
    pub fn stream_delete_and_insert_char(
        stream: *mut Stream,
        delete_size: usize,
        c: core::ffi::c_char,
    ) -> bool;
}
extern "C" {
    #[doc = " Delete N chars from the stream and insert string to the stream\n @param stream Stream instance\n @param delete_size size of data to be deleted\n @param string string value\n @return true if the operation was successful\n @return false on error"]
    pub fn stream_delete_and_insert_string(
        stream: *mut Stream,
        delete_size: usize,
        string: *mut FuriString,
    ) -> bool;
}
extern "C" {
    #[doc = " Delete N chars from the stream and insert const char* to the stream\n @param stream Stream instance\n @param delete_size size of data to be deleted\n @param string c-string value\n @return true if the operation was successful\n @return false on error"]
    pub fn stream_delete_and_insert_cstring(
        stream: *mut Stream,
        delete_size: usize,
        string: *const core::ffi::c_char,
    ) -> bool;
}
extern "C" {
    #[doc = " Delete N chars from the stream and insert formatted string to the stream\n @param stream Stream instance\n @param delete_size size of data to be deleted\n @param format\n @param ...\n @return true if the operation was successful\n @return false on error"]
    pub fn stream_delete_and_insert_format(
        stream: *mut Stream,
        delete_size: usize,
        format: *const core::ffi::c_char,
        ...
    ) -> bool;
}
extern "C" {
    #[doc = " Delete N chars from the stream and insert formatted string to the stream, va_list version\n @param stream Stream instance\n @param delete_size size of data to be deleted\n @param format\n @param args\n @return true if the operation was successful\n @return false on error"]
    pub fn stream_delete_and_insert_vaformat(
        stream: *mut Stream,
        delete_size: usize,
        format: *const core::ffi::c_char,
        args: va_list,
    ) -> bool;
}
extern "C" {
    #[doc = " Remove N chars from the stream, starting at the current pointer.\n The size may be larger than stream size, the stream will be cleared from current RW pointer to the end.\n @param stream Stream instance\n @param size how many chars need to be deleted\n @return true if the operation was successful\n @return false on error"]
    pub fn stream_delete(stream: *mut Stream, size: usize) -> bool;
}
extern "C" {
    #[doc = " Copy data from one stream to another. Data will be copied from current RW pointer and to current RW pointer.\n @param stream_from\n @param stream_to\n @param size\n @return size_t"]
    pub fn stream_copy(stream_from: *mut Stream, stream_to: *mut Stream, size: usize) -> usize;
}
extern "C" {
    #[doc = " Copy data from one stream to another. Data will be copied from start of one stream and to start of other stream.\n @param stream_from\n @param stream_to\n @return size_t"]
    pub fn stream_copy_full(stream_from: *mut Stream, stream_to: *mut Stream) -> usize;
}
extern "C" {
    #[doc = " Splits one stream into two others. The original stream will remain untouched.\n @param stream\n @param stream_left\n @param stream_right\n @return true\n @return false"]
    pub fn stream_split(
        stream: *mut Stream,
        stream_left: *mut Stream,
        stream_right: *mut Stream,
    ) -> bool;
}
extern "C" {
    #[doc = " Loads data to the stream from a file. Data will be loaded to the current RW pointer. RW pointer will be moved to the end of the stream.\n @param stream Stream instance\n @param storage\n @param path\n @return size_t"]
    pub fn stream_load_from_file(
        stream: *mut Stream,
        storage: *mut Storage,
        path: *const core::ffi::c_char,
    ) -> usize;
}
extern "C" {
    #[doc = " Writes data from a stream to a file. Data will be saved starting from the current RW pointer. RW pointer will be moved to the end of the stream.\n @param stream Stream instance\n @param storage\n @param path\n @param mode\n @return size_t"]
    pub fn stream_save_to_file(
        stream: *mut Stream,
        storage: *mut Storage,
        path: *const core::ffi::c_char,
        mode: FS_OpenMode,
    ) -> usize;
}
extern "C" {
    #[doc = " Dump stream inner data (size, RW position, content)\n @param stream Stream instance"]
    pub fn stream_dump_data(stream: *mut Stream);
}
extern "C" {
    #[doc = " Returns the underlying stream instance.\n Use only if you know what you are doing.\n @param flipper_format\n @return Stream*"]
    pub fn flipper_format_get_raw_stream(flipper_format: *mut FlipperFormat) -> *mut Stream;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct InfraredDecoderHandler {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct InfraredEncoderHandler {
    _unused: [u8; 0],
}
pub const InfraredProtocol_InfraredProtocolUnknown: InfraredProtocol = -1;
pub const InfraredProtocol_InfraredProtocolNEC: InfraredProtocol = 0;
pub const InfraredProtocol_InfraredProtocolNECext: InfraredProtocol = 1;
pub const InfraredProtocol_InfraredProtocolNEC42: InfraredProtocol = 2;
pub const InfraredProtocol_InfraredProtocolNEC42ext: InfraredProtocol = 3;
pub const InfraredProtocol_InfraredProtocolSamsung32: InfraredProtocol = 4;
pub const InfraredProtocol_InfraredProtocolRC6: InfraredProtocol = 5;
pub const InfraredProtocol_InfraredProtocolRC5: InfraredProtocol = 6;
pub const InfraredProtocol_InfraredProtocolRC5X: InfraredProtocol = 7;
pub const InfraredProtocol_InfraredProtocolSIRC: InfraredProtocol = 8;
pub const InfraredProtocol_InfraredProtocolSIRC15: InfraredProtocol = 9;
pub const InfraredProtocol_InfraredProtocolSIRC20: InfraredProtocol = 10;
pub const InfraredProtocol_InfraredProtocolKaseikyo: InfraredProtocol = 11;
pub const InfraredProtocol_InfraredProtocolMAX: InfraredProtocol = 12;
pub type InfraredProtocol = core::ffi::c_schar;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct InfraredMessage {
    pub protocol: InfraredProtocol,
    pub address: u32,
    pub command: u32,
    pub repeat: bool,
}
#[test]
fn bindgen_test_layout_InfraredMessage() {
    const UNINIT: ::core::mem::MaybeUninit<InfraredMessage> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<InfraredMessage>(),
        16usize,
        concat!("Size of: ", stringify!(InfraredMessage))
    );
    assert_eq!(
        ::core::mem::align_of::<InfraredMessage>(),
        4usize,
        concat!("Alignment of ", stringify!(InfraredMessage))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).protocol) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(InfraredMessage),
            "::",
            stringify!(protocol)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).address) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(InfraredMessage),
            "::",
            stringify!(address)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).command) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(InfraredMessage),
            "::",
            stringify!(command)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).repeat) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(InfraredMessage),
            "::",
            stringify!(repeat)
        )
    );
}
pub const InfraredStatus_InfraredStatusError: InfraredStatus = 0;
pub const InfraredStatus_InfraredStatusOk: InfraredStatus = 1;
pub const InfraredStatus_InfraredStatusDone: InfraredStatus = 2;
pub const InfraredStatus_InfraredStatusReady: InfraredStatus = 3;
pub type InfraredStatus = core::ffi::c_uchar;
extern "C" {
    #[doc = " Initialize decoder.\n\n \\return      returns pointer to INFRARED decoder handler if success, otherwise - error."]
    pub fn infrared_alloc_decoder() -> *mut InfraredDecoderHandler;
}
extern "C" {
    #[doc = " Provide to decoder next timing.\n\n \\param[in]   handler     - handler to INFRARED decoders. Should be acquired with \\c infrared_alloc_decoder().\n \\param[in]   level       - high(true) or low(false) level of input signal to analyze.\n                          it should alternate every call, otherwise it is an error case,\n                          and decoder resets its state and start decoding from the start.\n \\param[in]   duration    - duration of steady high/low input signal.\n \\return      if message is ready, returns pointer to decoded message, returns NULL.\n              Note: ownership of returned ptr belongs to handler. So pointer is valid\n              up to next infrared_free_decoder(), infrared_reset_decoder(),\n              infrared_decode(), infrared_check_decoder_ready() calls."]
    pub fn infrared_decode(
        handler: *mut InfraredDecoderHandler,
        level: bool,
        duration: u32,
    ) -> *const InfraredMessage;
}
extern "C" {
    #[doc = " Check whether decoder is ready.\n Functionality is quite similar to infrared_decode(), but with no timing providing.\n Some protocols (e.g. Sony SIRC) has variable payload length, which means we\n can't recognize end of message right after receiving last bit. That's why\n application should call to infrared_check_decoder_ready() after some timeout to\n retrieve decoded message, if so.\n\n \\param[in]   handler     - handler to INFRARED decoders. Should be acquired with \\c infrared_alloc_decoder().\n \\return      if message is ready, returns pointer to decoded message, returns NULL.\n              Note: ownership of returned ptr belongs to handler. So pointer is valid\n              up to next infrared_free_decoder(), infrared_reset_decoder(),\n              infrared_decode(), infrared_check_decoder_ready() calls."]
    pub fn infrared_check_decoder_ready(
        handler: *mut InfraredDecoderHandler,
    ) -> *const InfraredMessage;
}
extern "C" {
    #[doc = " Deinitialize decoder and free allocated memory.\n\n \\param[in]   handler     - handler to INFRARED decoders. Should be acquired with \\c infrared_alloc_decoder()."]
    pub fn infrared_free_decoder(handler: *mut InfraredDecoderHandler);
}
extern "C" {
    #[doc = " Reset INFRARED decoder.\n\n \\param[in]   handler     - handler to INFRARED decoders. Should be acquired with \\c infrared_alloc_decoder()."]
    pub fn infrared_reset_decoder(handler: *mut InfraredDecoderHandler);
}
extern "C" {
    #[doc = " Get protocol name by protocol enum.\n\n \\param[in]   protocol    - protocol identifier.\n \\return      string to protocol name."]
    pub fn infrared_get_protocol_name(protocol: InfraredProtocol) -> *const core::ffi::c_char;
}
extern "C" {
    #[doc = " Get protocol enum by protocol name.\n\n \\param[in]   protocol_name   - string to protocol name.\n \\return      protocol identifier."]
    pub fn infrared_get_protocol_by_name(
        protocol_name: *const core::ffi::c_char,
    ) -> InfraredProtocol;
}
extern "C" {
    #[doc = " Get address length by protocol enum.\n\n \\param[in]   protocol    - protocol identifier.\n \\return      length of address in bits."]
    pub fn infrared_get_protocol_address_length(protocol: InfraredProtocol) -> u8;
}
extern "C" {
    #[doc = " Get command length by protocol enum.\n\n \\param[in]   protocol    - protocol identifier.\n \\return      length of command in bits."]
    pub fn infrared_get_protocol_command_length(protocol: InfraredProtocol) -> u8;
}
extern "C" {
    #[doc = " Checks whether protocol valid.\n\n \\param[in]   protocol    - protocol identifier.\n \\return      true if protocol is valid, false otherwise."]
    pub fn infrared_is_protocol_valid(protocol: InfraredProtocol) -> bool;
}
extern "C" {
    #[doc = " Allocate INFRARED encoder.\n\n \\return      encoder handler."]
    pub fn infrared_alloc_encoder() -> *mut InfraredEncoderHandler;
}
extern "C" {
    #[doc = " Free encoder handler previously allocated with \\c infrared_alloc_encoder().\n\n \\param[in]   handler     - handler to INFRARED encoder. Should be acquired with \\c infrared_alloc_encoder()."]
    pub fn infrared_free_encoder(handler: *mut InfraredEncoderHandler);
}
extern "C" {
    #[doc = " Encode previously set INFRARED message.\n Usage:\n  1) alloc with \\c infrared_alloc_encoder()\n  2) set message to encode with \\c infrared_reset_encoder()\n  3) call for \\c infrared_encode() to continuously get one at a time timings.\n  4) when \\c infrared_encode() returns InfraredStatusDone, it means new message is fully encoded.\n  5) to encode additional timings, just continue calling \\c infrared_encode().\n\n \\param[in]   handler     - handler to INFRARED encoder. Should be acquired with \\c infrared_alloc_encoder().\n \\param[out]  duration    - encoded timing.\n \\param[out]  level       - encoded level.\n\n \\return      status of encode operation."]
    pub fn infrared_encode(
        handler: *mut InfraredEncoderHandler,
        duration: *mut u32,
        level: *mut bool,
    ) -> InfraredStatus;
}
extern "C" {
    #[doc = " Reset INFRARED encoder and set new message to encode. If it's not called after receiveing\n InfraredStatusDone in \\c infrared_encode(), encoder will encode repeat messages\n till the end of time.\n\n \\param[in]   handler     - handler to INFRARED encoder. Should be acquired with \\c infrared_alloc_encoder().\n \\param[in]   message     - message to encode."]
    pub fn infrared_reset_encoder(
        handler: *mut InfraredEncoderHandler,
        message: *const InfraredMessage,
    );
}
extern "C" {
    #[doc = " Get PWM frequency value for selected protocol\n\n \\param[in]   protocol    - protocol to get from PWM frequency\n\n \\return      frequency"]
    pub fn infrared_get_protocol_frequency(protocol: InfraredProtocol) -> u32;
}
extern "C" {
    #[doc = " Get PWM duty cycle value for selected protocol\n\n \\param[in]   protocol    - protocol to get from PWM duty cycle\n\n \\return      duty cycle"]
    pub fn infrared_get_protocol_duty_cycle(protocol: InfraredProtocol) -> f32;
}
extern "C" {
    #[doc = " Get the minimum count of signal repeats for the selected protocol\n\n \\param[in]   protocol    - protocol to get the repeat count from\n\n \\return      repeat count"]
    pub fn infrared_get_protocol_min_repeat_count(protocol: InfraredProtocol) -> usize;
}
extern "C" {
    #[doc = " Send message over INFRARED.\n\n \\param[in]   message     - message to send.\n \\param[in]   times       - number of times message should be sent."]
    pub fn infrared_send(message: *const InfraredMessage, times: core::ffi::c_int);
}
extern "C" {
    #[doc = " Send raw data through infrared port.\n\n \\param[in]   timings - array of timings to send.\n \\param[in]   timings_cnt - timings array size.\n \\param[in]   start_from_mark - true if timings starts from mark,\n              otherwise from space"]
    pub fn infrared_send_raw(timings: *const u32, timings_cnt: u32, start_from_mark: bool);
}
extern "C" {
    #[doc = " Send raw data through infrared port, with additional settings.\n\n \\param[in]   timings - array of timings to send.\n \\param[in]   timings_cnt - timings array size.\n \\param[in]   start_from_mark - true if timings starts from mark,\n              otherwise from space\n \\param[in]   duty_cycle - duty cycle to generate on PWM\n \\param[in]   frequency - frequency to generate on PWM"]
    pub fn infrared_send_raw_ext(
        timings: *const u32,
        timings_cnt: u32,
        start_from_mark: bool,
        frequency: u32,
        duty_cycle: f32,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct InfraredWorker {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct InfraredWorkerSignal {
    _unused: [u8; 0],
}
pub const InfraredWorkerGetSignalResponse_InfraredWorkerGetSignalResponseNew:
    InfraredWorkerGetSignalResponse = 0;
#[doc = " Signal, provided by callback is new and encoder should be reseted"]
pub const InfraredWorkerGetSignalResponse_InfraredWorkerGetSignalResponseSame:
    InfraredWorkerGetSignalResponse = 1;
#[doc = " Signal, provided by callback is same. No encoder resetting."]
pub const InfraredWorkerGetSignalResponse_InfraredWorkerGetSignalResponseStop:
    InfraredWorkerGetSignalResponse = 2;
pub type InfraredWorkerGetSignalResponse = core::ffi::c_uchar;
#[doc = " Callback type for providing next signal to send. Should be used with\n infrared_worker_make_decoded_signal() or infrared_worker_make_raw_signal()"]
pub type InfraredWorkerGetSignalCallback = ::core::option::Option<
    unsafe extern "C" fn(
        context: *mut core::ffi::c_void,
        instance: *mut InfraredWorker,
    ) -> InfraredWorkerGetSignalResponse,
>;
#[doc = " Callback type for 'message is sent' event"]
pub type InfraredWorkerMessageSentCallback =
    ::core::option::Option<unsafe extern "C" fn(context: *mut core::ffi::c_void)>;
#[doc = " Callback type to call by InfraredWorker thread when new signal is received"]
pub type InfraredWorkerReceivedSignalCallback = ::core::option::Option<
    unsafe extern "C" fn(
        context: *mut core::ffi::c_void,
        received_signal: *mut InfraredWorkerSignal,
    ),
>;
extern "C" {
    #[doc = " Allocate InfraredWorker\n\n @return just created instance of InfraredWorker"]
    pub fn infrared_worker_alloc() -> *mut InfraredWorker;
}
extern "C" {
    #[doc = " Free InfraredWorker\n\n @param[in]   instance - InfraredWorker instance"]
    pub fn infrared_worker_free(instance: *mut InfraredWorker);
}
extern "C" {
    #[doc = " Start InfraredWorker thread, initialise furi_hal, prepare all work.\n\n @param[in]   instance - InfraredWorker instance"]
    pub fn infrared_worker_rx_start(instance: *mut InfraredWorker);
}
extern "C" {
    #[doc = " Stop InfraredWorker thread, deinitialize furi_hal.\n\n @param[in]   instance - InfraredWorker instance"]
    pub fn infrared_worker_rx_stop(instance: *mut InfraredWorker);
}
extern "C" {
    #[doc = " Set received data callback InfraredWorker\n\n @param[in]   instance - InfraredWorker instance\n @param[in]   context - context to pass to callbacks\n @param[in]   callback - InfraredWorkerReceivedSignalCallback callback"]
    pub fn infrared_worker_rx_set_received_signal_callback(
        instance: *mut InfraredWorker,
        callback: InfraredWorkerReceivedSignalCallback,
        context: *mut core::ffi::c_void,
    );
}
extern "C" {
    #[doc = " Enable blinking on receiving any signal on IR port.\n\n @param[in]   instance - instance of InfraredWorker\n @param[in]   enable - true if you want to enable blinking\n                       false otherwise"]
    pub fn infrared_worker_rx_enable_blink_on_receiving(
        instance: *mut InfraredWorker,
        enable: bool,
    );
}
extern "C" {
    #[doc = " Enable decoding of received infrared signals.\n\n @param[in]   instance - instance of InfraredWorker\n @param[in]   enable - true if you want to enable decoding\n                       false otherwise"]
    pub fn infrared_worker_rx_enable_signal_decoding(instance: *mut InfraredWorker, enable: bool);
}
extern "C" {
    #[doc = " Clarify is received signal either decoded or raw\n\n @param[in]   signal - received signal\n @return      true if signal is decoded, false if signal is raw"]
    pub fn infrared_worker_signal_is_decoded(signal: *const InfraredWorkerSignal) -> bool;
}
extern "C" {
    #[doc = " Start transmitting signal. Callback InfraredWorkerGetSignalCallback should be\n set before this function is called, as it calls for it to fill buffer before\n starting transmission.\n\n @param[in]   instance - InfraredWorker instance"]
    pub fn infrared_worker_tx_start(instance: *mut InfraredWorker);
}
extern "C" {
    #[doc = " Stop transmitting signal. Waits for end of current signal and stops transmission.\n\n @param[in]   instance - InfraredWorker instance"]
    pub fn infrared_worker_tx_stop(instance: *mut InfraredWorker);
}
extern "C" {
    #[doc = " Set callback for providing next signal to send\n\n @param[in]   instance - InfraredWorker instance\n @param[in]   context - context to pass to callbacks\n @param[in]   callback - InfraredWorkerGetSignalCallback callback"]
    pub fn infrared_worker_tx_set_get_signal_callback(
        instance: *mut InfraredWorker,
        callback: InfraredWorkerGetSignalCallback,
        context: *mut core::ffi::c_void,
    );
}
extern "C" {
    #[doc = " Set callback for end of signal transmitting\n\n @param[in]   instance - InfraredWorker instance\n @param[in]   context - context to pass to callbacks\n @param[in]   callback - InfraredWorkerMessageSentCallback callback"]
    pub fn infrared_worker_tx_set_signal_sent_callback(
        instance: *mut InfraredWorker,
        callback: InfraredWorkerMessageSentCallback,
        context: *mut core::ffi::c_void,
    );
}
extern "C" {
    #[doc = " Callback to pass to infrared_worker_tx_set_get_signal_callback() if signal\n is steady and will not be changed between infrared_worker start and stop.\n Before starting transmission, desired steady signal must be set with\n infrared_worker_make_decoded_signal() or infrared_worker_make_raw_signal().\n\n This function should not be implicitly called.\n\n @param[in]   context - context\n @param[out]  instance - InfraredWorker instance"]
    pub fn infrared_worker_tx_get_signal_steady_callback(
        context: *mut core::ffi::c_void,
        instance: *mut InfraredWorker,
    ) -> InfraredWorkerGetSignalResponse;
}
extern "C" {
    #[doc = " Acquire raw signal from interface struct 'InfraredWorkerSignal'.\n First, you have to ensure that signal is raw.\n\n @param[in]   signal - received signal\n @param[out]  timings - pointer to array of timings\n @param[out]  timings_cnt - pointer to amount of timings"]
    pub fn infrared_worker_get_raw_signal(
        signal: *const InfraredWorkerSignal,
        timings: *mut *const u32,
        timings_cnt: *mut usize,
    );
}
extern "C" {
    #[doc = " Acquire decoded message from interface struct 'InfraredWorkerSignal'.\n First, you have to ensure that signal is decoded.\n\n @param[in]   signal - received signal\n @return      decoded INFRARED message"]
    pub fn infrared_worker_get_decoded_signal(
        signal: *const InfraredWorkerSignal,
    ) -> *const InfraredMessage;
}
extern "C" {
    #[doc = " Set current decoded signal for InfraredWorker instance\n\n @param[out]  instance - InfraredWorker instance\n @param[in]   message - decoded signal"]
    pub fn infrared_worker_set_decoded_signal(
        instance: *mut InfraredWorker,
        message: *const InfraredMessage,
    );
}
extern "C" {
    #[doc = " Set current raw signal for InfraredWorker instance\n\n @param[out]  instance - InfraredWorker instance\n @param[in]   timings - array of raw timings\n @param[in]   timings_cnt - size of array of raw timings"]
    pub fn infrared_worker_set_raw_signal(
        instance: *mut InfraredWorker,
        timings: *const u32,
        timings_cnt: usize,
    );
}
pub type ProtocolAlloc = ::core::option::Option<unsafe extern "C" fn() -> *mut core::ffi::c_void>;
pub type ProtocolFree =
    ::core::option::Option<unsafe extern "C" fn(protocol: *mut core::ffi::c_void)>;
pub type ProtocolGetData =
    ::core::option::Option<unsafe extern "C" fn(protocol: *mut core::ffi::c_void) -> *mut u8>;
pub type ProtocolDecoderStart =
    ::core::option::Option<unsafe extern "C" fn(protocol: *mut core::ffi::c_void)>;
pub type ProtocolDecoderFeed = ::core::option::Option<
    unsafe extern "C" fn(protocol: *mut core::ffi::c_void, level: bool, duration: u32) -> bool,
>;
pub type ProtocolEncoderStart =
    ::core::option::Option<unsafe extern "C" fn(protocol: *mut core::ffi::c_void) -> bool>;
pub type ProtocolEncoderYield =
    ::core::option::Option<unsafe extern "C" fn(protocol: *mut core::ffi::c_void) -> LevelDuration>;
pub type ProtocolRenderData = ::core::option::Option<
    unsafe extern "C" fn(protocol: *mut core::ffi::c_void, result: *mut FuriString),
>;
pub type ProtocolWriteData = ::core::option::Option<
    unsafe extern "C" fn(protocol: *mut core::ffi::c_void, data: *mut core::ffi::c_void) -> bool,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ProtocolDecoder {
    pub start: ProtocolDecoderStart,
    pub feed: ProtocolDecoderFeed,
}
#[test]
fn bindgen_test_layout_ProtocolDecoder() {
    const UNINIT: ::core::mem::MaybeUninit<ProtocolDecoder> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<ProtocolDecoder>(),
        8usize,
        concat!("Size of: ", stringify!(ProtocolDecoder))
    );
    assert_eq!(
        ::core::mem::align_of::<ProtocolDecoder>(),
        4usize,
        concat!("Alignment of ", stringify!(ProtocolDecoder))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).start) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ProtocolDecoder),
            "::",
            stringify!(start)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).feed) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ProtocolDecoder),
            "::",
            stringify!(feed)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ProtocolEncoder {
    pub start: ProtocolEncoderStart,
    pub yield_: ProtocolEncoderYield,
}
#[test]
fn bindgen_test_layout_ProtocolEncoder() {
    const UNINIT: ::core::mem::MaybeUninit<ProtocolEncoder> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<ProtocolEncoder>(),
        8usize,
        concat!("Size of: ", stringify!(ProtocolEncoder))
    );
    assert_eq!(
        ::core::mem::align_of::<ProtocolEncoder>(),
        4usize,
        concat!("Alignment of ", stringify!(ProtocolEncoder))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).start) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ProtocolEncoder),
            "::",
            stringify!(start)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).yield_) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ProtocolEncoder),
            "::",
            stringify!(yield_)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ProtocolBase {
    pub data_size: usize,
    pub name: *const core::ffi::c_char,
    pub manufacturer: *const core::ffi::c_char,
    pub features: u32,
    pub validate_count: u8,
    pub alloc: ProtocolAlloc,
    pub free: ProtocolFree,
    pub get_data: ProtocolGetData,
    pub decoder: ProtocolDecoder,
    pub encoder: ProtocolEncoder,
    pub render_data: ProtocolRenderData,
    pub render_brief_data: ProtocolRenderData,
    pub write_data: ProtocolWriteData,
}
#[test]
fn bindgen_test_layout_ProtocolBase() {
    const UNINIT: ::core::mem::MaybeUninit<ProtocolBase> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<ProtocolBase>(),
        60usize,
        concat!("Size of: ", stringify!(ProtocolBase))
    );
    assert_eq!(
        ::core::mem::align_of::<ProtocolBase>(),
        4usize,
        concat!("Alignment of ", stringify!(ProtocolBase))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).data_size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ProtocolBase),
            "::",
            stringify!(data_size)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ProtocolBase),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).manufacturer) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ProtocolBase),
            "::",
            stringify!(manufacturer)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).features) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(ProtocolBase),
            "::",
            stringify!(features)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).validate_count) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ProtocolBase),
            "::",
            stringify!(validate_count)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).alloc) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(ProtocolBase),
            "::",
            stringify!(alloc)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).free) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ProtocolBase),
            "::",
            stringify!(free)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_data) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(ProtocolBase),
            "::",
            stringify!(get_data)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).decoder) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ProtocolBase),
            "::",
            stringify!(decoder)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).encoder) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(ProtocolBase),
            "::",
            stringify!(encoder)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).render_data) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(ProtocolBase),
            "::",
            stringify!(render_data)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).render_brief_data) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(ProtocolBase),
            "::",
            stringify!(render_brief_data)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).write_data) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(ProtocolBase),
            "::",
            stringify!(write_data)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ProtocolDict {
    _unused: [u8; 0],
}
pub type ProtocolId = i32;
extern "C" {
    pub fn protocol_dict_alloc(
        protocols: *mut *const ProtocolBase,
        protocol_count: usize,
    ) -> *mut ProtocolDict;
}
extern "C" {
    pub fn protocol_dict_free(dict: *mut ProtocolDict);
}
extern "C" {
    pub fn protocol_dict_set_data(
        dict: *mut ProtocolDict,
        protocol_index: usize,
        data: *const u8,
        data_size: usize,
    );
}
extern "C" {
    pub fn protocol_dict_get_data(
        dict: *mut ProtocolDict,
        protocol_index: usize,
        data: *mut u8,
        data_size: usize,
    );
}
extern "C" {
    pub fn protocol_dict_get_data_size(dict: *mut ProtocolDict, protocol_index: usize) -> usize;
}
extern "C" {
    pub fn protocol_dict_get_max_data_size(dict: *mut ProtocolDict) -> usize;
}
extern "C" {
    pub fn protocol_dict_get_name(
        dict: *mut ProtocolDict,
        protocol_index: usize,
    ) -> *const core::ffi::c_char;
}
extern "C" {
    pub fn protocol_dict_get_manufacturer(
        dict: *mut ProtocolDict,
        protocol_index: usize,
    ) -> *const core::ffi::c_char;
}
extern "C" {
    pub fn protocol_dict_decoders_start(dict: *mut ProtocolDict);
}
extern "C" {
    pub fn protocol_dict_get_features(dict: *mut ProtocolDict, protocol_index: usize) -> u32;
}
extern "C" {
    pub fn protocol_dict_decoders_feed(
        dict: *mut ProtocolDict,
        level: bool,
        duration: u32,
    ) -> ProtocolId;
}
extern "C" {
    pub fn protocol_dict_decoders_feed_by_feature(
        dict: *mut ProtocolDict,
        feature: u32,
        level: bool,
        duration: u32,
    ) -> ProtocolId;
}
extern "C" {
    pub fn protocol_dict_decoders_feed_by_id(
        dict: *mut ProtocolDict,
        protocol_index: usize,
        level: bool,
        duration: u32,
    ) -> ProtocolId;
}
extern "C" {
    pub fn protocol_dict_encoder_start(dict: *mut ProtocolDict, protocol_index: usize) -> bool;
}
extern "C" {
    pub fn protocol_dict_encoder_yield(
        dict: *mut ProtocolDict,
        protocol_index: usize,
    ) -> LevelDuration;
}
extern "C" {
    pub fn protocol_dict_render_data(
        dict: *mut ProtocolDict,
        result: *mut FuriString,
        protocol_index: usize,
    );
}
extern "C" {
    pub fn protocol_dict_render_brief_data(
        dict: *mut ProtocolDict,
        result: *mut FuriString,
        protocol_index: usize,
    );
}
extern "C" {
    pub fn protocol_dict_get_validate_count(dict: *mut ProtocolDict, protocol_index: usize) -> u32;
}
extern "C" {
    pub fn protocol_dict_get_protocol_by_name(
        dict: *mut ProtocolDict,
        name: *const core::ffi::c_char,
    ) -> ProtocolId;
}
extern "C" {
    pub fn protocol_dict_get_write_data(
        dict: *mut ProtocolDict,
        protocol_index: usize,
        data: *mut core::ffi::c_void,
    ) -> bool;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LFRFIDT5577 {
    pub block: [u32; 8usize],
    pub blocks_to_write: u32,
}
#[test]
fn bindgen_test_layout_LFRFIDT5577() {
    const UNINIT: ::core::mem::MaybeUninit<LFRFIDT5577> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<LFRFIDT5577>(),
        36usize,
        concat!("Size of: ", stringify!(LFRFIDT5577))
    );
    assert_eq!(
        ::core::mem::align_of::<LFRFIDT5577>(),
        4usize,
        concat!("Alignment of ", stringify!(LFRFIDT5577))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).block) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(LFRFIDT5577),
            "::",
            stringify!(block)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).blocks_to_write) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(LFRFIDT5577),
            "::",
            stringify!(blocks_to_write)
        )
    );
}
extern "C" {
    #[doc = " @brief Write T5577 tag data to tag\n\n @param data"]
    pub fn t5577_write(data: *mut LFRFIDT5577);
}
pub const LFRFIDProtocol_LFRFIDProtocolEM4100: LFRFIDProtocol = 0;
pub const LFRFIDProtocol_LFRFIDProtocolH10301: LFRFIDProtocol = 1;
pub const LFRFIDProtocol_LFRFIDProtocolIdteck: LFRFIDProtocol = 2;
pub const LFRFIDProtocol_LFRFIDProtocolIndala26: LFRFIDProtocol = 3;
pub const LFRFIDProtocol_LFRFIDProtocolIOProxXSF: LFRFIDProtocol = 4;
pub const LFRFIDProtocol_LFRFIDProtocolAwid: LFRFIDProtocol = 5;
pub const LFRFIDProtocol_LFRFIDProtocolFDXA: LFRFIDProtocol = 6;
pub const LFRFIDProtocol_LFRFIDProtocolFDXB: LFRFIDProtocol = 7;
pub const LFRFIDProtocol_LFRFIDProtocolHidGeneric: LFRFIDProtocol = 8;
pub const LFRFIDProtocol_LFRFIDProtocolHidExGeneric: LFRFIDProtocol = 9;
pub const LFRFIDProtocol_LFRFIDProtocolPyramid: LFRFIDProtocol = 10;
pub const LFRFIDProtocol_LFRFIDProtocolViking: LFRFIDProtocol = 11;
pub const LFRFIDProtocol_LFRFIDProtocolJablotron: LFRFIDProtocol = 12;
pub const LFRFIDProtocol_LFRFIDProtocolParadox: LFRFIDProtocol = 13;
pub const LFRFIDProtocol_LFRFIDProtocolPACStanley: LFRFIDProtocol = 14;
pub const LFRFIDProtocol_LFRFIDProtocolKeri: LFRFIDProtocol = 15;
pub const LFRFIDProtocol_LFRFIDProtocolGallagher: LFRFIDProtocol = 16;
pub const LFRFIDProtocol_LFRFIDProtocolMax: LFRFIDProtocol = 17;
pub type LFRFIDProtocol = core::ffi::c_uchar;
extern "C" {
    pub static mut lfrfid_protocols: [*const ProtocolBase; 0usize];
}
extern "C" {
    #[doc = " @brief Save protocol from dictionary to file\n\n @param dict\n @param protocol\n @param filename\n @return true\n @return false"]
    pub fn lfrfid_dict_file_save(
        dict: *mut ProtocolDict,
        protocol: ProtocolId,
        filename: *const core::ffi::c_char,
    ) -> bool;
}
extern "C" {
    #[doc = " @brief Load protocol from file to dictionary\n\n @param dict\n @param filename\n @return ProtocolId"]
    pub fn lfrfid_dict_file_load(
        dict: *mut ProtocolDict,
        filename: *const core::ffi::c_char,
    ) -> ProtocolId;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LFRFIDRawFile {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " @brief Allocate a new LFRFIDRawFile instance\n\n @param storage\n @return LFRFIDRawFile*"]
    pub fn lfrfid_raw_file_alloc(storage: *mut Storage) -> *mut LFRFIDRawFile;
}
extern "C" {
    #[doc = " @brief Free a LFRFIDRawFile instance\n\n @param file"]
    pub fn lfrfid_raw_file_free(file: *mut LFRFIDRawFile);
}
extern "C" {
    #[doc = " @brief Open RAW file for writing\n\n @param file\n @param file_path\n @return bool"]
    pub fn lfrfid_raw_file_open_write(
        file: *mut LFRFIDRawFile,
        file_path: *const core::ffi::c_char,
    ) -> bool;
}
extern "C" {
    #[doc = " @brief Open RAW file for reading\n @param file\n @param file_path\n @return bool"]
    pub fn lfrfid_raw_file_open_read(
        file: *mut LFRFIDRawFile,
        file_path: *const core::ffi::c_char,
    ) -> bool;
}
extern "C" {
    #[doc = " @brief Write RAW file header\n\n @param file\n @param frequency\n @param duty_cycle\n @param max_buffer_size\n @return bool"]
    pub fn lfrfid_raw_file_write_header(
        file: *mut LFRFIDRawFile,
        frequency: f32,
        duty_cycle: f32,
        max_buffer_size: u32,
    ) -> bool;
}
extern "C" {
    #[doc = " @brief Write data to RAW file\n\n @param file\n @param buffer_data\n @param buffer_size\n @return bool"]
    pub fn lfrfid_raw_file_write_buffer(
        file: *mut LFRFIDRawFile,
        buffer_data: *mut u8,
        buffer_size: usize,
    ) -> bool;
}
extern "C" {
    #[doc = " @brief Read RAW file header\n\n @param file\n @param frequency\n @param duty_cycle\n @return bool"]
    pub fn lfrfid_raw_file_read_header(
        file: *mut LFRFIDRawFile,
        frequency: *mut f32,
        duty_cycle: *mut f32,
    ) -> bool;
}
extern "C" {
    #[doc = " @brief Read varint-encoded pair from RAW file\n\n @param file\n @param duration\n @param pulse\n @param pass_end file was wrapped around, can be NULL\n @return bool"]
    pub fn lfrfid_raw_file_read_pair(
        file: *mut LFRFIDRawFile,
        duration: *mut u32,
        pulse: *mut u32,
        pass_end: *mut bool,
    ) -> bool;
}
pub const LFRFIDWorkerWriteResult_LFRFIDWorkerWriteOK: LFRFIDWorkerWriteResult = 0;
pub const LFRFIDWorkerWriteResult_LFRFIDWorkerWriteProtocolCannotBeWritten:
    LFRFIDWorkerWriteResult = 1;
pub const LFRFIDWorkerWriteResult_LFRFIDWorkerWriteFobCannotBeWritten: LFRFIDWorkerWriteResult = 2;
pub const LFRFIDWorkerWriteResult_LFRFIDWorkerWriteTooLongToWrite: LFRFIDWorkerWriteResult = 3;
pub type LFRFIDWorkerWriteResult = core::ffi::c_uchar;
pub const LFRFIDWorkerReadType_LFRFIDWorkerReadTypeAuto: LFRFIDWorkerReadType = 0;
pub const LFRFIDWorkerReadType_LFRFIDWorkerReadTypeASKOnly: LFRFIDWorkerReadType = 1;
pub const LFRFIDWorkerReadType_LFRFIDWorkerReadTypePSKOnly: LFRFIDWorkerReadType = 2;
pub type LFRFIDWorkerReadType = core::ffi::c_uchar;
pub const LFRFIDWorkerReadResult_LFRFIDWorkerReadSenseStart: LFRFIDWorkerReadResult = 0;
pub const LFRFIDWorkerReadResult_LFRFIDWorkerReadSenseEnd: LFRFIDWorkerReadResult = 1;
pub const LFRFIDWorkerReadResult_LFRFIDWorkerReadSenseCardStart: LFRFIDWorkerReadResult = 2;
pub const LFRFIDWorkerReadResult_LFRFIDWorkerReadSenseCardEnd: LFRFIDWorkerReadResult = 3;
pub const LFRFIDWorkerReadResult_LFRFIDWorkerReadStartASK: LFRFIDWorkerReadResult = 4;
pub const LFRFIDWorkerReadResult_LFRFIDWorkerReadStartPSK: LFRFIDWorkerReadResult = 5;
pub const LFRFIDWorkerReadResult_LFRFIDWorkerReadDone: LFRFIDWorkerReadResult = 6;
pub type LFRFIDWorkerReadResult = core::ffi::c_uchar;
pub const LFRFIDWorkerReadRawResult_LFRFIDWorkerReadRawFileError: LFRFIDWorkerReadRawResult = 0;
pub const LFRFIDWorkerReadRawResult_LFRFIDWorkerReadRawOverrun: LFRFIDWorkerReadRawResult = 1;
pub type LFRFIDWorkerReadRawResult = core::ffi::c_uchar;
pub const LFRFIDWorkerEmulateRawResult_LFRFIDWorkerEmulateRawFileError:
    LFRFIDWorkerEmulateRawResult = 0;
pub const LFRFIDWorkerEmulateRawResult_LFRFIDWorkerEmulateRawOverrun: LFRFIDWorkerEmulateRawResult =
    1;
pub type LFRFIDWorkerEmulateRawResult = core::ffi::c_uchar;
pub type LFRFIDWorkerReadCallback = ::core::option::Option<
    unsafe extern "C" fn(
        result: LFRFIDWorkerReadResult,
        protocol: ProtocolId,
        context: *mut core::ffi::c_void,
    ),
>;
pub type LFRFIDWorkerWriteCallback = ::core::option::Option<
    unsafe extern "C" fn(result: LFRFIDWorkerWriteResult, context: *mut core::ffi::c_void),
>;
pub type LFRFIDWorkerReadRawCallback = ::core::option::Option<
    unsafe extern "C" fn(result: LFRFIDWorkerReadRawResult, context: *mut core::ffi::c_void),
>;
pub type LFRFIDWorkerEmulateRawCallback = ::core::option::Option<
    unsafe extern "C" fn(result: LFRFIDWorkerEmulateRawResult, context: *mut core::ffi::c_void),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LFRFIDWorker {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " Allocate LF-RFID worker\n @return LFRFIDWorker*"]
    pub fn lfrfid_worker_alloc(dict: *mut ProtocolDict) -> *mut LFRFIDWorker;
}
extern "C" {
    #[doc = " Free LF-RFID worker\n @param worker"]
    pub fn lfrfid_worker_free(worker: *mut LFRFIDWorker);
}
extern "C" {
    #[doc = " Start LF-RFID worker thread\n @param worker"]
    pub fn lfrfid_worker_start_thread(worker: *mut LFRFIDWorker);
}
extern "C" {
    #[doc = " Stop LF-RFID worker thread\n @param worker"]
    pub fn lfrfid_worker_stop_thread(worker: *mut LFRFIDWorker);
}
extern "C" {
    #[doc = " @brief Start read mode\n\n @param worker\n @param type\n @param callback\n @param context"]
    pub fn lfrfid_worker_read_start(
        worker: *mut LFRFIDWorker,
        type_: LFRFIDWorkerReadType,
        callback: LFRFIDWorkerReadCallback,
        context: *mut core::ffi::c_void,
    );
}
extern "C" {
    #[doc = " @brief Start write mode\n\n @param worker\n @param protocol\n @param callback\n @param context"]
    pub fn lfrfid_worker_write_start(
        worker: *mut LFRFIDWorker,
        protocol: LFRFIDProtocol,
        callback: LFRFIDWorkerWriteCallback,
        context: *mut core::ffi::c_void,
    );
}
extern "C" {
    #[doc = " Start emulate mode\n @param worker"]
    pub fn lfrfid_worker_emulate_start(worker: *mut LFRFIDWorker, protocol: LFRFIDProtocol);
}
extern "C" {
    #[doc = " @brief Start raw read mode\n\n @param worker\n @param filename\n @param type\n @param callback\n @param context"]
    pub fn lfrfid_worker_read_raw_start(
        worker: *mut LFRFIDWorker,
        filename: *const core::ffi::c_char,
        type_: LFRFIDWorkerReadType,
        callback: LFRFIDWorkerReadRawCallback,
        context: *mut core::ffi::c_void,
    );
}
extern "C" {
    #[doc = " Emulate raw read mode\n @param worker\n @param filename\n @param callback\n @param context"]
    pub fn lfrfid_worker_emulate_raw_start(
        worker: *mut LFRFIDWorker,
        filename: *const core::ffi::c_char,
        callback: LFRFIDWorkerEmulateRawCallback,
        context: *mut core::ffi::c_void,
    );
}
extern "C" {
    #[doc = " Stop all modes\n @param worker"]
    pub fn lfrfid_worker_stop(worker: *mut LFRFIDWorker);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LFRFIDRawWorker {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " @brief Allocate a new LFRFIDRawWorker instance\n\n @return LFRFIDRawWorker*"]
    pub fn lfrfid_raw_worker_alloc() -> *mut LFRFIDRawWorker;
}
extern "C" {
    #[doc = " @brief Free a LFRFIDRawWorker instance\n\n @param worker LFRFIDRawWorker instance"]
    pub fn lfrfid_raw_worker_free(worker: *mut LFRFIDRawWorker);
}
extern "C" {
    #[doc = " @brief Start reading\n\n @param worker LFRFIDRawWorker instance\n @param file_path path where file will be saved\n @param frequency HW frequency\n @param duty_cycle HW duty cycle\n @param callback callback for read event\n @param context context for callback"]
    pub fn lfrfid_raw_worker_start_read(
        worker: *mut LFRFIDRawWorker,
        file_path: *const core::ffi::c_char,
        frequency: f32,
        duty_cycle: f32,
        callback: LFRFIDWorkerReadRawCallback,
        context: *mut core::ffi::c_void,
    );
}
extern "C" {
    #[doc = " @brief Start emulate\n\n @param worker LFRFIDRawWorker instance\n @param file_path path to file that will be emulated\n @param callback callback for emulate event\n @param context context for callback"]
    pub fn lfrfid_raw_worker_start_emulate(
        worker: *mut LFRFIDRawWorker,
        file_path: *const core::ffi::c_char,
        callback: LFRFIDWorkerEmulateRawCallback,
        context: *mut core::ffi::c_void,
    );
}
extern "C" {
    #[doc = " @brief Stop worker\n\n @param worker"]
    pub fn lfrfid_raw_worker_stop(worker: *mut LFRFIDRawWorker);
}
pub const BitLibParity_BitLibParityEven: BitLibParity = 0;
pub const BitLibParity_BitLibParityOdd: BitLibParity = 1;
pub const BitLibParity_BitLibParityAlways0: BitLibParity = 2;
pub const BitLibParity_BitLibParityAlways1: BitLibParity = 3;
pub type BitLibParity = core::ffi::c_uchar;
extern "C" {
    #[doc = " @brief Push a bit into a byte array.\n  @param data array to push bit into\n  @param data_size array size\n  @param bit bit to push"]
    pub fn bit_lib_push_bit(data: *mut u8, data_size: usize, bit: bool);
}
extern "C" {
    #[doc = " @brief Set a bit in a byte array.\n  @param data array to set bit in\n  @param position The position of the bit to set.\n  @param bit bit value to set"]
    pub fn bit_lib_set_bit(data: *mut u8, position: usize, bit: bool);
}
extern "C" {
    #[doc = " @brief Set the bit at the given position to the given value.\n @param data The data to set the bit in.\n @param position The position of the bit to set.\n @param byte The data to set the bit to.\n @param length The length of the data."]
    pub fn bit_lib_set_bits(data: *mut u8, position: usize, byte: u8, length: u8);
}
extern "C" {
    #[doc = " @brief Get the bit of a byte.\n @param data The byte to get the bits from.\n @param position The position of the bit.\n @return The bit."]
    pub fn bit_lib_get_bit(data: *const u8, position: usize) -> bool;
}
extern "C" {
    #[doc = " @brief Get the bits of a data, as uint8_t.\n @param data The data to get the bits from.\n @param position The position of the first bit.\n @param length The length of the bits.\n @return The bits."]
    pub fn bit_lib_get_bits(data: *const u8, position: usize, length: u8) -> u8;
}
extern "C" {
    #[doc = " @brief Get the bits of a data, as uint16_t.\n @param data The data to get the bits from.\n @param position The position of the first bit.\n @param length The length of the bits.\n @return The bits."]
    pub fn bit_lib_get_bits_16(data: *const u8, position: usize, length: u8) -> u16;
}
extern "C" {
    #[doc = " @brief Get the bits of a data, as uint32_t.\n @param data The data to get the bits from.\n @param position The position of the first bit.\n @param length The length of the bits.\n @return The bits."]
    pub fn bit_lib_get_bits_32(data: *const u8, position: usize, length: u8) -> u32;
}
extern "C" {
    #[doc = " @brief Test parity of given bits\n @param bits Bits to test parity of\n @param parity Parity to test against\n @return true if parity is correct, false otherwise"]
    pub fn bit_lib_test_parity_32(bits: u32, parity: BitLibParity) -> bool;
}
extern "C" {
    #[doc = " @brief Test parity of bit array, check parity for every parity_length block from start\n\n @param data Bit array\n @param position Start position\n @param length Bit count\n @param parity Parity to test against\n @param parity_length Parity block length\n @return true\n @return false"]
    pub fn bit_lib_test_parity(
        data: *const u8,
        position: usize,
        length: u8,
        parity: BitLibParity,
        parity_length: u8,
    ) -> bool;
}
extern "C" {
    #[doc = " @brief Add parity to bit array\n\n @param data Source bit array\n @param position Start position\n @param dest Destination bit array\n @param dest_position Destination position\n @param source_length Source bit count\n @param parity_length Parity block length\n @param parity Parity to test against\n @return size_t"]
    pub fn bit_lib_add_parity(
        data: *const u8,
        position: usize,
        dest: *mut u8,
        dest_position: usize,
        source_length: u8,
        parity_length: u8,
        parity: BitLibParity,
    ) -> usize;
}
extern "C" {
    #[doc = " @brief Remove bit every n in array and shift array left. Useful to remove parity.\n\n @param data Bit array\n @param position Start position\n @param length Bit count\n @param n every n bit will be removed\n @return size_t"]
    pub fn bit_lib_remove_bit_every_nth(data: *mut u8, position: usize, length: u8, n: u8)
        -> usize;
}
extern "C" {
    #[doc = " @brief Copy bits from source to destination.\n\n @param data destination array\n @param position position in destination array\n @param length length of bits to copy\n @param source source array\n @param source_position position in source array"]
    pub fn bit_lib_copy_bits(
        data: *mut u8,
        position: usize,
        length: usize,
        source: *const u8,
        source_position: usize,
    );
}
extern "C" {
    #[doc = " @brief Reverse bits in bit array\n\n @param data Bit array\n @param position start position\n @param length length of bits to reverse"]
    pub fn bit_lib_reverse_bits(data: *mut u8, position: usize, length: u8);
}
extern "C" {
    #[doc = " @brief Count 1 bits in data\n\n @param data\n @return uint8_t set bit count"]
    pub fn bit_lib_get_bit_count(data: u32) -> u8;
}
extern "C" {
    #[doc = " @brief Print data as bit array\n\n @param data\n @param length"]
    pub fn bit_lib_print_bits(data: *const u8, length: usize);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct BitLibRegion {
    pub mark: core::ffi::c_char,
    pub start: usize,
    pub length: usize,
}
#[test]
fn bindgen_test_layout_BitLibRegion() {
    const UNINIT: ::core::mem::MaybeUninit<BitLibRegion> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<BitLibRegion>(),
        12usize,
        concat!("Size of: ", stringify!(BitLibRegion))
    );
    assert_eq!(
        ::core::mem::align_of::<BitLibRegion>(),
        4usize,
        concat!("Alignment of ", stringify!(BitLibRegion))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).mark) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(BitLibRegion),
            "::",
            stringify!(mark)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).start) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(BitLibRegion),
            "::",
            stringify!(start)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(BitLibRegion),
            "::",
            stringify!(length)
        )
    );
}
extern "C" {
    #[doc = " @brief Print data as bit array and mark regions. Regions needs to be sorted by start position.\n\n @param regions\n @param region_count\n @param data\n @param length"]
    pub fn bit_lib_print_regions(
        regions: *const BitLibRegion,
        region_count: usize,
        data: *const u8,
        length: usize,
    );
}
extern "C" {
    #[doc = " @brief Reverse bits in uint16_t, faster than generic bit_lib_reverse_bits.\n\n @param data\n @return uint16_t"]
    pub fn bit_lib_reverse_16_fast(data: u16) -> u16;
}
extern "C" {
    #[doc = " @brief Reverse bits in uint8_t, faster than generic bit_lib_reverse_bits.\n\n @param byte Byte\n @return uint8_t the reversed byte"]
    pub fn bit_lib_reverse_8_fast(byte: u8) -> u8;
}
extern "C" {
    #[doc = " @brief Slow, but generic CRC8 implementation\n\n @param data\n @param data_size\n @param polynom CRC polynom\n @param init init value\n @param ref_in true if the right bit is older\n @param ref_out true to reverse output\n @param xor_out xor output with this value\n @return uint8_t"]
    pub fn bit_lib_crc8(
        data: *const u8,
        data_size: usize,
        polynom: u8,
        init: u8,
        ref_in: bool,
        ref_out: bool,
        xor_out: u8,
    ) -> u16;
}
extern "C" {
    #[doc = " @brief Slow, but generic CRC16 implementation\n\n @param data\n @param data_size\n @param polynom CRC polynom\n @param init init value\n @param ref_in true if the right bit is older\n @param ref_out true to reverse output\n @param xor_out xor output with this value\n @return uint16_t"]
    pub fn bit_lib_crc16(
        data: *const u8,
        data_size: usize,
        polynom: u16,
        init: u16,
        ref_in: bool,
        ref_out: bool,
        xor_out: u16,
    ) -> u16;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct uECC_Curve_t {
    _unused: [u8; 0],
}
pub type uECC_Curve = *const uECC_Curve_t;
extern "C" {
    pub fn uECC_secp256r1() -> uECC_Curve;
}
pub type uECC_RNG_Function = ::core::option::Option<
    unsafe extern "C" fn(dest: *mut u8, size: core::ffi::c_uint) -> core::ffi::c_int,
>;
extern "C" {
    pub fn uECC_set_rng(rng_function: uECC_RNG_Function);
}
extern "C" {
    pub fn uECC_compute_public_key(
        private_key: *const u8,
        public_key: *mut u8,
        curve: uECC_Curve,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn uECC_sign(
        private_key: *const u8,
        message_hash: *const u8,
        hash_size: core::ffi::c_uint,
        signature: *mut u8,
        curve: uECC_Curve,
    ) -> core::ffi::c_int;
}
extern "C" {
    #[doc = " Allocate file stream\n @return Stream*"]
    pub fn file_stream_alloc(storage: *mut Storage) -> *mut Stream;
}
extern "C" {
    #[doc = " Opens an existing file or create a new one.\n @param stream pointer to file stream object.\n @param path path to file\n @param access_mode access mode from FS_AccessMode\n @param open_mode open mode from FS_OpenMode\n @return success flag. You need to close the file even if the open operation failed."]
    pub fn file_stream_open(
        stream: *mut Stream,
        path: *const core::ffi::c_char,
        access_mode: FS_AccessMode,
        open_mode: FS_OpenMode,
    ) -> bool;
}
extern "C" {
    #[doc = " Closes the file.\n @param stream\n @return true\n @return false"]
    pub fn file_stream_close(stream: *mut Stream) -> bool;
}
extern "C" {
    #[doc = " Retrieves the error id from the file object\n @param stream pointer to stream object.\n @return FS_Error error id"]
    pub fn file_stream_get_error(stream: *mut Stream) -> FS_Error;
}
extern "C" {
    #[doc = " Allocate a file stream with buffered read operations\n @return Stream*"]
    pub fn buffered_file_stream_alloc(storage: *mut Storage) -> *mut Stream;
}
extern "C" {
    #[doc = " Opens an existing file or creates a new one.\n @param stream pointer to file stream object.\n @param path path to file\n @param access_mode access mode from FS_AccessMode\n @param open_mode open mode from FS_OpenMode\n @return True on success, False on failure. You need to close the file even if the open operation failed."]
    pub fn buffered_file_stream_open(
        stream: *mut Stream,
        path: *const core::ffi::c_char,
        access_mode: FS_AccessMode,
        open_mode: FS_OpenMode,
    ) -> bool;
}
extern "C" {
    #[doc = " Closes the file.\n @param stream pointer to file stream object.\n @return True on success, False on failure."]
    pub fn buffered_file_stream_close(stream: *mut Stream) -> bool;
}
extern "C" {
    #[doc = " Forces write from cache to the underlying file.\n @param stream pointer to file stream object.\n @return True on success, False on failure."]
    pub fn buffered_file_stream_sync(stream: *mut Stream) -> bool;
}
extern "C" {
    #[doc = " Retrieves the error id from the file object\n @param stream pointer to stream object.\n @return FS_Error error id"]
    pub fn buffered_file_stream_get_error(stream: *mut Stream) -> FS_Error;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MfClassicDict {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct EmvData {
    pub name: [core::ffi::c_char; 32usize],
    pub aid: [u8; 16usize],
    pub aid_len: u16,
    pub number: [u8; 10usize],
    pub number_len: u8,
    pub exp_mon: u8,
    pub exp_year: u8,
    pub country_code: u16,
    pub currency_code: u16,
}
#[test]
fn bindgen_test_layout_EmvData() {
    const UNINIT: ::core::mem::MaybeUninit<EmvData> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<EmvData>(),
        68usize,
        concat!("Size of: ", stringify!(EmvData))
    );
    assert_eq!(
        ::core::mem::align_of::<EmvData>(),
        2usize,
        concat!("Alignment of ", stringify!(EmvData))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(EmvData),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).aid) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(EmvData),
            "::",
            stringify!(aid)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).aid_len) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(EmvData),
            "::",
            stringify!(aid_len)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).number) as usize - ptr as usize },
        50usize,
        concat!(
            "Offset of field: ",
            stringify!(EmvData),
            "::",
            stringify!(number)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).number_len) as usize - ptr as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(EmvData),
            "::",
            stringify!(number_len)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).exp_mon) as usize - ptr as usize },
        61usize,
        concat!(
            "Offset of field: ",
            stringify!(EmvData),
            "::",
            stringify!(exp_mon)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).exp_year) as usize - ptr as usize },
        62usize,
        concat!(
            "Offset of field: ",
            stringify!(EmvData),
            "::",
            stringify!(exp_year)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).country_code) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(EmvData),
            "::",
            stringify!(country_code)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).currency_code) as usize - ptr as usize },
        66usize,
        concat!(
            "Offset of field: ",
            stringify!(EmvData),
            "::",
            stringify!(currency_code)
        )
    );
}
pub const MfUltralightAuthMethod_MfUltralightAuthMethodManual: MfUltralightAuthMethod = 0;
pub const MfUltralightAuthMethod_MfUltralightAuthMethodAmeebo: MfUltralightAuthMethod = 1;
pub const MfUltralightAuthMethod_MfUltralightAuthMethodXiaomi: MfUltralightAuthMethod = 2;
pub const MfUltralightAuthMethod_MfUltralightAuthMethodAuto: MfUltralightAuthMethod = 3;
pub type MfUltralightAuthMethod = core::ffi::c_uchar;
pub const MfUltralightType_MfUltralightTypeUnknown: MfUltralightType = 0;
pub const MfUltralightType_MfUltralightTypeNTAG203: MfUltralightType = 1;
pub const MfUltralightType_MfUltralightTypeUL11: MfUltralightType = 2;
pub const MfUltralightType_MfUltralightTypeUL21: MfUltralightType = 3;
pub const MfUltralightType_MfUltralightTypeNTAG213: MfUltralightType = 4;
pub const MfUltralightType_MfUltralightTypeNTAG215: MfUltralightType = 5;
pub const MfUltralightType_MfUltralightTypeNTAG216: MfUltralightType = 6;
pub const MfUltralightType_MfUltralightTypeNTAGI2C1K: MfUltralightType = 7;
pub const MfUltralightType_MfUltralightTypeNTAGI2C2K: MfUltralightType = 8;
pub const MfUltralightType_MfUltralightTypeNTAGI2CPlus1K: MfUltralightType = 9;
pub const MfUltralightType_MfUltralightTypeNTAGI2CPlus2K: MfUltralightType = 10;
pub const MfUltralightType_MfUltralightTypeNum: MfUltralightType = 11;
pub type MfUltralightType = core::ffi::c_uchar;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MfUltralightVersion {
    pub header: u8,
    pub vendor_id: u8,
    pub prod_type: u8,
    pub prod_subtype: u8,
    pub prod_ver_major: u8,
    pub prod_ver_minor: u8,
    pub storage_size: u8,
    pub protocol_type: u8,
}
#[test]
fn bindgen_test_layout_MfUltralightVersion() {
    const UNINIT: ::core::mem::MaybeUninit<MfUltralightVersion> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<MfUltralightVersion>(),
        8usize,
        concat!("Size of: ", stringify!(MfUltralightVersion))
    );
    assert_eq!(
        ::core::mem::align_of::<MfUltralightVersion>(),
        1usize,
        concat!("Alignment of ", stringify!(MfUltralightVersion))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).header) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MfUltralightVersion),
            "::",
            stringify!(header)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).vendor_id) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(MfUltralightVersion),
            "::",
            stringify!(vendor_id)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).prod_type) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(MfUltralightVersion),
            "::",
            stringify!(prod_type)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).prod_subtype) as usize - ptr as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(MfUltralightVersion),
            "::",
            stringify!(prod_subtype)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).prod_ver_major) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(MfUltralightVersion),
            "::",
            stringify!(prod_ver_major)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).prod_ver_minor) as usize - ptr as usize },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(MfUltralightVersion),
            "::",
            stringify!(prod_ver_minor)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).storage_size) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(MfUltralightVersion),
            "::",
            stringify!(storage_size)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).protocol_type) as usize - ptr as usize },
        7usize,
        concat!(
            "Offset of field: ",
            stringify!(MfUltralightVersion),
            "::",
            stringify!(protocol_type)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MfUltralightData {
    pub type_: MfUltralightType,
    pub version: MfUltralightVersion,
    pub signature: [u8; 32usize],
    pub counter: [u32; 3usize],
    pub tearing: [u8; 3usize],
    pub auth_method: MfUltralightAuthMethod,
    pub auth_key: [u8; 4usize],
    pub auth_success: bool,
    pub curr_authlim: u16,
    pub data_size: u16,
    pub data: [u8; 2040usize],
    pub data_read: u16,
}
#[test]
fn bindgen_test_layout_MfUltralightData() {
    const UNINIT: ::core::mem::MaybeUninit<MfUltralightData> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<MfUltralightData>(),
        2112usize,
        concat!("Size of: ", stringify!(MfUltralightData))
    );
    assert_eq!(
        ::core::mem::align_of::<MfUltralightData>(),
        4usize,
        concat!("Alignment of ", stringify!(MfUltralightData))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MfUltralightData),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(MfUltralightData),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).signature) as usize - ptr as usize },
        9usize,
        concat!(
            "Offset of field: ",
            stringify!(MfUltralightData),
            "::",
            stringify!(signature)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).counter) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(MfUltralightData),
            "::",
            stringify!(counter)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tearing) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(MfUltralightData),
            "::",
            stringify!(tearing)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).auth_method) as usize - ptr as usize },
        59usize,
        concat!(
            "Offset of field: ",
            stringify!(MfUltralightData),
            "::",
            stringify!(auth_method)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).auth_key) as usize - ptr as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(MfUltralightData),
            "::",
            stringify!(auth_key)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).auth_success) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(MfUltralightData),
            "::",
            stringify!(auth_success)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).curr_authlim) as usize - ptr as usize },
        66usize,
        concat!(
            "Offset of field: ",
            stringify!(MfUltralightData),
            "::",
            stringify!(curr_authlim)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).data_size) as usize - ptr as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(MfUltralightData),
            "::",
            stringify!(data_size)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        70usize,
        concat!(
            "Offset of field: ",
            stringify!(MfUltralightData),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).data_read) as usize - ptr as usize },
        2110usize,
        concat!(
            "Offset of field: ",
            stringify!(MfUltralightData),
            "::",
            stringify!(data_read)
        )
    );
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct MfUltralightAuth {
    pub pwd: MfUltralightAuth__bindgen_ty_1,
    pub pack: MfUltralightAuth__bindgen_ty_2,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union MfUltralightAuth__bindgen_ty_1 {
    pub raw: [u8; 4usize],
    pub value: u32,
}
#[test]
fn bindgen_test_layout_MfUltralightAuth__bindgen_ty_1() {
    const UNINIT: ::core::mem::MaybeUninit<MfUltralightAuth__bindgen_ty_1> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<MfUltralightAuth__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(MfUltralightAuth__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<MfUltralightAuth__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(MfUltralightAuth__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).raw) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MfUltralightAuth__bindgen_ty_1),
            "::",
            stringify!(raw)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MfUltralightAuth__bindgen_ty_1),
            "::",
            stringify!(value)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union MfUltralightAuth__bindgen_ty_2 {
    pub raw: [u8; 2usize],
    pub value: u16,
}
#[test]
fn bindgen_test_layout_MfUltralightAuth__bindgen_ty_2() {
    const UNINIT: ::core::mem::MaybeUninit<MfUltralightAuth__bindgen_ty_2> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<MfUltralightAuth__bindgen_ty_2>(),
        2usize,
        concat!("Size of: ", stringify!(MfUltralightAuth__bindgen_ty_2))
    );
    assert_eq!(
        ::core::mem::align_of::<MfUltralightAuth__bindgen_ty_2>(),
        2usize,
        concat!("Alignment of ", stringify!(MfUltralightAuth__bindgen_ty_2))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).raw) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MfUltralightAuth__bindgen_ty_2),
            "::",
            stringify!(raw)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MfUltralightAuth__bindgen_ty_2),
            "::",
            stringify!(value)
        )
    );
}
#[test]
fn bindgen_test_layout_MfUltralightAuth() {
    const UNINIT: ::core::mem::MaybeUninit<MfUltralightAuth> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<MfUltralightAuth>(),
        6usize,
        concat!("Size of: ", stringify!(MfUltralightAuth))
    );
    assert_eq!(
        ::core::mem::align_of::<MfUltralightAuth>(),
        1usize,
        concat!("Alignment of ", stringify!(MfUltralightAuth))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pwd) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MfUltralightAuth),
            "::",
            stringify!(pwd)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pack) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(MfUltralightAuth),
            "::",
            stringify!(pack)
        )
    );
}
pub const MfClassicType_MfClassicType1k: MfClassicType = 0;
pub const MfClassicType_MfClassicType4k: MfClassicType = 1;
pub const MfClassicType_MfClassicTypeMini: MfClassicType = 2;
pub type MfClassicType = core::ffi::c_uchar;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MfClassicBlock {
    pub value: [u8; 16usize],
}
#[test]
fn bindgen_test_layout_MfClassicBlock() {
    const UNINIT: ::core::mem::MaybeUninit<MfClassicBlock> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<MfClassicBlock>(),
        16usize,
        concat!("Size of: ", stringify!(MfClassicBlock))
    );
    assert_eq!(
        ::core::mem::align_of::<MfClassicBlock>(),
        1usize,
        concat!("Alignment of ", stringify!(MfClassicBlock))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MfClassicBlock),
            "::",
            stringify!(value)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MfClassicData {
    pub type_: MfClassicType,
    pub block_read_mask: [u32; 8usize],
    pub key_a_mask: u64,
    pub key_b_mask: u64,
    pub block: [MfClassicBlock; 256usize],
}
#[test]
fn bindgen_test_layout_MfClassicData() {
    const UNINIT: ::core::mem::MaybeUninit<MfClassicData> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<MfClassicData>(),
        4152usize,
        concat!("Size of: ", stringify!(MfClassicData))
    );
    assert_eq!(
        ::core::mem::align_of::<MfClassicData>(),
        8usize,
        concat!("Alignment of ", stringify!(MfClassicData))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MfClassicData),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).block_read_mask) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(MfClassicData),
            "::",
            stringify!(block_read_mask)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).key_a_mask) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(MfClassicData),
            "::",
            stringify!(key_a_mask)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).key_b_mask) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(MfClassicData),
            "::",
            stringify!(key_b_mask)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).block) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(MfClassicData),
            "::",
            stringify!(block)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MifareDesfireVersion {
    pub hw_vendor: u8,
    pub hw_type: u8,
    pub hw_subtype: u8,
    pub hw_major: u8,
    pub hw_minor: u8,
    pub hw_storage: u8,
    pub hw_proto: u8,
    pub sw_vendor: u8,
    pub sw_type: u8,
    pub sw_subtype: u8,
    pub sw_major: u8,
    pub sw_minor: u8,
    pub sw_storage: u8,
    pub sw_proto: u8,
    pub uid: [u8; 7usize],
    pub batch: [u8; 5usize],
    pub prod_week: u8,
    pub prod_year: u8,
}
#[test]
fn bindgen_test_layout_MifareDesfireVersion() {
    const UNINIT: ::core::mem::MaybeUninit<MifareDesfireVersion> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<MifareDesfireVersion>(),
        28usize,
        concat!("Size of: ", stringify!(MifareDesfireVersion))
    );
    assert_eq!(
        ::core::mem::align_of::<MifareDesfireVersion>(),
        1usize,
        concat!("Alignment of ", stringify!(MifareDesfireVersion))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).hw_vendor) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MifareDesfireVersion),
            "::",
            stringify!(hw_vendor)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).hw_type) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(MifareDesfireVersion),
            "::",
            stringify!(hw_type)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).hw_subtype) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(MifareDesfireVersion),
            "::",
            stringify!(hw_subtype)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).hw_major) as usize - ptr as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(MifareDesfireVersion),
            "::",
            stringify!(hw_major)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).hw_minor) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(MifareDesfireVersion),
            "::",
            stringify!(hw_minor)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).hw_storage) as usize - ptr as usize },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(MifareDesfireVersion),
            "::",
            stringify!(hw_storage)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).hw_proto) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(MifareDesfireVersion),
            "::",
            stringify!(hw_proto)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).sw_vendor) as usize - ptr as usize },
        7usize,
        concat!(
            "Offset of field: ",
            stringify!(MifareDesfireVersion),
            "::",
            stringify!(sw_vendor)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).sw_type) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MifareDesfireVersion),
            "::",
            stringify!(sw_type)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).sw_subtype) as usize - ptr as usize },
        9usize,
        concat!(
            "Offset of field: ",
            stringify!(MifareDesfireVersion),
            "::",
            stringify!(sw_subtype)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).sw_major) as usize - ptr as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(MifareDesfireVersion),
            "::",
            stringify!(sw_major)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).sw_minor) as usize - ptr as usize },
        11usize,
        concat!(
            "Offset of field: ",
            stringify!(MifareDesfireVersion),
            "::",
            stringify!(sw_minor)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).sw_storage) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(MifareDesfireVersion),
            "::",
            stringify!(sw_storage)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).sw_proto) as usize - ptr as usize },
        13usize,
        concat!(
            "Offset of field: ",
            stringify!(MifareDesfireVersion),
            "::",
            stringify!(sw_proto)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).uid) as usize - ptr as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(MifareDesfireVersion),
            "::",
            stringify!(uid)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).batch) as usize - ptr as usize },
        21usize,
        concat!(
            "Offset of field: ",
            stringify!(MifareDesfireVersion),
            "::",
            stringify!(batch)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).prod_week) as usize - ptr as usize },
        26usize,
        concat!(
            "Offset of field: ",
            stringify!(MifareDesfireVersion),
            "::",
            stringify!(prod_week)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).prod_year) as usize - ptr as usize },
        27usize,
        concat!(
            "Offset of field: ",
            stringify!(MifareDesfireVersion),
            "::",
            stringify!(prod_year)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MifareDesfireFreeMemory {
    pub bytes: u32,
}
#[test]
fn bindgen_test_layout_MifareDesfireFreeMemory() {
    const UNINIT: ::core::mem::MaybeUninit<MifareDesfireFreeMemory> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<MifareDesfireFreeMemory>(),
        4usize,
        concat!("Size of: ", stringify!(MifareDesfireFreeMemory))
    );
    assert_eq!(
        ::core::mem::align_of::<MifareDesfireFreeMemory>(),
        4usize,
        concat!("Alignment of ", stringify!(MifareDesfireFreeMemory))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bytes) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MifareDesfireFreeMemory),
            "::",
            stringify!(bytes)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MifareDesfireKeyVersion {
    pub id: u8,
    pub version: u8,
    pub next: *mut MifareDesfireKeyVersion,
}
#[test]
fn bindgen_test_layout_MifareDesfireKeyVersion() {
    const UNINIT: ::core::mem::MaybeUninit<MifareDesfireKeyVersion> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<MifareDesfireKeyVersion>(),
        8usize,
        concat!("Size of: ", stringify!(MifareDesfireKeyVersion))
    );
    assert_eq!(
        ::core::mem::align_of::<MifareDesfireKeyVersion>(),
        4usize,
        concat!("Alignment of ", stringify!(MifareDesfireKeyVersion))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MifareDesfireKeyVersion),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(MifareDesfireKeyVersion),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).next) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(MifareDesfireKeyVersion),
            "::",
            stringify!(next)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MifareDesfireKeySettings {
    pub change_key_id: u8,
    pub config_changeable: bool,
    pub free_create_delete: bool,
    pub free_directory_list: bool,
    pub master_key_changeable: bool,
    pub flags: u8,
    pub max_keys: u8,
    pub key_version_head: *mut MifareDesfireKeyVersion,
}
#[test]
fn bindgen_test_layout_MifareDesfireKeySettings() {
    const UNINIT: ::core::mem::MaybeUninit<MifareDesfireKeySettings> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<MifareDesfireKeySettings>(),
        12usize,
        concat!("Size of: ", stringify!(MifareDesfireKeySettings))
    );
    assert_eq!(
        ::core::mem::align_of::<MifareDesfireKeySettings>(),
        4usize,
        concat!("Alignment of ", stringify!(MifareDesfireKeySettings))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).change_key_id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MifareDesfireKeySettings),
            "::",
            stringify!(change_key_id)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).config_changeable) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(MifareDesfireKeySettings),
            "::",
            stringify!(config_changeable)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).free_create_delete) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(MifareDesfireKeySettings),
            "::",
            stringify!(free_create_delete)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).free_directory_list) as usize - ptr as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(MifareDesfireKeySettings),
            "::",
            stringify!(free_directory_list)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).master_key_changeable) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(MifareDesfireKeySettings),
            "::",
            stringify!(master_key_changeable)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(MifareDesfireKeySettings),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).max_keys) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(MifareDesfireKeySettings),
            "::",
            stringify!(max_keys)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).key_version_head) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MifareDesfireKeySettings),
            "::",
            stringify!(key_version_head)
        )
    );
}
pub const MifareDesfireFileType_MifareDesfireFileTypeStandard: MifareDesfireFileType = 0;
pub const MifareDesfireFileType_MifareDesfireFileTypeBackup: MifareDesfireFileType = 1;
pub const MifareDesfireFileType_MifareDesfireFileTypeValue: MifareDesfireFileType = 2;
pub const MifareDesfireFileType_MifareDesfireFileTypeLinearRecord: MifareDesfireFileType = 3;
pub const MifareDesfireFileType_MifareDesfireFileTypeCyclicRecord: MifareDesfireFileType = 4;
pub type MifareDesfireFileType = core::ffi::c_uchar;
pub const MifareDesfireFileCommunicationSettings_MifareDesfireFileCommunicationSettingsPlaintext:
    MifareDesfireFileCommunicationSettings = 0;
pub const MifareDesfireFileCommunicationSettings_MifareDesfireFileCommunicationSettingsAuthenticated : MifareDesfireFileCommunicationSettings = 1 ;
pub const MifareDesfireFileCommunicationSettings_MifareDesfireFileCommunicationSettingsEnciphered : MifareDesfireFileCommunicationSettings = 3 ;
pub type MifareDesfireFileCommunicationSettings = core::ffi::c_uchar;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct MifareDesfireFile {
    pub id: u8,
    pub type_: MifareDesfireFileType,
    pub comm: MifareDesfireFileCommunicationSettings,
    pub access_rights: u16,
    pub settings: MifareDesfireFile__bindgen_ty_1,
    pub contents: *mut u8,
    pub next: *mut MifareDesfireFile,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union MifareDesfireFile__bindgen_ty_1 {
    pub data: MifareDesfireFile__bindgen_ty_1__bindgen_ty_1,
    pub value: MifareDesfireFile__bindgen_ty_1__bindgen_ty_2,
    pub record: MifareDesfireFile__bindgen_ty_1__bindgen_ty_3,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MifareDesfireFile__bindgen_ty_1__bindgen_ty_1 {
    pub size: u32,
}
#[test]
fn bindgen_test_layout_MifareDesfireFile__bindgen_ty_1__bindgen_ty_1() {
    const UNINIT: ::core::mem::MaybeUninit<MifareDesfireFile__bindgen_ty_1__bindgen_ty_1> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<MifareDesfireFile__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(MifareDesfireFile__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<MifareDesfireFile__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(MifareDesfireFile__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MifareDesfireFile__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(size)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MifareDesfireFile__bindgen_ty_1__bindgen_ty_2 {
    pub lo_limit: u32,
    pub hi_limit: u32,
    pub limited_credit_value: u32,
    pub limited_credit_enabled: bool,
}
#[test]
fn bindgen_test_layout_MifareDesfireFile__bindgen_ty_1__bindgen_ty_2() {
    const UNINIT: ::core::mem::MaybeUninit<MifareDesfireFile__bindgen_ty_1__bindgen_ty_2> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<MifareDesfireFile__bindgen_ty_1__bindgen_ty_2>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(MifareDesfireFile__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<MifareDesfireFile__bindgen_ty_1__bindgen_ty_2>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(MifareDesfireFile__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).lo_limit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MifareDesfireFile__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(lo_limit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).hi_limit) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(MifareDesfireFile__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(hi_limit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).limited_credit_value) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MifareDesfireFile__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(limited_credit_value)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).limited_credit_enabled) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(MifareDesfireFile__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(limited_credit_enabled)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MifareDesfireFile__bindgen_ty_1__bindgen_ty_3 {
    pub size: u32,
    pub max: u32,
    pub cur: u32,
}
#[test]
fn bindgen_test_layout_MifareDesfireFile__bindgen_ty_1__bindgen_ty_3() {
    const UNINIT: ::core::mem::MaybeUninit<MifareDesfireFile__bindgen_ty_1__bindgen_ty_3> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<MifareDesfireFile__bindgen_ty_1__bindgen_ty_3>(),
        12usize,
        concat!(
            "Size of: ",
            stringify!(MifareDesfireFile__bindgen_ty_1__bindgen_ty_3)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<MifareDesfireFile__bindgen_ty_1__bindgen_ty_3>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(MifareDesfireFile__bindgen_ty_1__bindgen_ty_3)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MifareDesfireFile__bindgen_ty_1__bindgen_ty_3),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).max) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(MifareDesfireFile__bindgen_ty_1__bindgen_ty_3),
            "::",
            stringify!(max)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).cur) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MifareDesfireFile__bindgen_ty_1__bindgen_ty_3),
            "::",
            stringify!(cur)
        )
    );
}
#[test]
fn bindgen_test_layout_MifareDesfireFile__bindgen_ty_1() {
    const UNINIT: ::core::mem::MaybeUninit<MifareDesfireFile__bindgen_ty_1> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<MifareDesfireFile__bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(MifareDesfireFile__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<MifareDesfireFile__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(MifareDesfireFile__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MifareDesfireFile__bindgen_ty_1),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MifareDesfireFile__bindgen_ty_1),
            "::",
            stringify!(value)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).record) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MifareDesfireFile__bindgen_ty_1),
            "::",
            stringify!(record)
        )
    );
}
#[test]
fn bindgen_test_layout_MifareDesfireFile() {
    const UNINIT: ::core::mem::MaybeUninit<MifareDesfireFile> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<MifareDesfireFile>(),
        32usize,
        concat!("Size of: ", stringify!(MifareDesfireFile))
    );
    assert_eq!(
        ::core::mem::align_of::<MifareDesfireFile>(),
        4usize,
        concat!("Alignment of ", stringify!(MifareDesfireFile))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MifareDesfireFile),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(MifareDesfireFile),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).comm) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(MifareDesfireFile),
            "::",
            stringify!(comm)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).access_rights) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(MifareDesfireFile),
            "::",
            stringify!(access_rights)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).settings) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MifareDesfireFile),
            "::",
            stringify!(settings)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).contents) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(MifareDesfireFile),
            "::",
            stringify!(contents)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).next) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(MifareDesfireFile),
            "::",
            stringify!(next)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MifareDesfireApplication {
    pub id: [u8; 3usize],
    pub key_settings: *mut MifareDesfireKeySettings,
    pub file_head: *mut MifareDesfireFile,
    pub next: *mut MifareDesfireApplication,
}
#[test]
fn bindgen_test_layout_MifareDesfireApplication() {
    const UNINIT: ::core::mem::MaybeUninit<MifareDesfireApplication> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<MifareDesfireApplication>(),
        16usize,
        concat!("Size of: ", stringify!(MifareDesfireApplication))
    );
    assert_eq!(
        ::core::mem::align_of::<MifareDesfireApplication>(),
        4usize,
        concat!("Alignment of ", stringify!(MifareDesfireApplication))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MifareDesfireApplication),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).key_settings) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(MifareDesfireApplication),
            "::",
            stringify!(key_settings)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).file_head) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MifareDesfireApplication),
            "::",
            stringify!(file_head)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).next) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(MifareDesfireApplication),
            "::",
            stringify!(next)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MifareDesfireData {
    pub version: MifareDesfireVersion,
    pub free_memory: *mut MifareDesfireFreeMemory,
    pub master_key_settings: *mut MifareDesfireKeySettings,
    pub app_head: *mut MifareDesfireApplication,
}
#[test]
fn bindgen_test_layout_MifareDesfireData() {
    const UNINIT: ::core::mem::MaybeUninit<MifareDesfireData> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<MifareDesfireData>(),
        40usize,
        concat!("Size of: ", stringify!(MifareDesfireData))
    );
    assert_eq!(
        ::core::mem::align_of::<MifareDesfireData>(),
        4usize,
        concat!("Alignment of ", stringify!(MifareDesfireData))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MifareDesfireData),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).free_memory) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(MifareDesfireData),
            "::",
            stringify!(free_memory)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).master_key_settings) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(MifareDesfireData),
            "::",
            stringify!(master_key_settings)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).app_head) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(MifareDesfireData),
            "::",
            stringify!(app_head)
        )
    );
}
pub type NfcLoadingCallback =
    ::core::option::Option<unsafe extern "C" fn(context: *mut core::ffi::c_void, state: bool)>;
pub const NfcProtocol_NfcDeviceProtocolUnknown: NfcProtocol = 0;
pub const NfcProtocol_NfcDeviceProtocolEMV: NfcProtocol = 1;
pub const NfcProtocol_NfcDeviceProtocolMifareUl: NfcProtocol = 2;
pub const NfcProtocol_NfcDeviceProtocolMifareClassic: NfcProtocol = 3;
pub const NfcProtocol_NfcDeviceProtocolMifareDesfire: NfcProtocol = 4;
pub type NfcProtocol = core::ffi::c_uchar;
pub const NfcDeviceSaveFormat_NfcDeviceSaveFormatUid: NfcDeviceSaveFormat = 0;
pub const NfcDeviceSaveFormat_NfcDeviceSaveFormatBankCard: NfcDeviceSaveFormat = 1;
pub const NfcDeviceSaveFormat_NfcDeviceSaveFormatMifareUl: NfcDeviceSaveFormat = 2;
pub const NfcDeviceSaveFormat_NfcDeviceSaveFormatMifareClassic: NfcDeviceSaveFormat = 3;
pub const NfcDeviceSaveFormat_NfcDeviceSaveFormatMifareDesfire: NfcDeviceSaveFormat = 4;
pub type NfcDeviceSaveFormat = core::ffi::c_uchar;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NfcReaderRequestData {
    pub data: [u8; 64usize],
    pub size: u16,
}
#[test]
fn bindgen_test_layout_NfcReaderRequestData() {
    const UNINIT: ::core::mem::MaybeUninit<NfcReaderRequestData> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<NfcReaderRequestData>(),
        66usize,
        concat!("Size of: ", stringify!(NfcReaderRequestData))
    );
    assert_eq!(
        ::core::mem::align_of::<NfcReaderRequestData>(),
        2usize,
        concat!("Alignment of ", stringify!(NfcReaderRequestData))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NfcReaderRequestData),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(NfcReaderRequestData),
            "::",
            stringify!(size)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NfcMfClassicDictAttackData {
    pub dict: *mut MfClassicDict,
    pub current_sector: u8,
}
#[test]
fn bindgen_test_layout_NfcMfClassicDictAttackData() {
    const UNINIT: ::core::mem::MaybeUninit<NfcMfClassicDictAttackData> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<NfcMfClassicDictAttackData>(),
        8usize,
        concat!("Size of: ", stringify!(NfcMfClassicDictAttackData))
    );
    assert_eq!(
        ::core::mem::align_of::<NfcMfClassicDictAttackData>(),
        4usize,
        concat!("Alignment of ", stringify!(NfcMfClassicDictAttackData))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).dict) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NfcMfClassicDictAttackData),
            "::",
            stringify!(dict)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).current_sector) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(NfcMfClassicDictAttackData),
            "::",
            stringify!(current_sector)
        )
    );
}
pub const NfcReadMode_NfcReadModeAuto: NfcReadMode = 0;
pub const NfcReadMode_NfcReadModeMfClassic: NfcReadMode = 1;
pub const NfcReadMode_NfcReadModeMfUltralight: NfcReadMode = 2;
pub const NfcReadMode_NfcReadModeMfDesfire: NfcReadMode = 3;
pub const NfcReadMode_NfcReadModeEMV: NfcReadMode = 4;
pub const NfcReadMode_NfcReadModeNFCA: NfcReadMode = 5;
pub type NfcReadMode = core::ffi::c_uchar;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct NfcDeviceData {
    pub nfc_data: FuriHalNfcDevData,
    pub protocol: NfcProtocol,
    pub read_mode: NfcReadMode,
    pub __bindgen_anon_1: NfcDeviceData__bindgen_ty_1,
    pub __bindgen_anon_2: NfcDeviceData__bindgen_ty_2,
    pub parsed_data: *mut FuriString,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union NfcDeviceData__bindgen_ty_1 {
    pub reader_data: NfcReaderRequestData,
    pub mf_classic_dict_attack_data: NfcMfClassicDictAttackData,
    pub mf_ul_auth: MfUltralightAuth,
}
#[test]
fn bindgen_test_layout_NfcDeviceData__bindgen_ty_1() {
    const UNINIT: ::core::mem::MaybeUninit<NfcDeviceData__bindgen_ty_1> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<NfcDeviceData__bindgen_ty_1>(),
        68usize,
        concat!("Size of: ", stringify!(NfcDeviceData__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<NfcDeviceData__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(NfcDeviceData__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reader_data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NfcDeviceData__bindgen_ty_1),
            "::",
            stringify!(reader_data)
        )
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).mf_classic_dict_attack_data) as usize - ptr as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NfcDeviceData__bindgen_ty_1),
            "::",
            stringify!(mf_classic_dict_attack_data)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).mf_ul_auth) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NfcDeviceData__bindgen_ty_1),
            "::",
            stringify!(mf_ul_auth)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union NfcDeviceData__bindgen_ty_2 {
    pub emv_data: EmvData,
    pub mf_ul_data: MfUltralightData,
    pub mf_classic_data: MfClassicData,
    pub mf_df_data: MifareDesfireData,
}
#[test]
fn bindgen_test_layout_NfcDeviceData__bindgen_ty_2() {
    const UNINIT: ::core::mem::MaybeUninit<NfcDeviceData__bindgen_ty_2> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<NfcDeviceData__bindgen_ty_2>(),
        4152usize,
        concat!("Size of: ", stringify!(NfcDeviceData__bindgen_ty_2))
    );
    assert_eq!(
        ::core::mem::align_of::<NfcDeviceData__bindgen_ty_2>(),
        8usize,
        concat!("Alignment of ", stringify!(NfcDeviceData__bindgen_ty_2))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).emv_data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NfcDeviceData__bindgen_ty_2),
            "::",
            stringify!(emv_data)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).mf_ul_data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NfcDeviceData__bindgen_ty_2),
            "::",
            stringify!(mf_ul_data)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).mf_classic_data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NfcDeviceData__bindgen_ty_2),
            "::",
            stringify!(mf_classic_data)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).mf_df_data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NfcDeviceData__bindgen_ty_2),
            "::",
            stringify!(mf_df_data)
        )
    );
}
#[test]
fn bindgen_test_layout_NfcDeviceData() {
    const UNINIT: ::core::mem::MaybeUninit<NfcDeviceData> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<NfcDeviceData>(),
        4256usize,
        concat!("Size of: ", stringify!(NfcDeviceData))
    );
    assert_eq!(
        ::core::mem::align_of::<NfcDeviceData>(),
        8usize,
        concat!("Alignment of ", stringify!(NfcDeviceData))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).nfc_data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NfcDeviceData),
            "::",
            stringify!(nfc_data)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).protocol) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(NfcDeviceData),
            "::",
            stringify!(protocol)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).read_mode) as usize - ptr as usize },
        25usize,
        concat!(
            "Offset of field: ",
            stringify!(NfcDeviceData),
            "::",
            stringify!(read_mode)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).parsed_data) as usize - ptr as usize },
        4248usize,
        concat!(
            "Offset of field: ",
            stringify!(NfcDeviceData),
            "::",
            stringify!(parsed_data)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct NfcDevice {
    pub storage: *mut Storage,
    pub dialogs: *mut DialogsApp,
    pub dev_data: NfcDeviceData,
    pub dev_name: [core::ffi::c_char; 23usize],
    pub load_path: *mut FuriString,
    pub folder: *mut FuriString,
    pub format: NfcDeviceSaveFormat,
    pub shadow_file_exist: bool,
    pub loading_cb: NfcLoadingCallback,
    pub loading_cb_ctx: *mut core::ffi::c_void,
}
#[test]
fn bindgen_test_layout_NfcDevice() {
    const UNINIT: ::core::mem::MaybeUninit<NfcDevice> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<NfcDevice>(),
        4312usize,
        concat!("Size of: ", stringify!(NfcDevice))
    );
    assert_eq!(
        ::core::mem::align_of::<NfcDevice>(),
        8usize,
        concat!("Alignment of ", stringify!(NfcDevice))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).storage) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NfcDevice),
            "::",
            stringify!(storage)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).dialogs) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(NfcDevice),
            "::",
            stringify!(dialogs)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).dev_data) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(NfcDevice),
            "::",
            stringify!(dev_data)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).dev_name) as usize - ptr as usize },
        4264usize,
        concat!(
            "Offset of field: ",
            stringify!(NfcDevice),
            "::",
            stringify!(dev_name)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).load_path) as usize - ptr as usize },
        4288usize,
        concat!(
            "Offset of field: ",
            stringify!(NfcDevice),
            "::",
            stringify!(load_path)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).folder) as usize - ptr as usize },
        4292usize,
        concat!(
            "Offset of field: ",
            stringify!(NfcDevice),
            "::",
            stringify!(folder)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).format) as usize - ptr as usize },
        4296usize,
        concat!(
            "Offset of field: ",
            stringify!(NfcDevice),
            "::",
            stringify!(format)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).shadow_file_exist) as usize - ptr as usize },
        4297usize,
        concat!(
            "Offset of field: ",
            stringify!(NfcDevice),
            "::",
            stringify!(shadow_file_exist)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).loading_cb) as usize - ptr as usize },
        4300usize,
        concat!(
            "Offset of field: ",
            stringify!(NfcDevice),
            "::",
            stringify!(loading_cb)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).loading_cb_ctx) as usize - ptr as usize },
        4304usize,
        concat!(
            "Offset of field: ",
            stringify!(NfcDevice),
            "::",
            stringify!(loading_cb_ctx)
        )
    );
}
extern "C" {
    pub fn nfc_device_alloc() -> *mut NfcDevice;
}
extern "C" {
    pub fn nfc_device_free(nfc_dev: *mut NfcDevice);
}
extern "C" {
    pub fn nfc_device_set_name(dev: *mut NfcDevice, name: *const core::ffi::c_char);
}
extern "C" {
    pub fn nfc_device_save(dev: *mut NfcDevice, dev_name: *const core::ffi::c_char) -> bool;
}
extern "C" {
    pub fn nfc_device_save_shadow(dev: *mut NfcDevice, dev_name: *const core::ffi::c_char) -> bool;
}
extern "C" {
    pub fn nfc_device_load(
        dev: *mut NfcDevice,
        file_path: *const core::ffi::c_char,
        show_dialog: bool,
    ) -> bool;
}
extern "C" {
    pub fn nfc_device_load_key_cache(dev: *mut NfcDevice) -> bool;
}
extern "C" {
    pub fn nfc_file_select(dev: *mut NfcDevice) -> bool;
}
extern "C" {
    pub fn nfc_device_data_clear(dev: *mut NfcDeviceData);
}
extern "C" {
    pub fn nfc_device_clear(dev: *mut NfcDevice);
}
extern "C" {
    pub fn nfc_device_delete(dev: *mut NfcDevice, use_load_path: bool) -> bool;
}
extern "C" {
    pub fn nfc_device_restore(dev: *mut NfcDevice, use_load_path: bool) -> bool;
}
extern "C" {
    pub fn nfc_device_set_loading_callback(
        dev: *mut NfcDevice,
        callback: NfcLoadingCallback,
        context: *mut core::ffi::c_void,
    );
}
pub const iButtonKeyType_iButtonKeyDS1990: iButtonKeyType = 0;
pub const iButtonKeyType_iButtonKeyCyfral: iButtonKeyType = 1;
pub const iButtonKeyType_iButtonKeyMetakom: iButtonKeyType = 2;
pub type iButtonKeyType = core::ffi::c_uchar;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct iButtonKey {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " Allocate key\n @return iButtonKey*"]
    pub fn ibutton_key_alloc() -> *mut iButtonKey;
}
extern "C" {
    #[doc = " Free key\n @param key"]
    pub fn ibutton_key_free(key: *mut iButtonKey);
}
extern "C" {
    #[doc = " Copy key\n @param to\n @param from"]
    pub fn ibutton_key_set(to: *mut iButtonKey, from: *const iButtonKey);
}
extern "C" {
    #[doc = " Set key data\n @param key\n @param data\n @param data_count"]
    pub fn ibutton_key_set_data(key: *mut iButtonKey, data: *mut u8, data_count: u8);
}
extern "C" {
    #[doc = " Clear key data\n @param key"]
    pub fn ibutton_key_clear_data(key: *mut iButtonKey);
}
extern "C" {
    #[doc = " Get pointer to key data\n @param key\n @return const uint8_t*"]
    pub fn ibutton_key_get_data_p(key: *mut iButtonKey) -> *const u8;
}
extern "C" {
    #[doc = " Get key data size\n @param key\n @return uint8_t"]
    pub fn ibutton_key_get_data_size(key: *mut iButtonKey) -> u8;
}
extern "C" {
    #[doc = " Set key type\n @param key\n @param key_type"]
    pub fn ibutton_key_set_type(key: *mut iButtonKey, key_type: iButtonKeyType);
}
extern "C" {
    #[doc = " Get key type\n @param key\n @return iButtonKeyType"]
    pub fn ibutton_key_get_type(key: *mut iButtonKey) -> iButtonKeyType;
}
extern "C" {
    #[doc = " Get type string from key type\n @param key_type\n @return const char*"]
    pub fn ibutton_key_get_string_by_type(key_type: iButtonKeyType) -> *const core::ffi::c_char;
}
extern "C" {
    #[doc = " Get key type from string\n @param type_string\n @param key_type\n @return bool"]
    pub fn ibutton_key_get_type_by_string(
        type_string: *const core::ffi::c_char,
        key_type: *mut iButtonKeyType,
    ) -> bool;
}
extern "C" {
    #[doc = " Get key data size from type\n @param key_type\n @return uint8_t"]
    pub fn ibutton_key_get_size_by_type(key_type: iButtonKeyType) -> u8;
}
extern "C" {
    #[doc = " Get max key size\n @return uint8_t"]
    pub fn ibutton_key_get_max_size() -> u8;
}
extern "C" {
    #[doc = " Check if CRC for onewire key is valid\n @param key\n @return true\n @return false"]
    pub fn ibutton_key_dallas_crc_is_valid(key: *mut iButtonKey) -> bool;
}
extern "C" {
    #[doc = " Check if onewire key is a DS1990 key\n @param key\n @return true\n @return false"]
    pub fn ibutton_key_dallas_is_1990_key(key: *mut iButtonKey) -> bool;
}
pub const iButtonWorkerWriteResult_iButtonWorkerWriteOK: iButtonWorkerWriteResult = 0;
pub const iButtonWorkerWriteResult_iButtonWorkerWriteSameKey: iButtonWorkerWriteResult = 1;
pub const iButtonWorkerWriteResult_iButtonWorkerWriteNoDetect: iButtonWorkerWriteResult = 2;
pub const iButtonWorkerWriteResult_iButtonWorkerWriteCannotWrite: iButtonWorkerWriteResult = 3;
pub type iButtonWorkerWriteResult = core::ffi::c_uchar;
pub type iButtonWorkerReadCallback =
    ::core::option::Option<unsafe extern "C" fn(context: *mut core::ffi::c_void)>;
pub type iButtonWorkerWriteCallback = ::core::option::Option<
    unsafe extern "C" fn(context: *mut core::ffi::c_void, result: iButtonWorkerWriteResult),
>;
pub type iButtonWorkerEmulateCallback =
    ::core::option::Option<unsafe extern "C" fn(context: *mut core::ffi::c_void, emulated: bool)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct iButtonWorker {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " Allocate ibutton worker\n @return iButtonWorker*"]
    pub fn ibutton_worker_alloc() -> *mut iButtonWorker;
}
extern "C" {
    #[doc = " Free ibutton worker\n @param worker"]
    pub fn ibutton_worker_free(worker: *mut iButtonWorker);
}
extern "C" {
    #[doc = " Start ibutton worker thread\n @param worker"]
    pub fn ibutton_worker_start_thread(worker: *mut iButtonWorker);
}
extern "C" {
    #[doc = " Stop ibutton worker thread\n @param worker"]
    pub fn ibutton_worker_stop_thread(worker: *mut iButtonWorker);
}
extern "C" {
    #[doc = " Set \"read success\" callback\n @param worker\n @param callback\n @param context"]
    pub fn ibutton_worker_read_set_callback(
        worker: *mut iButtonWorker,
        callback: iButtonWorkerReadCallback,
        context: *mut core::ffi::c_void,
    );
}
extern "C" {
    #[doc = " Start read mode\n @param worker\n @param key"]
    pub fn ibutton_worker_read_start(worker: *mut iButtonWorker, key: *mut iButtonKey);
}
extern "C" {
    #[doc = " Set \"write event\" callback\n @param worker\n @param callback\n @param context"]
    pub fn ibutton_worker_write_set_callback(
        worker: *mut iButtonWorker,
        callback: iButtonWorkerWriteCallback,
        context: *mut core::ffi::c_void,
    );
}
extern "C" {
    #[doc = " Start write mode\n @param worker\n @param key"]
    pub fn ibutton_worker_write_start(worker: *mut iButtonWorker, key: *mut iButtonKey);
}
extern "C" {
    #[doc = " Set \"emulate success\" callback\n @param worker\n @param callback\n @param context"]
    pub fn ibutton_worker_emulate_set_callback(
        worker: *mut iButtonWorker,
        callback: iButtonWorkerEmulateCallback,
        context: *mut core::ffi::c_void,
    );
}
extern "C" {
    #[doc = " Start emulate mode\n @param worker\n @param key"]
    pub fn ibutton_worker_emulate_start(worker: *mut iButtonWorker, key: *mut iButtonKey);
}
extern "C" {
    #[doc = " Stop all modes\n @param worker"]
    pub fn ibutton_worker_stop(worker: *mut iButtonWorker);
}
extern "C" {
    pub fn maxim_crc8(data: *const u8, data_size: u8, crc_init: u8) -> u8;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OneWireSlave {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OneWireDevice {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " Allocate onewire device with ID\n @param id_1\n @param id_2\n @param id_3\n @param id_4\n @param id_5\n @param id_6\n @param id_7\n @param id_8\n @return OneWireDevice*"]
    pub fn onewire_device_alloc(
        id_1: u8,
        id_2: u8,
        id_3: u8,
        id_4: u8,
        id_5: u8,
        id_6: u8,
        id_7: u8,
        id_8: u8,
    ) -> *mut OneWireDevice;
}
extern "C" {
    #[doc = " Deallocate onewire device\n @param device"]
    pub fn onewire_device_free(device: *mut OneWireDevice);
}
extern "C" {
    #[doc = " Send ID report, called from onewire slave\n @param device"]
    pub fn onewire_device_send_id(device: *mut OneWireDevice);
}
extern "C" {
    #[doc = " Attach device to onewire slave bus\n @param device\n @param bus"]
    pub fn onewire_device_attach(device: *mut OneWireDevice, bus: *mut OneWireSlave);
}
extern "C" {
    #[doc = " Attach device from onewire slave bus\n @param device"]
    pub fn onewire_device_detach(device: *mut OneWireDevice);
}
extern "C" {
    #[doc = " Get pointer to device id array\n @param device\n @return uint8_t*"]
    pub fn onewire_device_get_id_p(device: *mut OneWireDevice) -> *mut u8;
}
#[doc = "< Search for alarmed device"]
pub const OneWireHostSearchMode_CONDITIONAL_SEARCH: OneWireHostSearchMode = 0;
#[doc = "< Search all devices"]
pub const OneWireHostSearchMode_NORMAL_SEARCH: OneWireHostSearchMode = 1;
pub type OneWireHostSearchMode = core::ffi::c_uchar;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OneWireHost {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " Allocate onewire host bus\n @param pin\n @return OneWireHost*"]
    pub fn onewire_host_alloc(gpio_pin: *const GpioPin) -> *mut OneWireHost;
}
extern "C" {
    #[doc = " Deallocate onewire host bus\n @param host"]
    pub fn onewire_host_free(host: *mut OneWireHost);
}
extern "C" {
    #[doc = " Reset bus\n @param host\n @return bool"]
    pub fn onewire_host_reset(host: *mut OneWireHost) -> bool;
}
extern "C" {
    #[doc = " Read one bit\n @param host\n @return bool"]
    pub fn onewire_host_read_bit(host: *mut OneWireHost) -> bool;
}
extern "C" {
    #[doc = " Read one byte\n @param host\n @return uint8_t"]
    pub fn onewire_host_read(host: *mut OneWireHost) -> u8;
}
extern "C" {
    #[doc = " Read many bytes\n @param host\n @param buffer\n @param count"]
    pub fn onewire_host_read_bytes(host: *mut OneWireHost, buffer: *mut u8, count: u16);
}
extern "C" {
    #[doc = " Write one bit\n @param host\n @param value"]
    pub fn onewire_host_write_bit(host: *mut OneWireHost, value: bool);
}
extern "C" {
    #[doc = " Write one byte\n @param host\n @param value"]
    pub fn onewire_host_write(host: *mut OneWireHost, value: u8);
}
extern "C" {
    #[doc = " Skip ROM command\n @param host"]
    pub fn onewire_host_skip(host: *mut OneWireHost);
}
extern "C" {
    #[doc = " Start working with the bus\n @param host"]
    pub fn onewire_host_start(host: *mut OneWireHost);
}
extern "C" {
    #[doc = " Stop working with the bus\n @param host"]
    pub fn onewire_host_stop(host: *mut OneWireHost);
}
extern "C" {
    #[doc = " @param host"]
    pub fn onewire_host_reset_search(host: *mut OneWireHost);
}
extern "C" {
    #[doc = " @param host\n @param family_code"]
    pub fn onewire_host_target_search(host: *mut OneWireHost, family_code: u8);
}
extern "C" {
    #[doc = " @param host\n @param newAddr\n @param mode\n @return uint8_t"]
    pub fn onewire_host_search(
        host: *mut OneWireHost,
        new_addr: *mut u8,
        mode: OneWireHostSearchMode,
    ) -> u8;
}
pub type OneWireSlaveResultCallback =
    ::core::option::Option<unsafe extern "C" fn(context: *mut core::ffi::c_void)>;
extern "C" {
    #[doc = " Allocate onewire slave\n @param gpio_pin\n @return OneWireSlave*"]
    pub fn onewire_slave_alloc(gpio_pin: *const GpioPin) -> *mut OneWireSlave;
}
extern "C" {
    #[doc = " Free onewire slave\n @param bus"]
    pub fn onewire_slave_free(bus: *mut OneWireSlave);
}
extern "C" {
    #[doc = " Start working with the bus\n @param bus"]
    pub fn onewire_slave_start(bus: *mut OneWireSlave);
}
extern "C" {
    #[doc = " Stop working with the bus\n @param bus"]
    pub fn onewire_slave_stop(bus: *mut OneWireSlave);
}
extern "C" {
    #[doc = " Attach device for emulation\n @param bus\n @param device"]
    pub fn onewire_slave_attach(bus: *mut OneWireSlave, device: *mut OneWireDevice);
}
extern "C" {
    #[doc = " Detach device from bus\n @param bus"]
    pub fn onewire_slave_detach(bus: *mut OneWireSlave);
}
extern "C" {
    #[doc = " Set a callback to report emulation success\n @param bus\n @param result_cb\n @param context"]
    pub fn onewire_slave_set_result_callback(
        bus: *mut OneWireSlave,
        result_cb: OneWireSlaveResultCallback,
        context: *mut core::ffi::c_void,
    );
}
extern "C" {
    pub fn __wrap_printf(format: *const core::ffi::c_char, ...) -> core::ffi::c_int;
}
extern "C" {
    pub fn __wrap_vsnprintf(
        str_: *mut core::ffi::c_char,
        size: usize,
        format: *const core::ffi::c_char,
        args: va_list,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn __wrap_puts(str_: *const core::ffi::c_char) -> core::ffi::c_int;
}
extern "C" {
    pub fn __wrap_putchar(ch: core::ffi::c_int) -> core::ffi::c_int;
}
extern "C" {
    pub fn __wrap_putc(ch: core::ffi::c_int, stream: *mut FILE) -> core::ffi::c_int;
}
extern "C" {
    pub fn __wrap_snprintf(
        str_: *mut core::ffi::c_char,
        size: usize,
        format: *const core::ffi::c_char,
        ...
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn __wrap_fflush(stream: *mut FILE) -> core::ffi::c_int;
}
extern "C" {
    pub fn __wrap___assert(
        file: *const core::ffi::c_char,
        line: core::ffi::c_int,
        e: *const core::ffi::c_char,
    ) -> !;
}
extern "C" {
    pub fn __wrap___assert_func(
        file: *const core::ffi::c_char,
        line: core::ffi::c_int,
        func: *const core::ffi::c_char,
        e: *const core::ffi::c_char,
    ) -> !;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SubGhzBlockDecoder {
    pub parser_step: u32,
    pub te_last: u32,
    pub decode_data: u64,
    pub decode_count_bit: u8,
}
#[test]
fn bindgen_test_layout_SubGhzBlockDecoder() {
    const UNINIT: ::core::mem::MaybeUninit<SubGhzBlockDecoder> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SubGhzBlockDecoder>(),
        24usize,
        concat!("Size of: ", stringify!(SubGhzBlockDecoder))
    );
    assert_eq!(
        ::core::mem::align_of::<SubGhzBlockDecoder>(),
        8usize,
        concat!("Alignment of ", stringify!(SubGhzBlockDecoder))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).parser_step) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SubGhzBlockDecoder),
            "::",
            stringify!(parser_step)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).te_last) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SubGhzBlockDecoder),
            "::",
            stringify!(te_last)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).decode_data) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SubGhzBlockDecoder),
            "::",
            stringify!(decode_data)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).decode_count_bit) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SubGhzBlockDecoder),
            "::",
            stringify!(decode_count_bit)
        )
    );
}
extern "C" {
    #[doc = " Add data bit when decoding.\n @param decoder Pointer to a SubGhzBlockDecoder instance\n @param bit data, 1bit"]
    pub fn subghz_protocol_blocks_add_bit(decoder: *mut SubGhzBlockDecoder, bit: u8);
}
extern "C" {
    #[doc = " Add data to_128 bit when decoding.\n @param decoder Pointer to a SubGhzBlockDecoder instance\n @param head_64_bit Pointer to a head_64_bit\n @param bit data, 1bit"]
    pub fn subghz_protocol_blocks_add_to_128_bit(
        decoder: *mut SubGhzBlockDecoder,
        bit: u8,
        head_64_bit: *mut u64,
    );
}
extern "C" {
    #[doc = " Getting the hash sum of the last randomly received parcel.\n @param decoder Pointer to a SubGhzBlockDecoder instance\n @return hash Hash sum"]
    pub fn subghz_protocol_blocks_get_hash_data(decoder: *mut SubGhzBlockDecoder, len: usize)
        -> u8;
}
pub const SubGhzProtocolBlockAlignBit_SubGhzProtocolBlockAlignBitLeft: SubGhzProtocolBlockAlignBit =
    0;
pub const SubGhzProtocolBlockAlignBit_SubGhzProtocolBlockAlignBitRight:
    SubGhzProtocolBlockAlignBit = 1;
pub type SubGhzProtocolBlockAlignBit = core::ffi::c_uchar;
extern "C" {
    #[doc = " Set data bit when encoding HEX array.\n @param bit_value The value of the bit to be set\n @param data_array Pointer to a HEX array\n @param set_index_bit Number set a bit in the array starting from the left\n @param max_size_array array size, check not to overflow"]
    pub fn subghz_protocol_blocks_set_bit_array(
        bit_value: bool,
        data_array: *mut u8,
        set_index_bit: usize,
        max_size_array: usize,
    );
}
extern "C" {
    #[doc = " Get data bit when encoding HEX array.\n @param data_array Pointer to a HEX array\n @param read_index_bit Number get a bit in the array starting from the left\n @return bool value bit"]
    pub fn subghz_protocol_blocks_get_bit_array(data_array: *mut u8, read_index_bit: usize)
        -> bool;
}
extern "C" {
    #[doc = " Generating an upload from data.\n @param data_array Pointer to a HEX array\n @param count_bit_data_array How many bits in the array are processed\n @param upload Pointer to a LevelDuration\n @param max_size_upload upload size, check not to overflow\n @param duration_bit duration 1 bit\n @param align_bit alignment of useful bits in an array"]
    pub fn subghz_protocol_blocks_get_upload_from_bit_array(
        data_array: *mut u8,
        count_bit_data_array: usize,
        upload: *mut LevelDuration,
        max_size_upload: usize,
        duration_bit: u32,
        align_bit: SubGhzProtocolBlockAlignBit,
    ) -> usize;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SubGhzKeystore {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SubGhzEnvironment {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " Allocate SubGhzEnvironment.\n @return SubGhzEnvironment* pointer to a SubGhzEnvironment instance"]
    pub fn subghz_environment_alloc() -> *mut SubGhzEnvironment;
}
extern "C" {
    #[doc = " Free SubGhzEnvironment.\n @param instance Pointer to a SubGhzEnvironment instance"]
    pub fn subghz_environment_free(instance: *mut SubGhzEnvironment);
}
extern "C" {
    #[doc = " Downloading the manufacture key file.\n @param instance Pointer to a SubGhzEnvironment instance\n @param filename Full path to the file\n @return true On success"]
    pub fn subghz_environment_load_keystore(
        instance: *mut SubGhzEnvironment,
        filename: *const core::ffi::c_char,
    ) -> bool;
}
extern "C" {
    #[doc = " Get pointer to a SubGhzKeystore* instance.\n @return SubGhzEnvironment* pointer to a SubGhzEnvironment instance"]
    pub fn subghz_environment_get_keystore(instance: *mut SubGhzEnvironment)
        -> *mut SubGhzKeystore;
}
extern "C" {
    #[doc = " Set filename to work with Came Atomo.\n @param instance Pointer to a SubGhzEnvironment instance\n @param filename Full path to the file"]
    pub fn subghz_environment_set_came_atomo_rainbow_table_file_name(
        instance: *mut SubGhzEnvironment,
        filename: *const core::ffi::c_char,
    );
}
extern "C" {
    #[doc = " Get filename to work with Came Atomo.\n @param instance Pointer to a SubGhzEnvironment instance\n @return Full path to the file"]
    pub fn subghz_environment_get_came_atomo_rainbow_table_file_name(
        instance: *mut SubGhzEnvironment,
    ) -> *const core::ffi::c_char;
}
extern "C" {
    #[doc = " Set filename to work with Alutech at-4n.\n @param instance Pointer to a SubGhzEnvironment instance\n @param filename Full path to the file"]
    pub fn subghz_environment_set_alutech_at_4n_rainbow_table_file_name(
        instance: *mut SubGhzEnvironment,
        filename: *const core::ffi::c_char,
    );
}
extern "C" {
    #[doc = " Get filename to work with Alutech at-4n.\n @param instance Pointer to a SubGhzEnvironment instance\n @return Full path to the file"]
    pub fn subghz_environment_get_alutech_at_4n_rainbow_table_file_name(
        instance: *mut SubGhzEnvironment,
    ) -> *const core::ffi::c_char;
}
extern "C" {
    #[doc = " Set filename to work with Nice Flor-S.\n @param instance Pointer to a SubGhzEnvironment instance\n @param filename Full path to the file"]
    pub fn subghz_environment_set_nice_flor_s_rainbow_table_file_name(
        instance: *mut SubGhzEnvironment,
        filename: *const core::ffi::c_char,
    );
}
extern "C" {
    #[doc = " Get filename to work with Nice Flor-S.\n @param instance Pointer to a SubGhzEnvironment instance\n @return Full path to the file"]
    pub fn subghz_environment_get_nice_flor_s_rainbow_table_file_name(
        instance: *mut SubGhzEnvironment,
    ) -> *const core::ffi::c_char;
}
extern "C" {
    #[doc = " Set list of protocols to work.\n @param instance Pointer to a SubGhzEnvironment instance\n @param protocol_registry_items Pointer to a SubGhzProtocolRegistry"]
    pub fn subghz_environment_set_protocol_registry(
        instance: *mut SubGhzEnvironment,
        protocol_registry_items: *mut core::ffi::c_void,
    );
}
extern "C" {
    #[doc = " Get list of protocols to work.\n @param instance Pointer to a SubGhzEnvironment instance\n @return Pointer to a SubGhzProtocolRegistry"]
    pub fn subghz_environment_get_protocol_registry(
        instance: *mut SubGhzEnvironment,
    ) -> *mut core::ffi::c_void;
}
extern "C" {
    #[doc = " Get list of protocols names.\n @param instance Pointer to a SubGhzEnvironment instance\n @param idx index protocols\n @return Pointer to a SubGhzProtocolRegistry"]
    pub fn subghz_environment_get_protocol_name_registry(
        instance: *mut SubGhzEnvironment,
        idx: usize,
    ) -> *const core::ffi::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SubGhzRadioPreset {
    pub name: *mut FuriString,
    pub frequency: u32,
    pub data: *mut u8,
    pub data_size: usize,
}
#[test]
fn bindgen_test_layout_SubGhzRadioPreset() {
    const UNINIT: ::core::mem::MaybeUninit<SubGhzRadioPreset> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SubGhzRadioPreset>(),
        16usize,
        concat!("Size of: ", stringify!(SubGhzRadioPreset))
    );
    assert_eq!(
        ::core::mem::align_of::<SubGhzRadioPreset>(),
        4usize,
        concat!("Alignment of ", stringify!(SubGhzRadioPreset))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SubGhzRadioPreset),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).frequency) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SubGhzRadioPreset),
            "::",
            stringify!(frequency)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SubGhzRadioPreset),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).data_size) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(SubGhzRadioPreset),
            "::",
            stringify!(data_size)
        )
    );
}
pub type SubGhzAlloc = ::core::option::Option<
    unsafe extern "C" fn(environment: *mut SubGhzEnvironment) -> *mut core::ffi::c_void,
>;
pub type SubGhzFree = ::core::option::Option<unsafe extern "C" fn(context: *mut core::ffi::c_void)>;
pub type SubGhzSerialize = ::core::option::Option<
    unsafe extern "C" fn(
        context: *mut core::ffi::c_void,
        flipper_format: *mut FlipperFormat,
        preset: *mut SubGhzRadioPreset,
    ) -> bool,
>;
pub type SubGhzDeserialize = ::core::option::Option<
    unsafe extern "C" fn(
        context: *mut core::ffi::c_void,
        flipper_format: *mut FlipperFormat,
    ) -> bool,
>;
pub type SubGhzDecoderFeed = ::core::option::Option<
    unsafe extern "C" fn(decoder: *mut core::ffi::c_void, level: bool, duration: u32),
>;
pub type SubGhzDecoderReset =
    ::core::option::Option<unsafe extern "C" fn(decoder: *mut core::ffi::c_void)>;
pub type SubGhzGetHashData =
    ::core::option::Option<unsafe extern "C" fn(decoder: *mut core::ffi::c_void) -> u8>;
pub type SubGhzGetString = ::core::option::Option<
    unsafe extern "C" fn(decoder: *mut core::ffi::c_void, output: *mut FuriString),
>;
pub type SubGhzEncoderStop =
    ::core::option::Option<unsafe extern "C" fn(encoder: *mut core::ffi::c_void)>;
pub type SubGhzEncoderYield =
    ::core::option::Option<unsafe extern "C" fn(context: *mut core::ffi::c_void) -> LevelDuration>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SubGhzProtocolDecoder {
    pub alloc: SubGhzAlloc,
    pub free: SubGhzFree,
    pub feed: SubGhzDecoderFeed,
    pub reset: SubGhzDecoderReset,
    pub get_hash_data: SubGhzGetHashData,
    pub get_string: SubGhzGetString,
    pub serialize: SubGhzSerialize,
    pub deserialize: SubGhzDeserialize,
}
#[test]
fn bindgen_test_layout_SubGhzProtocolDecoder() {
    const UNINIT: ::core::mem::MaybeUninit<SubGhzProtocolDecoder> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SubGhzProtocolDecoder>(),
        32usize,
        concat!("Size of: ", stringify!(SubGhzProtocolDecoder))
    );
    assert_eq!(
        ::core::mem::align_of::<SubGhzProtocolDecoder>(),
        4usize,
        concat!("Alignment of ", stringify!(SubGhzProtocolDecoder))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).alloc) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SubGhzProtocolDecoder),
            "::",
            stringify!(alloc)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).free) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SubGhzProtocolDecoder),
            "::",
            stringify!(free)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).feed) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SubGhzProtocolDecoder),
            "::",
            stringify!(feed)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reset) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(SubGhzProtocolDecoder),
            "::",
            stringify!(reset)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_hash_data) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SubGhzProtocolDecoder),
            "::",
            stringify!(get_hash_data)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_string) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(SubGhzProtocolDecoder),
            "::",
            stringify!(get_string)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).serialize) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(SubGhzProtocolDecoder),
            "::",
            stringify!(serialize)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).deserialize) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(SubGhzProtocolDecoder),
            "::",
            stringify!(deserialize)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SubGhzProtocolEncoder {
    pub alloc: SubGhzAlloc,
    pub free: SubGhzFree,
    pub deserialize: SubGhzDeserialize,
    pub stop: SubGhzEncoderStop,
    pub yield_: SubGhzEncoderYield,
}
#[test]
fn bindgen_test_layout_SubGhzProtocolEncoder() {
    const UNINIT: ::core::mem::MaybeUninit<SubGhzProtocolEncoder> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SubGhzProtocolEncoder>(),
        20usize,
        concat!("Size of: ", stringify!(SubGhzProtocolEncoder))
    );
    assert_eq!(
        ::core::mem::align_of::<SubGhzProtocolEncoder>(),
        4usize,
        concat!("Alignment of ", stringify!(SubGhzProtocolEncoder))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).alloc) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SubGhzProtocolEncoder),
            "::",
            stringify!(alloc)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).free) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SubGhzProtocolEncoder),
            "::",
            stringify!(free)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).deserialize) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SubGhzProtocolEncoder),
            "::",
            stringify!(deserialize)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).stop) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(SubGhzProtocolEncoder),
            "::",
            stringify!(stop)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).yield_) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SubGhzProtocolEncoder),
            "::",
            stringify!(yield_)
        )
    );
}
pub const SubGhzProtocolType_SubGhzProtocolTypeUnknown: SubGhzProtocolType = 0;
pub const SubGhzProtocolType_SubGhzProtocolTypeStatic: SubGhzProtocolType = 1;
pub const SubGhzProtocolType_SubGhzProtocolTypeDynamic: SubGhzProtocolType = 2;
pub const SubGhzProtocolType_SubGhzProtocolTypeRAW: SubGhzProtocolType = 3;
pub const SubGhzProtocolType_SubGhzProtocolWeatherStation: SubGhzProtocolType = 4;
pub const SubGhzProtocolType_SubGhzProtocolCustom: SubGhzProtocolType = 5;
pub type SubGhzProtocolType = core::ffi::c_uchar;
pub const SubGhzProtocolFlag_SubGhzProtocolFlag_RAW: SubGhzProtocolFlag = 1;
pub const SubGhzProtocolFlag_SubGhzProtocolFlag_Decodable: SubGhzProtocolFlag = 2;
pub const SubGhzProtocolFlag_SubGhzProtocolFlag_315: SubGhzProtocolFlag = 4;
pub const SubGhzProtocolFlag_SubGhzProtocolFlag_433: SubGhzProtocolFlag = 8;
pub const SubGhzProtocolFlag_SubGhzProtocolFlag_868: SubGhzProtocolFlag = 16;
pub const SubGhzProtocolFlag_SubGhzProtocolFlag_AM: SubGhzProtocolFlag = 32;
pub const SubGhzProtocolFlag_SubGhzProtocolFlag_FM: SubGhzProtocolFlag = 64;
pub const SubGhzProtocolFlag_SubGhzProtocolFlag_Save: SubGhzProtocolFlag = 128;
pub const SubGhzProtocolFlag_SubGhzProtocolFlag_Load: SubGhzProtocolFlag = 256;
pub const SubGhzProtocolFlag_SubGhzProtocolFlag_Send: SubGhzProtocolFlag = 512;
pub const SubGhzProtocolFlag_SubGhzProtocolFlag_BinRAW: SubGhzProtocolFlag = 1024;
pub type SubGhzProtocolFlag = core::ffi::c_ushort;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SubGhzProtocol {
    pub name: *const core::ffi::c_char,
    pub type_: SubGhzProtocolType,
    pub flag: SubGhzProtocolFlag,
    pub encoder: *const SubGhzProtocolEncoder,
    pub decoder: *const SubGhzProtocolDecoder,
}
#[test]
fn bindgen_test_layout_SubGhzProtocol() {
    const UNINIT: ::core::mem::MaybeUninit<SubGhzProtocol> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SubGhzProtocol>(),
        16usize,
        concat!("Size of: ", stringify!(SubGhzProtocol))
    );
    assert_eq!(
        ::core::mem::align_of::<SubGhzProtocol>(),
        4usize,
        concat!("Alignment of ", stringify!(SubGhzProtocol))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SubGhzProtocol),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SubGhzProtocol),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flag) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(SubGhzProtocol),
            "::",
            stringify!(flag)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).encoder) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SubGhzProtocol),
            "::",
            stringify!(encoder)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).decoder) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(SubGhzProtocol),
            "::",
            stringify!(decoder)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SubGhzBlockGeneric {
    pub protocol_name: *const core::ffi::c_char,
    pub data: u64,
    pub serial: u32,
    pub data_count_bit: u16,
    pub btn: u8,
    pub cnt: u32,
}
#[test]
fn bindgen_test_layout_SubGhzBlockGeneric() {
    const UNINIT: ::core::mem::MaybeUninit<SubGhzBlockGeneric> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SubGhzBlockGeneric>(),
        32usize,
        concat!("Size of: ", stringify!(SubGhzBlockGeneric))
    );
    assert_eq!(
        ::core::mem::align_of::<SubGhzBlockGeneric>(),
        8usize,
        concat!("Alignment of ", stringify!(SubGhzBlockGeneric))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).protocol_name) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SubGhzBlockGeneric),
            "::",
            stringify!(protocol_name)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SubGhzBlockGeneric),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).serial) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SubGhzBlockGeneric),
            "::",
            stringify!(serial)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).data_count_bit) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(SubGhzBlockGeneric),
            "::",
            stringify!(data_count_bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).btn) as usize - ptr as usize },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(SubGhzBlockGeneric),
            "::",
            stringify!(btn)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).cnt) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(SubGhzBlockGeneric),
            "::",
            stringify!(cnt)
        )
    );
}
extern "C" {
    #[doc = " Get name preset.\n @param preset_name name preset\n @param preset_str Output name preset"]
    pub fn subghz_block_generic_get_preset_name(
        preset_name: *const core::ffi::c_char,
        preset_str: *mut FuriString,
    );
}
extern "C" {
    #[doc = " Serialize data SubGhzBlockGeneric.\n @param instance Pointer to a SubGhzBlockGeneric instance\n @param flipper_format Pointer to a FlipperFormat instance\n @param preset The modulation on which the signal was received, SubGhzRadioPreset\n @return true On success"]
    pub fn subghz_block_generic_serialize(
        instance: *mut SubGhzBlockGeneric,
        flipper_format: *mut FlipperFormat,
        preset: *mut SubGhzRadioPreset,
    ) -> bool;
}
extern "C" {
    #[doc = " Deserialize data SubGhzBlockGeneric.\n @param instance Pointer to a SubGhzBlockGeneric instance\n @param flipper_format Pointer to a FlipperFormat instance\n @return true On success"]
    pub fn subghz_block_generic_deserialize(
        instance: *mut SubGhzBlockGeneric,
        flipper_format: *mut FlipperFormat,
    ) -> bool;
}
extern "C" {
    #[doc = " Flip the data bitwise\n\n @param      key        In data\n @param      bit_count  number of data bits\n\n @return     Reverse data"]
    pub fn subghz_protocol_blocks_reverse_key(key: u64, bit_count: u8) -> u64;
}
extern "C" {
    #[doc = " Get parity the data bitwise\n\n @param      key        In data\n @param      bit_count  number of data bits\n\n @return     parity"]
    pub fn subghz_protocol_blocks_get_parity(key: u64, bit_count: u8) -> u8;
}
extern "C" {
    #[doc = " CRC-4\n\n @param      message     array of bytes to check\n @param      size        number of bytes in message\n @param      polynomial  CRC polynomial\n @param      init        starting crc value\n\n @return     CRC value"]
    pub fn subghz_protocol_blocks_crc4(
        message: *const u8,
        size: usize,
        polynomial: u8,
        init: u8,
    ) -> u8;
}
extern "C" {
    #[doc = " CRC-7\n\n @param      message     array of bytes to check\n @param      size        number of bytes in message\n @param      polynomial  CRC polynomial\n @param      init        starting crc value\n\n @return     CRC value"]
    pub fn subghz_protocol_blocks_crc7(
        message: *const u8,
        size: usize,
        polynomial: u8,
        init: u8,
    ) -> u8;
}
extern "C" {
    #[doc = " Generic Cyclic Redundancy Check CRC-8. Example polynomial: 0x31 = x8 + x5 +\n x4 + 1 (x8 is implicit) Example polynomial: 0x80 = x8 + x7 (a normal\n bit-by-bit parity XOR)\n\n @param      message     array of bytes to check\n @param      size        number of bytes in message\n @param      polynomial  byte is from x^7 to x^0 (x^8 is implicitly one)\n @param      init        starting crc value\n\n @return     CRC value"]
    pub fn subghz_protocol_blocks_crc8(
        message: *const u8,
        size: usize,
        polynomial: u8,
        init: u8,
    ) -> u8;
}
extern "C" {
    #[doc = " \"Little-endian\" Cyclic Redundancy Check CRC-8 LE Input and output are\n reflected, i.e. least significant bit is shifted in first\n\n @param      message     array of bytes to check\n @param      size        number of bytes in message\n @param      polynomial  CRC polynomial\n @param      init        starting crc value\n\n @return     CRC value"]
    pub fn subghz_protocol_blocks_crc8le(
        message: *const u8,
        size: usize,
        polynomial: u8,
        init: u8,
    ) -> u8;
}
extern "C" {
    #[doc = " CRC-16 LSB. Input and output are reflected, i.e. least significant bit is\n shifted in first. Note that poly and init already need to be reflected\n\n @param      message     array of bytes to check\n @param      size        number of bytes in message\n @param      polynomial  CRC polynomial\n @param      init        starting crc value\n\n @return     CRC value"]
    pub fn subghz_protocol_blocks_crc16lsb(
        message: *const u8,
        size: usize,
        polynomial: u16,
        init: u16,
    ) -> u16;
}
extern "C" {
    #[doc = " CRC-16\n\n @param      message     array of bytes to check\n @param      size        number of bytes in message\n @param      polynomial  CRC polynomial\n @param      init        starting crc value\n\n @return     CRC value"]
    pub fn subghz_protocol_blocks_crc16(
        message: *const u8,
        size: usize,
        polynomial: u16,
        init: u16,
    ) -> u16;
}
extern "C" {
    #[doc = " Digest-8 by \"LFSR-based Toeplitz hash\"\n\n @param      message  bytes of message data\n @param      size     number of bytes to digest\n @param      gen      key stream generator, needs to includes the MSB if the\n                      LFSR is rolling\n @param      key      initial key\n\n @return     digest value"]
    pub fn subghz_protocol_blocks_lfsr_digest8(
        message: *const u8,
        size: usize,
        gen: u8,
        key: u8,
    ) -> u8;
}
extern "C" {
    #[doc = " Digest-8 by \"LFSR-based Toeplitz hash\", byte reflect, bit reflect\n\n @param      message  bytes of message data\n @param      size     number of bytes to digest\n @param      gen      key stream generator, needs to includes the MSB if the\n                      LFSR is rolling\n @param      key      initial key\n\n @return     digest value"]
    pub fn subghz_protocol_blocks_lfsr_digest8_reflect(
        message: *const u8,
        size: usize,
        gen: u8,
        key: u8,
    ) -> u8;
}
extern "C" {
    #[doc = " Digest-16 by \"LFSR-based Toeplitz hash\"\n\n @param      message  bytes of message data\n @param      size     number of bytes to digest\n @param      gen      key stream generator, needs to includes the MSB if the\n                      LFSR is rolling\n @param      key      initial key\n\n @return     digest value"]
    pub fn subghz_protocol_blocks_lfsr_digest16(
        message: *const u8,
        size: usize,
        gen: u16,
        key: u16,
    ) -> u16;
}
extern "C" {
    #[doc = " Compute Addition of a number of bytes\n\n @param      message  bytes of message data\n @param      size     number of bytes to sum\n\n @return     summation value"]
    pub fn subghz_protocol_blocks_add_bytes(message: *const u8, size: usize) -> u8;
}
extern "C" {
    #[doc = " Compute bit parity of a single byte (8 bits)\n\n @param      byte  single byte to check\n\n @return     1 odd parity, 0 even parity"]
    pub fn subghz_protocol_blocks_parity8(byte: u8) -> u8;
}
extern "C" {
    #[doc = " Compute bit parity of a number of bytes\n\n @param      message  bytes of message data\n @param      size     number of bytes to sum\n\n @return     1 odd parity, 0 even parity"]
    pub fn subghz_protocol_blocks_parity_bytes(message: *const u8, size: usize) -> u8;
}
extern "C" {
    #[doc = " Compute XOR (byte-wide parity) of a number of bytes\n\n @param      message  bytes of message data\n @param      size     number of bytes to sum\n\n @return     summation value, per bit-position 1 odd parity, 0 even parity"]
    pub fn subghz_protocol_blocks_xor_bytes(message: *const u8, size: usize) -> u8;
}
pub type SubGhzProtocolDecoderBaseRxCallback = ::core::option::Option<
    unsafe extern "C" fn(instance: *mut SubGhzProtocolDecoderBase, context: *mut core::ffi::c_void),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SubGhzProtocolDecoderBase {
    pub protocol: *const SubGhzProtocol,
    pub callback: SubGhzProtocolDecoderBaseRxCallback,
    pub context: *mut core::ffi::c_void,
}
#[test]
fn bindgen_test_layout_SubGhzProtocolDecoderBase() {
    const UNINIT: ::core::mem::MaybeUninit<SubGhzProtocolDecoderBase> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SubGhzProtocolDecoderBase>(),
        12usize,
        concat!("Size of: ", stringify!(SubGhzProtocolDecoderBase))
    );
    assert_eq!(
        ::core::mem::align_of::<SubGhzProtocolDecoderBase>(),
        4usize,
        concat!("Alignment of ", stringify!(SubGhzProtocolDecoderBase))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).protocol) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SubGhzProtocolDecoderBase),
            "::",
            stringify!(protocol)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).callback) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SubGhzProtocolDecoderBase),
            "::",
            stringify!(callback)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).context) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SubGhzProtocolDecoderBase),
            "::",
            stringify!(context)
        )
    );
}
extern "C" {
    #[doc = " Getting a textual representation of the received data.\n @param decoder_base Pointer to a SubGhzProtocolDecoderBase instance\n @param output Resulting text"]
    pub fn subghz_protocol_decoder_base_get_string(
        decoder_base: *mut SubGhzProtocolDecoderBase,
        output: *mut FuriString,
    ) -> bool;
}
extern "C" {
    #[doc = " Serialize data SubGhzProtocolDecoderBase.\n @param decoder_base Pointer to a SubGhzProtocolDecoderBase instance\n @param flipper_format Pointer to a FlipperFormat instance\n @param preset The modulation on which the signal was received, SubGhzRadioPreset\n @return true On success"]
    pub fn subghz_protocol_decoder_base_serialize(
        decoder_base: *mut SubGhzProtocolDecoderBase,
        flipper_format: *mut FlipperFormat,
        preset: *mut SubGhzRadioPreset,
    ) -> bool;
}
extern "C" {
    #[doc = " Getting the hash sum of the last randomly received parcel.\n @param decoder_base Pointer to a SubGhzProtocolDecoderBase instance\n @return hash Hash sum"]
    pub fn subghz_protocol_decoder_base_get_hash_data(
        decoder_base: *mut SubGhzProtocolDecoderBase,
    ) -> u8;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SubGhzProtocolEncoderBase {
    pub protocol: *const SubGhzProtocol,
}
#[test]
fn bindgen_test_layout_SubGhzProtocolEncoderBase() {
    const UNINIT: ::core::mem::MaybeUninit<SubGhzProtocolEncoderBase> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SubGhzProtocolEncoderBase>(),
        4usize,
        concat!("Size of: ", stringify!(SubGhzProtocolEncoderBase))
    );
    assert_eq!(
        ::core::mem::align_of::<SubGhzProtocolEncoderBase>(),
        4usize,
        concat!("Alignment of ", stringify!(SubGhzProtocolEncoderBase))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).protocol) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SubGhzProtocolEncoderBase),
            "::",
            stringify!(protocol)
        )
    );
}
pub type SubGhzProtocolEncoderRAWCallbackEnd =
    ::core::option::Option<unsafe extern "C" fn(context: *mut core::ffi::c_void)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SubGhzProtocolDecoderRAW {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SubGhzProtocolEncoderRAW {
    _unused: [u8; 0],
}
extern "C" {
    pub static subghz_protocol_raw_decoder: SubGhzProtocolDecoder;
}
extern "C" {
    pub static subghz_protocol_raw_encoder: SubGhzProtocolEncoder;
}
extern "C" {
    pub static subghz_protocol_raw: SubGhzProtocol;
}
extern "C" {
    #[doc = " Open file for writing\n @param instance Pointer to a SubGhzProtocolDecoderRAW instance\n @param dev_name  File name\n @param preset The modulation on which the signal was received, SubGhzRadioPreset\n @return true On success"]
    pub fn subghz_protocol_raw_save_to_file_init(
        instance: *mut SubGhzProtocolDecoderRAW,
        dev_name: *const core::ffi::c_char,
        preset: *mut SubGhzRadioPreset,
    ) -> bool;
}
extern "C" {
    #[doc = " Stop writing file to flash\n @param instance Pointer to a SubGhzProtocolDecoderRAW instance"]
    pub fn subghz_protocol_raw_save_to_file_stop(instance: *mut SubGhzProtocolDecoderRAW);
}
extern "C" {
    #[doc = " Get the number of samples received SubGhzProtocolDecoderRAW.\n @param instance Pointer to a SubGhzProtocolDecoderRAW instance\n @return count of samples"]
    pub fn subghz_protocol_raw_get_sample_write(instance: *mut SubGhzProtocolDecoderRAW) -> usize;
}
extern "C" {
    #[doc = " Allocate SubGhzProtocolDecoderRAW.\n @param environment Pointer to a SubGhzEnvironment instance\n @return SubGhzProtocolDecoderRAW* pointer to a SubGhzProtocolDecoderRAW instance"]
    pub fn subghz_protocol_decoder_raw_alloc(
        environment: *mut SubGhzEnvironment,
    ) -> *mut core::ffi::c_void;
}
extern "C" {
    #[doc = " Free SubGhzProtocolDecoderRAW.\n @param context Pointer to a SubGhzProtocolDecoderRAW instance"]
    pub fn subghz_protocol_decoder_raw_free(context: *mut core::ffi::c_void);
}
extern "C" {
    #[doc = " Reset decoder SubGhzProtocolDecoderRAW.\n @param context Pointer to a SubGhzProtocolDecoderRAW instance"]
    pub fn subghz_protocol_decoder_raw_reset(context: *mut core::ffi::c_void);
}
extern "C" {
    #[doc = " Parse a raw sequence of levels and durations received from the air.\n @param context Pointer to a SubGhzProtocolDecoderRAW instance\n @param level Signal level true-high false-low\n @param duration Duration of this level in, us"]
    pub fn subghz_protocol_decoder_raw_feed(
        context: *mut core::ffi::c_void,
        level: bool,
        duration: u32,
    );
}
extern "C" {
    #[doc = " Deserialize data SubGhzProtocolDecoderRAW.\n @param context Pointer to a SubGhzProtocolDecoderRAW instance\n @param flipper_format Pointer to a FlipperFormat instance\n @return true On success"]
    pub fn subghz_protocol_decoder_raw_deserialize(
        context: *mut core::ffi::c_void,
        flipper_format: *mut FlipperFormat,
    ) -> bool;
}
extern "C" {
    #[doc = " Getting a textual representation of the received data.\n @param context Pointer to a SubGhzProtocolDecoderRAW instance\n @param output Resulting text"]
    pub fn subghz_protocol_decoder_raw_get_string(
        context: *mut core::ffi::c_void,
        output: *mut FuriString,
    );
}
extern "C" {
    #[doc = " Allocate SubGhzProtocolEncoderRAW.\n @param environment Pointer to a SubGhzEnvironment instance\n @return SubGhzProtocolEncoderRAW* pointer to a SubGhzProtocolEncoderRAW instance"]
    pub fn subghz_protocol_encoder_raw_alloc(
        environment: *mut SubGhzEnvironment,
    ) -> *mut core::ffi::c_void;
}
extern "C" {
    #[doc = " Free SubGhzProtocolEncoderRAW.\n @param context Pointer to a SubGhzProtocolEncoderRAW instance"]
    pub fn subghz_protocol_encoder_raw_free(context: *mut core::ffi::c_void);
}
extern "C" {
    #[doc = " Forced transmission stop.\n @param context Pointer to a SubGhzProtocolEncoderRAW instance"]
    pub fn subghz_protocol_encoder_raw_stop(context: *mut core::ffi::c_void);
}
extern "C" {
    #[doc = " pause writing to flash.\n @param context Pointer to a SubGhzProtocolEncoderRAW instance\n @param pause pause writing"]
    pub fn subghz_protocol_raw_save_to_file_pause(
        instance: *mut SubGhzProtocolDecoderRAW,
        pause: bool,
    );
}
extern "C" {
    #[doc = " Set callback on completion of file transfer.\n @param instance Pointer to a SubGhzProtocolEncoderRAW instance\n @param callback_end Callback, SubGhzProtocolEncoderRAWCallbackEnd\n @param context_end Context"]
    pub fn subghz_protocol_raw_file_encoder_worker_set_callback_end(
        instance: *mut SubGhzProtocolEncoderRAW,
        callback_end: SubGhzProtocolEncoderRAWCallbackEnd,
        context_end: *mut core::ffi::c_void,
    );
}
extern "C" {
    #[doc = " File generation for RAW work.\n @param flipper_format Pointer to a FlipperFormat instance\n @param file_path File path"]
    pub fn subghz_protocol_raw_gen_fff_data(
        flipper_format: *mut FlipperFormat,
        file_path: *const core::ffi::c_char,
    );
}
extern "C" {
    #[doc = " Deserialize and generating an upload to send.\n @param context Pointer to a SubGhzProtocolEncoderRAW instance\n @param flipper_format Pointer to a FlipperFormat instance\n @return true On success"]
    pub fn subghz_protocol_encoder_raw_deserialize(
        context: *mut core::ffi::c_void,
        flipper_format: *mut FlipperFormat,
    ) -> bool;
}
extern "C" {
    #[doc = " Getting the level and duration of the upload to be loaded into DMA.\n @param context Pointer to a SubGhzProtocolEncoderRAW instance\n @return LevelDuration"]
    pub fn subghz_protocol_encoder_raw_yield(context: *mut core::ffi::c_void) -> LevelDuration;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SubGhzReceiver {
    _unused: [u8; 0],
}
pub type SubGhzReceiverCallback = ::core::option::Option<
    unsafe extern "C" fn(
        decoder: *mut SubGhzReceiver,
        decoder_base: *mut SubGhzProtocolDecoderBase,
        context: *mut core::ffi::c_void,
    ),
>;
extern "C" {
    #[doc = " Allocate and init SubGhzReceiver.\n @param environment Pointer to a SubGhzEnvironment instance\n @return SubGhzReceiver* pointer to a SubGhzReceiver instance"]
    pub fn subghz_receiver_alloc_init(environment: *mut SubGhzEnvironment) -> *mut SubGhzReceiver;
}
extern "C" {
    #[doc = " Free SubGhzReceiver.\n @param instance Pointer to a SubGhzReceiver instance"]
    pub fn subghz_receiver_free(instance: *mut SubGhzReceiver);
}
extern "C" {
    #[doc = " Parse a raw sequence of levels and durations received from the air.\n @param instance Pointer to a SubGhzReceiver instance\n @param level Signal level true-high false-low\n @param duration Duration of this level in, us"]
    pub fn subghz_receiver_decode(instance: *mut SubGhzReceiver, level: bool, duration: u32);
}
extern "C" {
    #[doc = " Reset decoder SubGhzReceiver.\n @param instance Pointer to a SubGhzReceiver instance"]
    pub fn subghz_receiver_reset(instance: *mut SubGhzReceiver);
}
extern "C" {
    #[doc = " Set a callback upon completion of successful decoding of one of the protocols.\n @param instance Pointer to a SubGhzReceiver instance\n @param callback Callback, SubGhzReceiverCallback\n @param context Context"]
    pub fn subghz_receiver_set_rx_callback(
        instance: *mut SubGhzReceiver,
        callback: SubGhzReceiverCallback,
        context: *mut core::ffi::c_void,
    );
}
extern "C" {
    #[doc = " Set the filter of receivers that will work at the moment.\n @param instance Pointer to a SubGhzReceiver instance\n @param filter Filter, SubGhzProtocolFlag"]
    pub fn subghz_receiver_set_filter(instance: *mut SubGhzReceiver, filter: SubGhzProtocolFlag);
}
extern "C" {
    #[doc = " Search for a cattery by his name.\n @param instance Pointer to a SubGhzReceiver instance\n @param decoder_name Receiver name\n @return SubGhzProtocolDecoderBase* pointer to a SubGhzProtocolDecoderBase instance"]
    pub fn subghz_receiver_search_decoder_base_by_name(
        instance: *mut SubGhzReceiver,
        decoder_name: *const core::ffi::c_char,
    ) -> *mut SubGhzProtocolDecoderBase;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SubGhzProtocolRegistry {
    pub items: *mut *const SubGhzProtocol,
    pub size: usize,
}
#[test]
fn bindgen_test_layout_SubGhzProtocolRegistry() {
    const UNINIT: ::core::mem::MaybeUninit<SubGhzProtocolRegistry> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SubGhzProtocolRegistry>(),
        8usize,
        concat!("Size of: ", stringify!(SubGhzProtocolRegistry))
    );
    assert_eq!(
        ::core::mem::align_of::<SubGhzProtocolRegistry>(),
        4usize,
        concat!("Alignment of ", stringify!(SubGhzProtocolRegistry))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).items) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SubGhzProtocolRegistry),
            "::",
            stringify!(items)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SubGhzProtocolRegistry),
            "::",
            stringify!(size)
        )
    );
}
extern "C" {
    #[doc = " Registration by name SubGhzProtocol.\n @param protocol_registry SubGhzProtocolRegistry\n @param name Protocol name\n @return SubGhzProtocol* pointer to a SubGhzProtocol instance"]
    pub fn subghz_protocol_registry_get_by_name(
        protocol_registry: *const SubGhzProtocolRegistry,
        name: *const core::ffi::c_char,
    ) -> *const SubGhzProtocol;
}
extern "C" {
    #[doc = " Registration protocol by index in array SubGhzProtocol.\n @param protocol_registry SubGhzProtocolRegistry\n @param index Protocol by index in array\n @return SubGhzProtocol* pointer to a SubGhzProtocol instance"]
    pub fn subghz_protocol_registry_get_by_index(
        protocol_registry: *const SubGhzProtocolRegistry,
        index: usize,
    ) -> *const SubGhzProtocol;
}
extern "C" {
    #[doc = " Getting the number of registered protocols.\n @param protocol_registry SubGhzProtocolRegistry\n @return Number of protocols"]
    pub fn subghz_protocol_registry_count(
        protocol_registry: *const SubGhzProtocolRegistry,
    ) -> usize;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SubGhzSetting {
    _unused: [u8; 0],
}
extern "C" {
    pub fn subghz_setting_alloc() -> *mut SubGhzSetting;
}
extern "C" {
    pub fn subghz_setting_free(instance: *mut SubGhzSetting);
}
extern "C" {
    pub fn subghz_setting_load(instance: *mut SubGhzSetting, file_path: *const core::ffi::c_char);
}
extern "C" {
    pub fn subghz_setting_get_frequency_count(instance: *mut SubGhzSetting) -> usize;
}
extern "C" {
    pub fn subghz_setting_get_hopper_frequency_count(instance: *mut SubGhzSetting) -> usize;
}
extern "C" {
    pub fn subghz_setting_get_preset_count(instance: *mut SubGhzSetting) -> usize;
}
extern "C" {
    pub fn subghz_setting_get_preset_name(
        instance: *mut SubGhzSetting,
        idx: usize,
    ) -> *const core::ffi::c_char;
}
extern "C" {
    pub fn subghz_setting_get_inx_preset_by_name(
        instance: *mut SubGhzSetting,
        preset_name: *const core::ffi::c_char,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn subghz_setting_get_preset_data(instance: *mut SubGhzSetting, idx: usize) -> *mut u8;
}
extern "C" {
    pub fn subghz_setting_get_preset_data_size(instance: *mut SubGhzSetting, idx: usize) -> usize;
}
extern "C" {
    pub fn subghz_setting_get_preset_data_by_name(
        instance: *mut SubGhzSetting,
        preset_name: *const core::ffi::c_char,
    ) -> *mut u8;
}
extern "C" {
    pub fn subghz_setting_load_custom_preset(
        instance: *mut SubGhzSetting,
        preset_name: *const core::ffi::c_char,
        fff_data_file: *mut FlipperFormat,
    ) -> bool;
}
extern "C" {
    pub fn subghz_setting_delete_custom_preset(
        instance: *mut SubGhzSetting,
        preset_name: *const core::ffi::c_char,
    ) -> bool;
}
extern "C" {
    pub fn subghz_setting_get_frequency(instance: *mut SubGhzSetting, idx: usize) -> u32;
}
extern "C" {
    pub fn subghz_setting_get_hopper_frequency(instance: *mut SubGhzSetting, idx: usize) -> u32;
}
extern "C" {
    pub fn subghz_setting_get_frequency_default_index(instance: *mut SubGhzSetting) -> u32;
}
extern "C" {
    pub fn subghz_setting_get_default_frequency(instance: *mut SubGhzSetting) -> u32;
}
pub type SubGhzTxRxWorkerCallbackHaveRead =
    ::core::option::Option<unsafe extern "C" fn(context: *mut core::ffi::c_void)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SubGhzTxRxWorker {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " SubGhzTxRxWorker, add data to transfer\n @param instance  Pointer to a SubGhzTxRxWorker instance\n @param data      *data\n @param size      data size\n @return bool     true if ok"]
    pub fn subghz_tx_rx_worker_write(
        instance: *mut SubGhzTxRxWorker,
        data: *mut u8,
        size: usize,
    ) -> bool;
}
extern "C" {
    #[doc = " SubGhzTxRxWorker, get available data\n @param instance   Pointer to a SubGhzTxRxWorker instance\n @return size_t    data size"]
    pub fn subghz_tx_rx_worker_available(instance: *mut SubGhzTxRxWorker) -> usize;
}
extern "C" {
    #[doc = " SubGhzTxRxWorker, read data\n @param instance   Pointer to a SubGhzTxRxWorker instance\n @param data       *data\n @param size       max data size, which can be read\n @return size_t    data size, how much is actually read"]
    pub fn subghz_tx_rx_worker_read(
        instance: *mut SubGhzTxRxWorker,
        data: *mut u8,
        size: usize,
    ) -> usize;
}
extern "C" {
    #[doc = " Сallback SubGhzTxRxWorker when there is data to read in an empty buffer\n @param instance Pointer to a SubGhzTxRxWorker instance\n @param callback SubGhzTxRxWorkerCallbackHaveRead callback\n @param context"]
    pub fn subghz_tx_rx_worker_set_callback_have_read(
        instance: *mut SubGhzTxRxWorker,
        callback: SubGhzTxRxWorkerCallbackHaveRead,
        context: *mut core::ffi::c_void,
    );
}
extern "C" {
    #[doc = " Allocate SubGhzTxRxWorker\n @return SubGhzTxRxWorker* Pointer to a SubGhzTxRxWorker instance"]
    pub fn subghz_tx_rx_worker_alloc() -> *mut SubGhzTxRxWorker;
}
extern "C" {
    #[doc = " Free SubGhzTxRxWorker\n @param instance Pointer to a SubGhzTxRxWorker instance"]
    pub fn subghz_tx_rx_worker_free(instance: *mut SubGhzTxRxWorker);
}
extern "C" {
    #[doc = " Start SubGhzTxRxWorker\n @param instance Pointer to a SubGhzTxRxWorker instance\n @return bool - true if ok"]
    pub fn subghz_tx_rx_worker_start(instance: *mut SubGhzTxRxWorker, frequency: u32) -> bool;
}
extern "C" {
    #[doc = " Stop SubGhzTxRxWorker\n @param instance Pointer to a SubGhzTxRxWorker instance"]
    pub fn subghz_tx_rx_worker_stop(instance: *mut SubGhzTxRxWorker);
}
extern "C" {
    #[doc = " Check if worker is running\n @param instance Pointer to a SubGhzTxRxWorker instance\n @return bool - true if running"]
    pub fn subghz_tx_rx_worker_is_running(instance: *mut SubGhzTxRxWorker) -> bool;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SubGhzWorker {
    _unused: [u8; 0],
}
pub type SubGhzWorkerOverrunCallback =
    ::core::option::Option<unsafe extern "C" fn(context: *mut core::ffi::c_void)>;
pub type SubGhzWorkerPairCallback = ::core::option::Option<
    unsafe extern "C" fn(context: *mut core::ffi::c_void, level: bool, duration: u32),
>;
extern "C" {
    pub fn subghz_worker_rx_callback(level: bool, duration: u32, context: *mut core::ffi::c_void);
}
extern "C" {
    #[doc = " Allocate SubGhzWorker.\n @return SubGhzWorker* Pointer to a SubGhzWorker instance"]
    pub fn subghz_worker_alloc() -> *mut SubGhzWorker;
}
extern "C" {
    #[doc = " Free SubGhzWorker.\n @param instance Pointer to a SubGhzWorker instance"]
    pub fn subghz_worker_free(instance: *mut SubGhzWorker);
}
extern "C" {
    #[doc = " Overrun callback SubGhzWorker.\n @param instance Pointer to a SubGhzWorker instance\n @param callback SubGhzWorkerOverrunCallback callback"]
    pub fn subghz_worker_set_overrun_callback(
        instance: *mut SubGhzWorker,
        callback: SubGhzWorkerOverrunCallback,
    );
}
extern "C" {
    #[doc = " Pair callback SubGhzWorker.\n @param instance Pointer to a SubGhzWorker instance\n @param callback SubGhzWorkerOverrunCallback callback"]
    pub fn subghz_worker_set_pair_callback(
        instance: *mut SubGhzWorker,
        callback: SubGhzWorkerPairCallback,
    );
}
extern "C" {
    #[doc = " Context callback SubGhzWorker.\n @param instance Pointer to a SubGhzWorker instance\n @param context"]
    pub fn subghz_worker_set_context(instance: *mut SubGhzWorker, context: *mut core::ffi::c_void);
}
extern "C" {
    #[doc = " Start SubGhzWorker.\n @param instance Pointer to a SubGhzWorker instance"]
    pub fn subghz_worker_start(instance: *mut SubGhzWorker);
}
extern "C" {
    #[doc = " Stop SubGhzWorker\n @param instance Pointer to a SubGhzWorker instance"]
    pub fn subghz_worker_stop(instance: *mut SubGhzWorker);
}
extern "C" {
    #[doc = " Check if worker is running.\n @param instance Pointer to a SubGhzWorker instance\n @return bool - true if running"]
    pub fn subghz_worker_is_running(instance: *mut SubGhzWorker) -> bool;
}
extern "C" {
    #[doc = " Short duration filter setting.\n glues short durations into 1. The default setting is 30 us, if set to 0 the filter will be disabled\n @param instance Pointer to a SubGhzWorker instance\n @param timeout time in us"]
    pub fn subghz_worker_set_filter(instance: *mut SubGhzWorker, timeout: u16);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SubGhzTransmitter {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " Allocate and init SubGhzTransmitter.\n @param environment Pointer to a SubGhzEnvironment instance\n @return SubGhzTransmitter* pointer to a SubGhzTransmitter instance"]
    pub fn subghz_transmitter_alloc_init(
        environment: *mut SubGhzEnvironment,
        protocol_name: *const core::ffi::c_char,
    ) -> *mut SubGhzTransmitter;
}
extern "C" {
    #[doc = " Free SubGhzTransmitter.\n @param instance Pointer to a SubGhzTransmitter instance"]
    pub fn subghz_transmitter_free(instance: *mut SubGhzTransmitter);
}
extern "C" {
    #[doc = " Get protocol instance.\n @param instance Pointer to a SubGhzTransmitter instance"]
    pub fn subghz_transmitter_get_protocol_instance(
        instance: *mut SubGhzTransmitter,
    ) -> *mut SubGhzProtocolEncoderBase;
}
extern "C" {
    #[doc = " Forced transmission stop.\n @param instance Pointer to a SubGhzTransmitter instance"]
    pub fn subghz_transmitter_stop(instance: *mut SubGhzTransmitter) -> bool;
}
extern "C" {
    #[doc = " Deserialize and generating an upload to send.\n @param instance Pointer to a SubGhzTransmitter instance\n @param flipper_format Pointer to a FlipperFormat instance\n @return true On success"]
    pub fn subghz_transmitter_deserialize(
        instance: *mut SubGhzTransmitter,
        flipper_format: *mut FlipperFormat,
    ) -> bool;
}
extern "C" {
    #[doc = " Getting the level and duration of the upload to be loaded into DMA.\n @param context Pointer to a SubGhzTransmitter instance\n @return LevelDuration"]
    pub fn subghz_transmitter_yield(context: *mut core::ffi::c_void) -> LevelDuration;
}
extern "C" {
    #[doc = " Extract int value and trim arguments string\n\n @param args - arguments string\n @param word first argument, output\n @return true - success\n @return false - arguments string does not contain int"]
    pub fn args_read_int_and_trim(args: *mut FuriString, value: *mut core::ffi::c_int) -> bool;
}
extern "C" {
    #[doc = " @brief Extract first argument from arguments string and trim arguments string\n\n @param args arguments string\n @param word first argument, output\n @return true - success\n @return false - arguments string does not contain anything"]
    pub fn args_read_string_and_trim(args: *mut FuriString, word: *mut FuriString) -> bool;
}
extern "C" {
    #[doc = " @brief Extract the first quoted argument from the argument string and trim the argument string. If the argument is not quoted, calls args_read_string_and_trim.\n\n @param args arguments string\n @param word first argument, output, without quotes\n @return true - success\n @return false - arguments string does not contain anything"]
    pub fn args_read_probably_quoted_string_and_trim(
        args: *mut FuriString,
        word: *mut FuriString,
    ) -> bool;
}
extern "C" {
    #[doc = " @brief Convert hex ASCII values to byte array\n\n @param args arguments string\n @param bytes byte array pointer, output\n @param bytes_count needed bytes count\n @return true - success\n @return false - arguments string does not contain enough values, or contain non-hex ASCII values"]
    pub fn args_read_hex_bytes(args: *mut FuriString, bytes: *mut u8, bytes_count: usize) -> bool;
}
extern "C" {
    #[doc = " @brief Get length of first word from arguments string\n\n @param args arguments string\n @return size_t length of first word"]
    pub fn args_get_first_word_length(args: *mut FuriString) -> usize;
}
extern "C" {
    #[doc = " @brief Get length of arguments string\n\n @param args arguments string\n @return size_t length of arguments string"]
    pub fn args_length(args: *mut FuriString) -> usize;
}
extern "C" {
    #[doc = " @brief Convert ASCII hex values to byte\n\n @param hi_nibble ASCII hi nibble character\n @param low_nibble ASCII low nibble character\n @param byte byte pointer, output\n @return bool conversion status"]
    pub fn args_char_to_hex(
        hi_nibble: core::ffi::c_char,
        low_nibble: core::ffi::c_char,
        byte: *mut u8,
    ) -> bool;
}
extern "C" {
    pub fn crc32_calc_buffer(crc: u32, buffer: *const core::ffi::c_void, size: usize) -> u32;
}
pub type FileCrcProgressCb =
    ::core::option::Option<unsafe extern "C" fn(progress: u8, context: *mut core::ffi::c_void)>;
extern "C" {
    pub fn crc32_calc_file(
        file: *mut File,
        progress_cb: FileCrcProgressCb,
        context: *mut core::ffi::c_void,
    ) -> u32;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DirWalk {
    _unused: [u8; 0],
}
#[doc = "< OK"]
pub const DirWalkResult_DirWalkOK: DirWalkResult = 0;
#[doc = "< Error"]
pub const DirWalkResult_DirWalkError: DirWalkResult = 1;
#[doc = "< Last element"]
pub const DirWalkResult_DirWalkLast: DirWalkResult = 2;
pub type DirWalkResult = core::ffi::c_uchar;
pub type DirWalkFilterCb = ::core::option::Option<
    unsafe extern "C" fn(
        name: *const core::ffi::c_char,
        fileinfo: *mut FileInfo,
        ctx: *mut core::ffi::c_void,
    ) -> bool,
>;
extern "C" {
    #[doc = " Allocate DirWalk\n @param storage\n @return DirWalk*"]
    pub fn dir_walk_alloc(storage: *mut Storage) -> *mut DirWalk;
}
extern "C" {
    #[doc = " Free DirWalk\n @param dir_walk"]
    pub fn dir_walk_free(dir_walk: *mut DirWalk);
}
extern "C" {
    #[doc = " Set recursive mode (true by default)\n @param dir_walk\n @param recursive"]
    pub fn dir_walk_set_recursive(dir_walk: *mut DirWalk, recursive: bool);
}
extern "C" {
    #[doc = " Set filter callback (Should return true if the data is valid)\n @param dir_walk\n @param cb\n @param context"]
    pub fn dir_walk_set_filter_cb(
        dir_walk: *mut DirWalk,
        cb: DirWalkFilterCb,
        context: *mut core::ffi::c_void,
    );
}
extern "C" {
    #[doc = " Open directory\n @param dir_walk\n @param path\n @return true\n @return false"]
    pub fn dir_walk_open(dir_walk: *mut DirWalk, path: *const core::ffi::c_char) -> bool;
}
extern "C" {
    #[doc = " Get error id\n @param dir_walk\n @return FS_Error"]
    pub fn dir_walk_get_error(dir_walk: *mut DirWalk) -> FS_Error;
}
extern "C" {
    #[doc = " Read next element from directory\n @param dir_walk\n @param return_path\n @param fileinfo\n @return DirWalkResult"]
    pub fn dir_walk_read(
        dir_walk: *mut DirWalk,
        return_path: *mut FuriString,
        fileinfo: *mut FileInfo,
    ) -> DirWalkResult;
}
extern "C" {
    #[doc = " Close directory\n @param dir_walk"]
    pub fn dir_walk_close(dir_walk: *mut DirWalk);
}
extern "C" {
    #[doc = " Compare two floating point numbers\n @param a         First number to compare\n @param b         Second number to compare\n\n @return          bool true if a equals b, false otherwise"]
    pub fn float_is_equal(a: f32, b: f32) -> bool;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sha256_context {
    pub total: [u32; 2usize],
    pub state: [u32; 8usize],
    pub wbuf: [u32; 16usize],
}
#[test]
fn bindgen_test_layout_sha256_context() {
    const UNINIT: ::core::mem::MaybeUninit<sha256_context> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sha256_context>(),
        104usize,
        concat!("Size of: ", stringify!(sha256_context))
    );
    assert_eq!(
        ::core::mem::align_of::<sha256_context>(),
        4usize,
        concat!("Alignment of ", stringify!(sha256_context))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).total) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sha256_context),
            "::",
            stringify!(total)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).state) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sha256_context),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).wbuf) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(sha256_context),
            "::",
            stringify!(wbuf)
        )
    );
}
extern "C" {
    pub fn sha256(
        input: *const core::ffi::c_uchar,
        ilen: core::ffi::c_uint,
        output: *mut core::ffi::c_uchar,
    );
}
extern "C" {
    pub fn sha256_start(ctx: *mut sha256_context);
}
extern "C" {
    pub fn sha256_finish(ctx: *mut sha256_context, output: *mut core::ffi::c_uchar);
}
extern "C" {
    pub fn sha256_update(
        ctx: *mut sha256_context,
        input: *const core::ffi::c_uchar,
        ilen: core::ffi::c_uint,
    );
}
extern "C" {
    pub fn sha256_process(ctx: *mut sha256_context);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hmac_context {
    pub init_hash: ::core::option::Option<unsafe extern "C" fn(context: *const hmac_context)>,
    pub update_hash: ::core::option::Option<
        unsafe extern "C" fn(
            context: *const hmac_context,
            message: *const u8,
            message_size: core::ffi::c_uint,
        ),
    >,
    pub finish_hash: ::core::option::Option<
        unsafe extern "C" fn(context: *const hmac_context, hash_result: *mut u8),
    >,
    pub block_size: core::ffi::c_uint,
    pub result_size: core::ffi::c_uint,
    pub tmp: *mut u8,
}
#[test]
fn bindgen_test_layout_hmac_context() {
    const UNINIT: ::core::mem::MaybeUninit<hmac_context> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<hmac_context>(),
        24usize,
        concat!("Size of: ", stringify!(hmac_context))
    );
    assert_eq!(
        ::core::mem::align_of::<hmac_context>(),
        4usize,
        concat!("Alignment of ", stringify!(hmac_context))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).init_hash) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hmac_context),
            "::",
            stringify!(init_hash)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).update_hash) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(hmac_context),
            "::",
            stringify!(update_hash)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).finish_hash) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(hmac_context),
            "::",
            stringify!(finish_hash)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).block_size) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(hmac_context),
            "::",
            stringify!(block_size)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).result_size) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(hmac_context),
            "::",
            stringify!(result_size)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tmp) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(hmac_context),
            "::",
            stringify!(tmp)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hmac_sha256_context {
    pub hmac_ctx: hmac_context,
    pub sha_ctx: sha256_context,
    pub tmp: [u8; 128usize],
}
#[test]
fn bindgen_test_layout_hmac_sha256_context() {
    const UNINIT: ::core::mem::MaybeUninit<hmac_sha256_context> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<hmac_sha256_context>(),
        256usize,
        concat!("Size of: ", stringify!(hmac_sha256_context))
    );
    assert_eq!(
        ::core::mem::align_of::<hmac_sha256_context>(),
        4usize,
        concat!("Alignment of ", stringify!(hmac_sha256_context))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).hmac_ctx) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hmac_sha256_context),
            "::",
            stringify!(hmac_ctx)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).sha_ctx) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(hmac_sha256_context),
            "::",
            stringify!(sha_ctx)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tmp) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(hmac_sha256_context),
            "::",
            stringify!(tmp)
        )
    );
}
extern "C" {
    pub fn hmac_sha256_init(ctx: *mut hmac_sha256_context, K: *const u8);
}
extern "C" {
    pub fn hmac_sha256_update(
        ctx: *const hmac_sha256_context,
        message: *const u8,
        message_size: core::ffi::c_uint,
    );
}
extern "C" {
    pub fn hmac_sha256_finish(ctx: *const hmac_sha256_context, K: *const u8, hash_result: *mut u8);
}
pub const ManchesterEvent_ManchesterEventShortLow: ManchesterEvent = 0;
pub const ManchesterEvent_ManchesterEventShortHigh: ManchesterEvent = 2;
pub const ManchesterEvent_ManchesterEventLongLow: ManchesterEvent = 4;
pub const ManchesterEvent_ManchesterEventLongHigh: ManchesterEvent = 6;
pub const ManchesterEvent_ManchesterEventReset: ManchesterEvent = 8;
pub type ManchesterEvent = core::ffi::c_uchar;
pub const ManchesterState_ManchesterStateStart1: ManchesterState = 0;
pub const ManchesterState_ManchesterStateMid1: ManchesterState = 1;
pub const ManchesterState_ManchesterStateMid0: ManchesterState = 2;
pub const ManchesterState_ManchesterStateStart0: ManchesterState = 3;
pub type ManchesterState = core::ffi::c_uchar;
extern "C" {
    pub fn manchester_advance(
        state: ManchesterState,
        event: ManchesterEvent,
        next_state: *mut ManchesterState,
        data: *mut bool,
    ) -> bool;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ManchesterEncoderState {
    pub prev_bit: bool,
    pub step: u8,
}
#[test]
fn bindgen_test_layout_ManchesterEncoderState() {
    const UNINIT: ::core::mem::MaybeUninit<ManchesterEncoderState> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<ManchesterEncoderState>(),
        2usize,
        concat!("Size of: ", stringify!(ManchesterEncoderState))
    );
    assert_eq!(
        ::core::mem::align_of::<ManchesterEncoderState>(),
        1usize,
        concat!("Alignment of ", stringify!(ManchesterEncoderState))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).prev_bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ManchesterEncoderState),
            "::",
            stringify!(prev_bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).step) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(ManchesterEncoderState),
            "::",
            stringify!(step)
        )
    );
}
pub const ManchesterEncoderResult_ManchesterEncoderResultShortLow: ManchesterEncoderResult = 0;
pub const ManchesterEncoderResult_ManchesterEncoderResultLongLow: ManchesterEncoderResult = 1;
pub const ManchesterEncoderResult_ManchesterEncoderResultLongHigh: ManchesterEncoderResult = 2;
pub const ManchesterEncoderResult_ManchesterEncoderResultShortHigh: ManchesterEncoderResult = 3;
pub type ManchesterEncoderResult = core::ffi::c_uchar;
extern "C" {
    pub fn manchester_encoder_reset(state: *mut ManchesterEncoderState);
}
extern "C" {
    pub fn manchester_encoder_advance(
        state: *mut ManchesterEncoderState,
        curr_bit: bool,
        result: *mut ManchesterEncoderResult,
    ) -> bool;
}
extern "C" {
    pub fn manchester_encoder_finish(state: *mut ManchesterEncoderState)
        -> ManchesterEncoderResult;
}
#[doc = " \\brief          MD5 context structure"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct md5_context {
    #[doc = "< number of bytes processed"]
    pub total: [u32; 2usize],
    #[doc = "< intermediate digest state"]
    pub state: [u32; 4usize],
    #[doc = "< data block being processed"]
    pub buffer: [core::ffi::c_uchar; 64usize],
}
#[test]
fn bindgen_test_layout_md5_context() {
    const UNINIT: ::core::mem::MaybeUninit<md5_context> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<md5_context>(),
        88usize,
        concat!("Size of: ", stringify!(md5_context))
    );
    assert_eq!(
        ::core::mem::align_of::<md5_context>(),
        4usize,
        concat!("Alignment of ", stringify!(md5_context))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).total) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(md5_context),
            "::",
            stringify!(total)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).state) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(md5_context),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).buffer) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(md5_context),
            "::",
            stringify!(buffer)
        )
    );
}
extern "C" {
    #[doc = " \\brief          MD5 context setup\n\n \\param ctx      context to be initialized"]
    pub fn md5_starts(ctx: *mut md5_context);
}
extern "C" {
    #[doc = " \\brief          MD5 process buffer\n\n \\param ctx      MD5 context\n \\param input    buffer holding the  data\n \\param ilen     length of the input data"]
    pub fn md5_update(ctx: *mut md5_context, input: *const core::ffi::c_uchar, ilen: usize);
}
extern "C" {
    #[doc = " \\brief          MD5 final digest\n\n \\param ctx      MD5 context\n \\param output   MD5 checksum result"]
    pub fn md5_finish(ctx: *mut md5_context, output: *mut core::ffi::c_uchar);
}
extern "C" {
    pub fn md5_process(ctx: *mut md5_context, data: *const core::ffi::c_uchar);
}
extern "C" {
    #[doc = " \\brief          Output = MD5( input buffer )\n\n \\param input    buffer holding the  data\n \\param ilen     length of the input data\n \\param output   MD5 checksum result"]
    pub fn md5(input: *const core::ffi::c_uchar, ilen: usize, output: *mut core::ffi::c_uchar);
}
extern "C" {
    #[doc = " @brief Extract filename without extension from path.\n\n @param path path string\n @param filename output filename string. Must be initialized before."]
    pub fn path_extract_filename_no_ext(path: *const core::ffi::c_char, filename: *mut FuriString);
}
extern "C" {
    #[doc = " @brief Extract filename string from path.\n\n @param path path string\n @param filename output filename string. Must be initialized before.\n @param trim_ext true - get filename without extension"]
    pub fn path_extract_filename(path: *mut FuriString, filename: *mut FuriString, trim_ext: bool);
}
extern "C" {
    #[doc = " @brief Extract file extension from path.\n\n @param path path string\n @param ext output extension string\n @param ext_len_max maximum extension string length"]
    pub fn path_extract_extension(
        path: *mut FuriString,
        ext: *mut core::ffi::c_char,
        ext_len_max: usize,
    );
}
extern "C" {
    #[doc = " @brief Extract last path component\n\n @param path path string\n @param filename output string. Must be initialized before."]
    pub fn path_extract_basename(path: *const core::ffi::c_char, basename: *mut FuriString);
}
extern "C" {
    #[doc = " @brief Extract path, except for last component\n\n @param path path string\n @param filename output string. Must be initialized before."]
    pub fn path_extract_dirname(path: *const core::ffi::c_char, dirname: *mut FuriString);
}
extern "C" {
    #[doc = " @brief Appends new component to path, adding path delimiter\n\n @param path path string\n @param suffix path part to apply"]
    pub fn path_append(path: *mut FuriString, suffix: *const core::ffi::c_char);
}
extern "C" {
    #[doc = " @brief Appends new component to path, adding path delimiter\n\n @param path first path part\n @param suffix second path part\n @param out_path output string to combine parts into. Must be initialized"]
    pub fn path_concat(
        path: *const core::ffi::c_char,
        suffix: *const core::ffi::c_char,
        out_path: *mut FuriString,
    );
}
extern "C" {
    #[doc = " @brief Check that path contains only ascii characters\n\n @param path\n @return true\n @return false"]
    pub fn path_contains_only_ascii(path: *const core::ffi::c_char) -> bool;
}
extern "C" {
    #[doc = " Generates random name\n @param name buffer to write random name\n @param max_name_size length of given buffer"]
    pub fn set_random_name(name: *mut core::ffi::c_char, max_name_size: u8);
}
extern "C" {
    pub fn saved_struct_load(
        path: *const core::ffi::c_char,
        data: *mut core::ffi::c_void,
        size: usize,
        magic: u8,
        version: u8,
    ) -> bool;
}
extern "C" {
    pub fn saved_struct_save(
        path: *const core::ffi::c_char,
        data: *mut core::ffi::c_void,
        size: usize,
        magic: u8,
        version: u8,
    ) -> bool;
}
extern "C" {
    pub fn saved_struct_get_payload_size(
        path: *const core::ffi::c_char,
        magic: u8,
        version: u8,
        payload_size: *mut usize,
    ) -> bool;
}
extern "C" {
    #[doc = " Allocate string stream\n @return Stream*"]
    pub fn string_stream_alloc() -> *mut Stream;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TarArchive {
    _unused: [u8; 0],
}
pub const TarOpenMode_TAR_OPEN_MODE_READ: TarOpenMode = 114;
pub const TarOpenMode_TAR_OPEN_MODE_WRITE: TarOpenMode = 119;
pub const TarOpenMode_TAR_OPEN_MODE_STDOUT: TarOpenMode = 115;
pub type TarOpenMode = core::ffi::c_uchar;
extern "C" {
    pub fn tar_archive_alloc(storage: *mut Storage) -> *mut TarArchive;
}
extern "C" {
    pub fn tar_archive_open(
        archive: *mut TarArchive,
        path: *const core::ffi::c_char,
        mode: TarOpenMode,
    ) -> bool;
}
extern "C" {
    pub fn tar_archive_free(archive: *mut TarArchive);
}
extern "C" {
    pub fn tar_archive_unpack_to(
        archive: *mut TarArchive,
        destination: *const core::ffi::c_char,
        converter: Storage_name_converter,
    ) -> bool;
}
extern "C" {
    pub fn tar_archive_add_file(
        archive: *mut TarArchive,
        fs_file_path: *const core::ffi::c_char,
        archive_fname: *const core::ffi::c_char,
        file_size: i32,
    ) -> bool;
}
extern "C" {
    pub fn tar_archive_add_dir(
        archive: *mut TarArchive,
        fs_full_path: *const core::ffi::c_char,
        path_prefix: *const core::ffi::c_char,
    ) -> bool;
}
extern "C" {
    pub fn tar_archive_get_entries_count(archive: *mut TarArchive) -> i32;
}
extern "C" {
    pub fn tar_archive_unpack_file(
        archive: *mut TarArchive,
        archive_fname: *const core::ffi::c_char,
        destination: *const core::ffi::c_char,
    ) -> bool;
}
pub type tar_unpack_file_cb = ::core::option::Option<
    unsafe extern "C" fn(
        name: *const core::ffi::c_char,
        is_directory: bool,
        context: *mut core::ffi::c_void,
    ) -> bool,
>;
extern "C" {
    pub fn tar_archive_set_file_callback(
        archive: *mut TarArchive,
        callback: tar_unpack_file_cb,
        context: *mut core::ffi::c_void,
    );
}
extern "C" {
    pub fn tar_archive_dir_add_element(
        archive: *mut TarArchive,
        dirpath: *const core::ffi::c_char,
    ) -> bool;
}
extern "C" {
    pub fn tar_archive_file_add_header(
        archive: *mut TarArchive,
        path: *const core::ffi::c_char,
        data_len: i32,
    ) -> bool;
}
extern "C" {
    pub fn tar_archive_file_add_data_block(
        archive: *mut TarArchive,
        data_block: *const u8,
        block_len: i32,
    ) -> bool;
}
extern "C" {
    pub fn tar_archive_file_finalize(archive: *mut TarArchive) -> bool;
}
extern "C" {
    pub fn tar_archive_store_data(
        archive: *mut TarArchive,
        path: *const core::ffi::c_char,
        data: *const u8,
        data_len: i32,
    ) -> bool;
}
extern "C" {
    pub fn tar_archive_finalize(archive: *mut TarArchive) -> bool;
}
extern "C" {
    #[doc = " Get the index of a uint32_t array element which is closest to the given value.\n\n Returned index corresponds to the first element found.\n If no suitable elements were found, the function returns 0.\n\n @param   value           value to be searched.\n @param   values          pointer to the array to perform the search in.\n @param   values_count    array size.\n\n @return value's index."]
    pub fn value_index_uint32(value: u32, values: *const u32, values_count: u8) -> u8;
}
extern "C" {
    #[doc = " Get the index of a float array element which is closest to the given value.\n\n Returned index corresponds to the first element found.\n If no suitable elements were found, the function returns 0.\n\n @param   value           value to be searched.\n @param   values          pointer to the array to perform the search in.\n @param   values_count    array size.\n\n @return value's index."]
    pub fn value_index_float(value: f32, values: *const f32, values_count: u8) -> u8;
}
extern "C" {
    #[doc = " Get the index of a bool array element which is equal to the given value.\n\n Returned index corresponds to the first element found.\n If no suitable elements were found, the function returns 0.\n\n @param   value           value to be searched.\n @param   values          pointer to the array to perform the search in.\n @param   values_count    array size.\n\n @return value's index."]
    pub fn value_index_bool(value: bool, values: *const bool, values_count: u8) -> u8;
}
